
/*!
 ███╗   ███╗███████╗████████╗██████╗  ██████╗     ██╗   ██╗██╗
 ████╗ ████║██╔════╝╚══██╔══╝██╔══██╗██╔═══██╗    ██║   ██║██║
 ██╔████╔██║█████╗     ██║   ██████╔╝██║   ██║    ██║   ██║██║
 ██║╚██╔╝██║██╔══╝     ██║   ██╔══██╗██║   ██║    ██║   ██║██║
 ██║ ╚═╝ ██║███████╗   ██║   ██║  ██║╚██████╔╝    ╚██████╔╝██║
 ╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝      ╚═════╝ ╚═╝                                                             

 * Metro UI v5.1.0 Components Library  (https://metroui.org.ua)
 * Build: 30.04.2025, 11:02:27
 * Copyright 2012-2025 by Serhii Pimenov
 * Licensed under MIT
 */

(() => {
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };

  // node_modules/@olton/datetime/dist/datetime.js
  var isNum = (v4) => !isNaN(v4);
  var DEFAULT_FORMAT = "YYYY-MM-DDTHH:mm:ss.sss";
  var INVALID_DATE = "Invalid date";
  var REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|m{1,2}|s{1,3}/g;
  var REGEX_FORMAT_STRFTIME = /(%[a-z])/gi;
  var DEFAULT_FORMAT_STRFTIME = "%Y-%m-%dT%H:%M:%S.%Q%t";
  var DEFAULT_LOCALE = {
    months: "January February March April May June July August September October November December".split(" "),
    monthsShort: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
    weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
    weekdaysShort: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
    weekdaysMin: "Su Mo Tu We Th Fr Sa".split(" "),
    weekStart: 0
  };
  var M = {
    ms: "Milliseconds",
    s: "Seconds",
    m: "Minutes",
    h: "Hours",
    D: "Date",
    d: "Day",
    M: "Month",
    Y: "FullYear",
    y: "Year",
    t: "Time"
  };
  var C = {
    ms: "ms",
    s: "second",
    m: "minute",
    h: "hour",
    D: "day",
    W: "week",
    d: "weekDay",
    M: "month",
    Y: "year",
    Y2: "year2",
    t: "time",
    c: "century",
    q: "quarter"
  };
  var required = (m4 = "") => {
    throw new Error("This argument is required!");
  };
  var isset = (v4, nullable = true) => {
    try {
      return nullable ? typeof v4 !== "undefined" : typeof v4 !== "undefined" && v4 !== null;
    } catch (e2) {
      return false;
    }
  };
  var not = (v4) => typeof v4 === "undefined" || v4 === null;
  var lpad = function(str2, pad, length) {
    let _str = "" + str2;
    if (length && _str.length >= length) {
      return _str;
    }
    return Array(length + 1 - _str.length).join(pad) + _str;
  };
  var ua_default = {
    months: "\u0421\u0456\u0447\u0435\u043D\u044C_\u041B\u044E\u0442\u0438\u0439_\u0411\u0435\u0440\u0435\u0437\u0435\u043D\u044C_\u041A\u0432\u0456\u0442\u0435\u043D\u044C_\u0422\u0440\u0430\u0432\u0435\u043D\u044C_\u0427\u0435\u0440\u0432\u0435\u043D\u044C_\u041B\u0438\u043F\u0435\u043D\u044C_\u0421\u0435\u0440\u043F\u0435\u043D\u044C_\u0412\u0435\u0440\u0435\u0441\u0435\u043D\u044C_\u0416\u043E\u0432\u0442\u0435\u043D\u044C_\u041B\u0438\u0441\u0442\u043E\u043F\u0430\u0434_\u0413\u0440\u0443\u0434\u0435\u043D\u044C".split("_"),
    monthsParental: "\u0421\u0456\u0447\u043D\u044F_\u041B\u044E\u0442\u043E\u0433\u043E_\u0411\u0435\u0440\u0435\u0437\u0435\u043D\u044F_\u041A\u0432\u0456\u0442\u043D\u044F_\u0422\u0440\u0430\u0432\u043D\u044F_\u0427\u0435\u0440\u0432\u043D\u044F_\u041B\u0438\u043F\u043D\u044F_\u0421\u0435\u0440\u043F\u043D\u044F_\u0412\u0435\u0440\u0435\u0441\u043D\u044F_\u0416\u043E\u0432\u0442\u043D\u044F_\u041B\u0438\u0441\u0442\u043E\u043F\u0430\u0434\u0430_\u0413\u0440\u0443\u0434\u043D\u044F".split("_"),
    monthsShort: "\u0421\u0456\u0447_\u041B\u044E\u0442_\u0411\u0435\u0440_\u041A\u0432\u0456_\u0422\u0440\u0430_\u0427\u0435\u0440_\u041B\u0438\u043F_\u0421\u0435\u0440_\u0412\u0435\u0440_\u0416\u043E\u0432_\u041B\u0438\u0441_\u0413\u0440\u0443".split("_"),
    weekdays: "\u041D\u0435\u0434\u0456\u043B\u044F_\u041F\u043E\u043D\u0435\u0434\u0456\u043B\u043E\u043A_\u0412\u0456\u0432\u0442\u043E\u0440\u043E\u043A_\u0421\u0435\u0440\u0435\u0434\u0430_\u0427\u0435\u0442\u0432\u0435\u0440_\u041F'\u044F\u0442\u043D\u0438\u0446\u044F_\u0421\u0443\u0431\u043E\u0442\u0430".split("_"),
    weekdaysShort: "\u041D\u0435\u0434_\u041F\u043E\u043D_\u0412\u0456\u0432_\u0421\u0435\u0440_\u0427\u0435\u0442_\u041F\u0442\u043D_\u0421\u0443\u0431".split("_"),
    weekdaysMin: "\u041D\u0434_\u041F\u043D_\u0412\u0442_\u0421\u0440_\u0427\u0442_\u041F\u0442_\u0421\u0431".split("_"),
    weekStart: 1
  };
  var de_default = {
    months: "Januar_Februar_M\xE4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
    monthsShort: "Jan_Feb_M\xE4r_Apr_Mai_Jun_Jul_Aug_Sep_Okt_Nov_Dez".split("_"),
    weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
    weekdaysShort: "Son_Mon_Die_Mit_Don_Fre_Sam".split("_"),
    weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
    weekStart: 1
  };
  var Datetime2 = class _Datetime {
    constructor() {
      const args = [].slice.call(arguments);
      this.value = new (Function.prototype.bind.apply(Date, [this].concat(args)))();
      this.locale = "en";
      this.weekStart = _Datetime.locales["en"].weekStart;
      this.utcMode = false;
      this.mutable = true;
      if (!isNum(this.value.getTime())) {
        throw new Error(INVALID_DATE);
      }
    }
    static locales = {
      en: DEFAULT_LOCALE,
      ua: ua_default,
      de: de_default
    };
    static isDatetime(val) {
      return val instanceof _Datetime;
    }
    static now(asDate = false) {
      return datetime2()[asDate ? "val" : "time"]();
    }
    static parse(str2 = required()) {
      return datetime2(Date.parse(str2));
    }
    static setLocale(name2 = required(), locale = required()) {
      _Datetime.locales[name2] = locale;
    }
    static getLocale(name2 = "en") {
      return isset(_Datetime.locales[name2], false) ? _Datetime.locales[name2] : _Datetime.locales["en"];
    }
    static align(date, align) {
      let _date = datetime2(date), result, temp;
      switch (align) {
        case C.s:
          result = _date.ms(0);
          break;
        //second
        case C.m:
          result = _Datetime.align(_date, C.s)[C.s](0);
          break;
        //minute
        case C.h:
          result = _Datetime.align(_date, C.m)[C.m](0);
          break;
        //hour
        case C.D:
          result = _Datetime.align(_date, C.h)[C.h](0);
          break;
        //day
        case C.M:
          result = _Datetime.align(_date, C.D)[C.D](1);
          break;
        //month
        case C.Y:
          result = _Datetime.align(_date, C.M)[C.M](0);
          break;
        //year
        case C.W: {
          temp = _date.weekDay();
          result = _Datetime.align(date, C.D).addDay(-temp);
          break;
        }
        default:
          result = _date;
      }
      return result;
    }
    static alignEnd(date, align) {
      let _date = datetime2(date), result, temp;
      switch (align) {
        case C.ms:
          result = _date.ms(999);
          break;
        //second
        case C.s:
          result = _Datetime.alignEnd(_date, C.ms);
          break;
        //second
        case C.m:
          result = _Datetime.alignEnd(_date, C.s)[C.s](59);
          break;
        //minute
        case C.h:
          result = _Datetime.alignEnd(_date, C.m)[C.m](59);
          break;
        //hour
        case C.D:
          result = _Datetime.alignEnd(_date, C.h)[C.h](23);
          break;
        //day
        case C.M:
          result = _Datetime.alignEnd(_date, C.D)[C.D](1).add(1, C.M).add(-1, C.D);
          break;
        //month
        case C.Y:
          result = _Datetime.alignEnd(_date, C.D)[C.M](11)[C.D](31);
          break;
        //year
        case C.W: {
          temp = _date.weekDay();
          result = _Datetime.alignEnd(_date, "day").addDay(6 - temp);
          break;
        }
        default:
          result = date;
      }
      return result;
    }
    immutable(v4) {
      this.mutable = !(not(v4) ? true : v4);
      return this;
    }
    utc() {
      this.utcMode = true;
      return this;
    }
    local() {
      this.utcMode = false;
      return this;
    }
    useLocale(val, override) {
      this.locale = override ? val : !isset(_Datetime.locales[val], false) ? "en" : val;
      this.weekStart = _Datetime.getLocale(this.locale).weekStart;
      return this;
    }
    clone() {
      const c3 = datetime2(this.value);
      c3.locale = this.locale;
      c3.weekStart = this.weekStart;
      c3.mutable = this.mutable;
      return c3;
    }
    align(to2) {
      if (this.mutable) {
        this.value = _Datetime.align(this, to2).val();
        return this;
      }
      return this.clone().immutable(false).align(to2).immutable(!this.mutable);
    }
    alignEnd(to2) {
      if (this.mutable) {
        this.value = _Datetime.alignEnd(this, to2).val();
        return this;
      }
      return this.clone().immutable(false).alignEnd(to2).immutable(!this.mutable);
    }
    val(val) {
      if (typeof val === "undefined" || val === null) {
        return this.value;
      }
      if (this.mutable) {
        this.value = typeof val === "string" ? Date.parse(val) : typeof val === "number" ? new Date(val) : val;
        return this;
      }
      return datetime2(val);
    }
    year2() {
      return +("" + this.year()).substring(-2);
    }
    /* Get + Set */
    _set(m4, v4) {
      const fn = "set" + (this.utcMode && m4 !== "t" ? "UTC" : "") + M[m4];
      if (this.mutable) {
        this.value[fn](v4);
        return this;
      }
      const clone = this.clone();
      clone.value[fn](v4);
      return clone;
    }
    _get(m4) {
      const fn = "get" + (this.utcMode && m4 !== "t" ? "UTC" : "") + M[m4];
      return this.value[fn]();
    }
    _work(part, val) {
      if (!arguments.length || (typeof val === "undefined" || val === null)) {
        return this._get(part);
      }
      return this._set(part, val);
    }
    ms(val) {
      return this._work("ms", val);
    }
    second(val) {
      return this._work("s", val);
    }
    minute(val) {
      return this._work("m", val);
    }
    hour(val) {
      return this._work("h", val);
    }
    day(val) {
      return this._work("D", val);
    }
    month(val) {
      return this._work("M", val);
    }
    year(val) {
      return this._work("Y", val);
    }
    time(val) {
      return this._work("t", val);
    }
    weekDay(val) {
      if (!arguments.length || not(val)) {
        return this.utcMode ? this.value.getUTCDay() : this.value.getDay();
      }
      const curr = this.weekDay();
      const diff = val - curr;
      this.day(this.day() + diff);
      return this;
    }
    get(unit) {
      return typeof this[unit] !== "function" ? this : this[unit]();
    }
    set(unit, val) {
      return typeof this[unit] !== "function" ? this : this[unit](val);
    }
    add(val, to2) {
      switch (to2) {
        case C.h:
          return this.time(this.time() + val * 60 * 60 * 1e3);
        case C.m:
          return this.time(this.time() + val * 60 * 1e3);
        case C.s:
          return this.time(this.time() + val * 1e3);
        case C.ms:
          return this.time(this.time() + val);
        case C.D:
          return this.day(this.day() + val);
        case C.W:
          return this.day(this.day() + val * 7);
        case C.M:
          return this.month(this.month() + val);
        case C.Y:
          return this.year(this.year() + val);
      }
    }
    addHour(v4) {
      return this.add(v4, C.h);
    }
    addMinute(v4) {
      return this.add(v4, C.m);
    }
    addSecond(v4) {
      return this.add(v4, C.s);
    }
    addMs(v4) {
      return this.add(v4, C.ms);
    }
    addDay(v4) {
      return this.add(v4, C.D);
    }
    addWeek(v4) {
      return this.add(v4, C.W);
    }
    addMonth(v4) {
      return this.add(v4, C.M);
    }
    addYear(v4) {
      return this.add(v4, C.Y);
    }
    format(fmt, locale) {
      const format = fmt || DEFAULT_FORMAT;
      const names = _Datetime.getLocale(locale || this.locale);
      const year = this.year(), year2 = this.year2(), month = this.month(), day = this.day(), weekDay = this.weekDay();
      const hour = this.hour(), minute = this.minute(), second = this.second(), ms = this.ms();
      const matches2 = {
        YY: year2,
        YYYY: year,
        M: month + 1,
        MM: lpad(month + 1, 0, 2),
        MMM: names.monthsShort[month],
        MMMM: names.months[month],
        D: day,
        DD: lpad(day, 0, 2),
        d: weekDay,
        dd: names.weekdaysMin[weekDay],
        ddd: names.weekdaysShort[weekDay],
        dddd: names.weekdays[weekDay],
        H: hour,
        HH: lpad(hour, 0, 2),
        m: minute,
        mm: lpad(minute, 0, 2),
        s: second,
        ss: lpad(second, 0, 2),
        sss: lpad(ms, 0, 3)
      };
      return format.replace(REGEX_FORMAT, (match, $1) => $1 || matches2[match]);
    }
    valueOf() {
      return this.value.valueOf();
    }
    toString() {
      return this.value.toString();
    }
  };
  var datetime2 = (...args) => args && args[0] instanceof Datetime2 ? args[0] : new Datetime2(...args);
  var fnFormat = Datetime2.prototype.format;
  var buddhistMixin = {
    buddhist() {
      return this.year() + 543;
    },
    format(format, locale) {
      format = format || DEFAULT_FORMAT;
      const matches2 = {
        BB: (this.buddhist() + "").slice(-2),
        BBBB: this.buddhist()
      };
      let result = format.replace(/(\[[^\]]+])|B{4}|B{2}/g, (match, $1) => $1 || matches2[match]);
      return fnFormat.bind(this)(result, locale);
    }
  };
  Object.assign(Datetime2.prototype, buddhistMixin);
  var createCalendar = (date, iso) => {
    let _date = date instanceof Datetime2 ? date.clone().align("month") : datetime2(date);
    let ws = iso === 0 || iso ? iso : date.weekStart;
    let wd = ws ? _date.isoWeekDay() : _date.weekDay();
    let names = Datetime2.getLocale(_date.locale);
    let now = datetime2(), i3;
    const getWeekDays = (wd2, ws2) => {
      if (ws2 === 0) {
        return wd2;
      }
      let su = wd2[0];
      return wd2.slice(1).concat([su]);
    };
    const result = {
      month: names.months[_date.month()],
      days: [],
      weekstart: iso ? 1 : 0,
      weekdays: getWeekDays(names.weekdaysMin, ws),
      today: now.format("YYYY-MM-DD"),
      weekends: [],
      week: []
    };
    _date.addDay(ws ? -wd + 1 : -wd);
    for (i3 = 0; i3 < 42; i3++) {
      result.days.push(_date.format("YYYY-MM-DD"));
      _date.add(1, "day");
    }
    result.weekends = result.days.filter(function(v4, i22) {
      const def = [0, 6, 7, 13, 14, 20, 21, 27, 28, 34, 35, 41];
      const iso2 = [5, 6, 12, 13, 19, 20, 26, 27, 33, 34, 40, 41];
      return ws === 0 ? def.includes(i22) : iso2.includes(i22);
    });
    _date = now.clone();
    wd = ws ? _date.isoWeekDay() : _date.weekDay();
    _date.addDay(ws ? -wd + 1 : -wd);
    for (i3 = 0; i3 < 7; i3++) {
      result.week.push(_date.format("YYYY-MM-DD"));
      _date.add(1, "day");
    }
    return result;
  };
  Object.assign(Datetime2.prototype, {
    // 1 - Monday, 0 - Sunday
    calendar(weekStart) {
      return createCalendar(this, weekStart);
    }
  });
  var fnFormat2 = Datetime2.prototype.format;
  Object.assign(Datetime2.prototype, {
    century() {
      return Math.ceil(this.year() / 100);
    },
    format(format, locale) {
      format = format || DEFAULT_FORMAT;
      const matches2 = {
        C: this.century()
      };
      let fmt = format.replace(/(\[[^\]]+])|C/g, (match, $1) => $1 || matches2[match]);
      return fnFormat2.bind(this)(fmt, locale);
    }
  });
  Object.assign(Datetime2.prototype, {
    same(d3) {
      return this.time() === datetime2(d3).time();
    },
    /*
    * align: year, month, day, hour, minute, second, ms = default
    * */
    compare(d3, align, operator = "=") {
      const date = datetime2(d3);
      const curr = datetime2(this.value);
      let t1, t2;
      operator = operator || "=";
      if (["<", ">", ">=", "<=", "=", "!="].includes(operator) === false) {
        operator = "=";
      }
      align = (align || "ms").toLowerCase();
      t1 = curr.align(align).time();
      t2 = date.align(align).time();
      switch (operator) {
        case "<":
          return t1 < t2;
        case ">":
          return t1 > t2;
        case "<=":
          return t1 <= t2;
        case ">=":
          return t1 >= t2;
        case "=":
          return t1 === t2;
        case "!=":
          return t1 !== t2;
      }
    },
    between(d1, d22) {
      return this.younger(d1) && this.older(d22);
    },
    older(date, align) {
      return this.compare(date, align, "<");
    },
    olderOrEqual(date, align) {
      return this.compare(date, align, "<=");
    },
    younger(date, align) {
      return this.compare(date, align, ">");
    },
    youngerOrEqual(date, align) {
      return this.compare(date, align, ">=");
    },
    equal(date, align) {
      return this.compare(date, align, "=");
    },
    notEqual(date, align) {
      return this.compare(date, align, "!=");
    },
    diff(d3) {
      const date = datetime2(d3);
      const diff = Math.abs(this.time() - date.time());
      const diffMonth = Math.abs(this.month() - date.month() + 12 * (this.year() - date.year()));
      return {
        "ms": diff,
        "second": Math.ceil(diff / 1e3),
        "minute": Math.ceil(diff / (1e3 * 60)),
        "hour": Math.ceil(diff / (1e3 * 60 * 60)),
        "day": Math.ceil(diff / (1e3 * 60 * 60 * 24)),
        "month": diffMonth,
        "year": Math.floor(diffMonth / 12)
      };
    },
    distance(d3, align) {
      return this.diff(d3)[align];
    }
  });
  Object.assign(Datetime2.prototype, {
    isLeapYear() {
      const year = this.year();
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
  });
  Object.assign(Datetime2.prototype, {
    dayOfYear() {
      const dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      const month = this.month();
      const day = this.day();
      return dayCount[month] + day + (month > 1 && this.isLeapYear() ? 1 : 0);
    }
  });
  Object.assign(Datetime2.prototype, {
    daysInMonth() {
      const curr = datetime2(this.value);
      return curr.add(1, "month").day(1).add(-1, "day").day();
    },
    daysInYear() {
      return this.isLeapYear() ? 366 : 365;
    },
    daysInYearMap() {
      const result = [];
      const curr = datetime2(this.value);
      curr.month(0).day(1);
      for (let i3 = 0; i3 < 12; i3++) {
        curr.add(1, "month").add(-1, "day");
        result.push(curr.day());
        curr.day(1).add(1, "month");
      }
      return result;
    },
    daysInYearObj(locale, shortName) {
      const map = this.daysInYearMap();
      const result = {};
      const names = Datetime2.getLocale(locale || this.locale);
      map.forEach((v4, i3) => result[names[shortName ? "monthsShort" : "months"][i3]] = v4);
      return result;
    }
  });
  Object.assign(Datetime2.prototype, {
    decade() {
      return Math.floor(this.year() / 10) * 10;
    },
    decadeStart() {
      const decade = this.decade();
      const result = this.mutable ? this : this.clone();
      return result.year(decade).month(0).day(1);
    },
    decadeEnd() {
      const decade = this.decade() + 9;
      const result = this.mutable ? this : this.clone();
      return result.year(decade).month(11).day(31);
    },
    decadeOfMonth() {
      const part = this.clone().add(1, "month").day(1).add(-1, "day").day() / 3;
      const day = this.day();
      if (day <= part) return 1;
      if (day <= part * 2) return 2;
      return 3;
    }
  });
  Object.assign(Datetime2, {
    from(str2, format, locale) {
      let norm, normFormat, fItems, dItems;
      let iMonth, iDay, iYear, iHour, iMinute, iSecond, iMs;
      let year, month, day, hour, minute, second, ms;
      let parsedMonth;
      const getIndex = function(where, what) {
        return where.map(function(el) {
          return el.toLowerCase();
        }).indexOf(what.toLowerCase());
      };
      const monthNameToNumber = function(month2) {
        let i3 = -1;
        const names = Datetime2.getLocale(locale || "en");
        if (not(month2)) return -1;
        i3 = getIndex(names.months, month2);
        if (i3 === -1 && typeof names["monthsParental"] !== "undefined") {
          i3 = getIndex(names["monthsParental"], month2);
        }
        if (i3 === -1) {
          month2 = month2.substr(0, 3);
          i3 = getIndex(names.monthsShort, month2);
        }
        return i3 === -1 ? -1 : i3 + 1;
      };
      const getPartIndex = function(part) {
        const parts = {
          "month": ["M", "mm", "%m"],
          "day": ["D", "dd", "%d"],
          "year": ["YY", "YYYY", "yy", "yyyy", "%y"],
          "hour": ["h", "hh", "%h"],
          "minute": ["m", "mi", "i", "ii", "%i"],
          "second": ["s", "ss", "%s"],
          "ms": ["sss"]
        };
        let result = -1, key, index;
        for (let i3 = 0; i3 < parts[part].length; i3++) {
          key = parts[part][i3];
          index = fItems.indexOf(key);
          if (index !== -1) {
            result = index;
            break;
          }
        }
        return result;
      };
      if (!format) {
        return datetime2();
      }
      norm = str2.replace(/[\/,.:\s]/g, "-");
      normFormat = format.toLowerCase().replace(/[^a-zA-Z0-9%]/g, "-");
      fItems = normFormat.split("-");
      dItems = norm.split("-");
      if (norm.replace(/-/g, "").trim() === "") {
        throw new Error(INVALID_DATE);
      }
      iMonth = getPartIndex("month");
      iDay = getPartIndex("day");
      iYear = getPartIndex("year");
      iHour = getPartIndex("hour");
      iMinute = getPartIndex("minute");
      iSecond = getPartIndex("second");
      iMs = getPartIndex("ms");
      if (iMonth > -1 && dItems[iMonth]) {
        if (isNaN(parseInt(dItems[iMonth]))) {
          dItems[iMonth] = monthNameToNumber(dItems[iMonth]);
          if (dItems[iMonth] === -1) {
            iMonth = -1;
          }
        } else {
          parsedMonth = parseInt(dItems[iMonth]);
          if (parsedMonth < 1 || parsedMonth > 12) {
            iMonth = -1;
          }
        }
      } else {
        iMonth = -1;
      }
      year = iYear > -1 && dItems[iYear] ? dItems[iYear] : 0;
      month = iMonth > -1 && dItems[iMonth] ? dItems[iMonth] : 1;
      day = iDay > -1 && dItems[iDay] ? dItems[iDay] : 1;
      hour = iHour > -1 && dItems[iHour] ? dItems[iHour] : 0;
      minute = iMinute > -1 && dItems[iMinute] ? dItems[iMinute] : 0;
      second = iSecond > -1 && dItems[iSecond] ? dItems[iSecond] : 0;
      ms = iMs > -1 && dItems[iMs] ? dItems[iMs] : 0;
      return datetime2(year, month - 1, day, hour, minute, second, ms);
    }
  });
  var fnFormat3 = Datetime2.prototype.format;
  Object.assign(Datetime2.prototype, {
    ampm(isLowerCase) {
      let val = this.hour() < 12 ? "AM" : "PM";
      return isLowerCase ? val.toLowerCase() : val;
    },
    hour12: function(h3, p3) {
      let hour = h3;
      if (arguments.length === 0) {
        return this.hour() % 12;
      }
      p3 = p3 || "am";
      if (p3.toLowerCase() === "pm") {
        hour += 12;
      }
      return this.hour(hour);
    },
    format: function(format, locale) {
      let matches2, result, h12 = this.hour12();
      format = format || DEFAULT_FORMAT;
      matches2 = {
        a: "[" + this.ampm(true) + "]",
        A: "[" + this.ampm(false) + "]",
        h: h12,
        hh: lpad(h12, 0, 2)
      };
      result = format.replace(/(\[[^\]]+])|a|A|h{1,2}/g, (match, $1) => $1 || matches2[match]);
      return fnFormat3.bind(this)(result, locale);
    }
  });
  var fnFormat4 = Datetime2.prototype.format;
  var fnAlign = Datetime2.align;
  var fnAlignEnd = Datetime2.alignEnd;
  Object.assign(Datetime2, {
    align(d3, align) {
      let date = datetime2(d3), result, temp;
      switch (align) {
        case "isoWeek":
          temp = date.isoWeekDay();
          result = fnAlign(date, "day").addDay(-temp + 1);
          break;
        // isoWeek
        default:
          result = fnAlign.apply(void 0, [date, align]);
      }
      return result;
    },
    alignEnd(d3, align) {
      let date = datetime2(d3), result, temp;
      switch (align) {
        case "isoWeek":
          temp = date.isoWeekDay();
          result = fnAlignEnd(date, "day").addDay(7 - temp);
          break;
        // isoWeek
        default:
          result = fnAlignEnd.apply(void 0, [date, align]);
      }
      return result;
    }
  });
  Object.assign(Datetime2.prototype, {
    isoWeekDay(val) {
      let wd = (this.weekDay() + 6) % 7 + 1;
      if (!arguments.length || not(val)) {
        return wd;
      }
      return this.addDay(val - wd);
    },
    format(format, locale) {
      format = format || DEFAULT_FORMAT;
      const matches2 = {
        I: this.isoWeekDay()
      };
      let result = format.replace(/(\[[^\]]+])|I{1,2}/g, (match, $1) => $1 || matches2[match]);
      return fnFormat4.bind(this)(result, locale);
    }
  });
  Object.assign(Datetime2, {
    max() {
      let arr = [].slice.call(arguments);
      return arr.map((el) => datetime2(el)).sort((a3, b4) => b4.time() - a3.time())[0];
    }
  });
  Object.assign(Datetime2.prototype, {
    max() {
      return Datetime2.max.apply(this, [this].concat([].slice.call(arguments)));
    }
  });
  Object.assign(Datetime2, {
    min() {
      let arr = [].slice.call(arguments);
      return arr.map((el) => datetime2(el)).sort((a3, b4) => a3.time() - b4.time())[0];
    }
  });
  Object.assign(Datetime2.prototype, {
    min() {
      return Datetime2.min.apply(this, [this].concat([].slice.call(arguments)));
    }
  });
  var fnAlign2 = Datetime2.align;
  var fnAlignEnd2 = Datetime2.alignEnd;
  var fnAdd = Datetime2.prototype.add;
  Object.assign(Datetime2, {
    align(d3, align) {
      let date = datetime2(d3), result;
      switch (align) {
        case "quarter":
          result = Datetime2.align(date, "day").day(1).month(date.quarter() * 3 - 3);
          break;
        //quarter
        default:
          result = fnAlign2.apply(this, [date, align]);
      }
      return result;
    },
    alignEnd(d3, align) {
      let date = datetime2(d3), result;
      switch (align) {
        case "quarter":
          result = Datetime2.align(date, "quarter").add(3, "month").add(-1, "ms");
          break;
        //quarter
        default:
          result = fnAlignEnd2.apply(this, [date, align]);
      }
      return result;
    }
  });
  Object.assign(Datetime2.prototype, {
    quarter() {
      const month = this.month();
      if (month <= 2) return 1;
      if (month <= 5) return 2;
      if (month <= 8) return 3;
      return 4;
    },
    add(val, to2) {
      if (to2 === "quarter") {
        return this.month(this.month() + val * 3);
      }
      return fnAdd.bind(this)(val, to2);
    },
    addQuarter(v4) {
      return this.add(v4, "quarter");
    }
  });
  Object.assign(Datetime2, {
    sort(arr, opt2) {
      let result, _arr;
      const o2 = {};
      if (typeof opt2 === "string" || typeof opt2 !== "object" || not(opt2)) {
        o2.format = DEFAULT_FORMAT;
        o2.dir = opt2 && opt2.toUpperCase() === "DESC" ? "DESC" : "ASC";
        o2.returnAs = "datetime";
      } else {
        o2.format = opt2.format || DEFAULT_FORMAT;
        o2.dir = (opt2.dir || "ASC").toUpperCase();
        o2.returnAs = opt2.format ? "string" : opt2.returnAs || "datetime";
      }
      _arr = arr.map((el) => datetime2(el)).sort((a3, b4) => a3.valueOf() - b4.valueOf());
      if (o2.dir === "DESC") {
        _arr.reverse();
      }
      switch (o2.returnAs) {
        case "string":
          result = _arr.map((el) => el.format(o2.format));
          break;
        case "date":
          result = _arr.map((el) => el.val());
          break;
        default:
          result = _arr;
      }
      return result;
    }
  });
  var fnFormat5 = Datetime2.prototype.format;
  Object.assign(Datetime2.prototype, {
    utcOffset() {
      return this.value.getTimezoneOffset();
    },
    timezone() {
      return this.toTimeString().replace(/.+GMT([+-])(\d{2})(\d{2}).+/, "$1$2:$3");
    },
    timezoneName() {
      return this.toTimeString().replace(/.+\((.+?)\)$/, "$1");
    },
    format(format, locale) {
      format = format || DEFAULT_FORMAT;
      const matches2 = {
        Z: this.utcMode ? "Z" : this.timezone(),
        ZZ: this.timezone().replace(":", ""),
        ZZZ: "[GMT]" + this.timezone(),
        z: this.timezoneName()
      };
      let result = format.replace(/(\[[^\]]+])|Z{1,3}|z/g, (match, $1) => $1 || matches2[match]);
      return fnFormat5.bind(this)(result, locale);
    }
  });
  var fnFormat6 = Datetime2.prototype.format;
  Object.assign(Datetime2.prototype, {
    // TODO Need optimisation
    weekNumber(weekStart) {
      let nYear, nday, newYear, day, daynum, weeknum;
      weekStart = +weekStart || 0;
      newYear = datetime2(this.year(), 0, 1);
      day = newYear.weekDay() - weekStart;
      day = day >= 0 ? day : day + 7;
      daynum = Math.floor(
        (this.time() - newYear.time() - (this.utcOffset() - newYear.utcOffset()) * 6e4) / 864e5
      ) + 1;
      if (day < 4) {
        weeknum = Math.floor((daynum + day - 1) / 7) + 1;
        if (weeknum > 52) {
          nYear = datetime2(this.year() + 1, 0, 1);
          nday = nYear.weekDay() - weekStart;
          nday = nday >= 0 ? nday : nday + 7;
          weeknum = nday < 4 ? 1 : 53;
        }
      } else {
        weeknum = Math.floor((daynum + day - 1) / 7);
      }
      return weeknum;
    },
    isoWeekNumber() {
      return this.weekNumber(1);
    },
    weeksInYear(weekStart) {
      const curr = datetime2(this.value);
      return curr.month(11).day(31).weekNumber(weekStart);
    },
    format: function(format, locale) {
      let matches2, result, wn = this.weekNumber(), wni = this.isoWeekNumber();
      format = format || DEFAULT_FORMAT;
      matches2 = {
        W: wn,
        WW: lpad(wn, 0, 2),
        WWW: wni,
        WWWW: lpad(wni, 0, 2)
      };
      result = format.replace(/(\[[^\]]+])|W{1,4}/g, (match, $1) => $1 || matches2[match]);
      return fnFormat6.bind(this)(result, locale);
    }
  });
  Object.assign(Datetime2.prototype, {
    strftime(fmt, locale) {
      const format = fmt || DEFAULT_FORMAT_STRFTIME;
      const names = Datetime2.getLocale(locale || this.locale);
      const year = this.year(), year2 = this.year2(), month = this.month(), day = this.day(), weekDay = this.weekDay();
      const hour = this.hour(), hour12 = this.hour12(), minute = this.minute(), second = this.second(), ms = this.ms(), time = this.time();
      const aDay = lpad(day, 0, 2), aMonth = lpad(month + 1, 0, 2), aHour = lpad(hour, 0, 2), aHour12 = lpad(hour12, 0, 2), aMinute = lpad(minute, 0, 2), aSecond = lpad(second, 0, 2), aMs = lpad(ms, 0, 3);
      const that = this;
      const thursday = function() {
        return datetime2(that.value).day(that.day() - (that.weekDay() + 6) % 7 + 3);
      };
      const matches2 = {
        "%a": names.weekdaysShort[weekDay],
        "%A": names.weekdays[weekDay],
        "%b": names.monthsShort[month],
        "%h": names.monthsShort[month],
        "%B": names.months[month],
        "%c": this.toString().substring(0, this.toString().indexOf(" (")),
        "%C": this.century(),
        "%d": aDay,
        "%D": [aDay, aMonth, year].join("/"),
        "%e": day,
        "%F": [year, aMonth, aDay].join("-"),
        "%G": thursday().year(),
        "%g": ("" + thursday().year()).slice(2),
        "%H": aHour,
        "%I": aHour12,
        "%j": lpad(this.dayOfYear(), 0, 3),
        "%k": aHour,
        "%l": aHour12,
        "%m": aMonth,
        "%n": month + 1,
        "%M": aMinute,
        "%p": this.ampm(),
        "%P": this.ampm(true),
        "%s": Math.round(time / 1e3),
        "%S": aSecond,
        "%u": this.isoWeekDay(),
        "%V": this.isoWeekNumber(),
        "%w": weekDay,
        "%x": this.toLocaleDateString(),
        "%X": this.toLocaleTimeString(),
        "%y": year2,
        "%Y": year,
        "%z": this.timezone().replace(":", ""),
        "%Z": this.timezoneName(),
        "%r": [aHour12, aMinute, aSecond].join(":") + " " + this.ampm(),
        "%R": [aHour, aMinute].join(":"),
        "%T": [aHour, aMinute, aSecond].join(":"),
        "%Q": aMs,
        "%q": ms,
        "%t": this.timezone()
      };
      return format.replace(
        REGEX_FORMAT_STRFTIME,
        (match) => matches2[match] === 0 || matches2[match] ? matches2[match] : match
      );
    }
  });
  Object.assign(Datetime2, {
    isToday(date) {
      const d3 = datetime2(date).align("day");
      const c3 = datetime2().align("day");
      return d3.time() === c3.time();
    }
  });
  Object.assign(Datetime2.prototype, {
    isToday() {
      return Datetime2.isToday(this);
    },
    today() {
      const now = datetime2();
      if (!this.mutable) {
        return now;
      }
      return this.val(now.val());
    }
  });
  Object.assign(Datetime2, {
    isTomorrow(date) {
      const d3 = datetime2(date).align("day");
      const c3 = datetime2().align("day").add(1, "day");
      return d3.time() === c3.time();
    }
  });
  Object.assign(Datetime2.prototype, {
    isTomorrow() {
      return Datetime2.isTomorrow(this);
    },
    tomorrow() {
      if (!this.mutable) {
        return this.clone().immutable(false).add(1, "day").immutable(!this.mutable);
      }
      return this.add(1, "day");
    }
  });
  Object.assign(Datetime2.prototype, {
    toDateString() {
      return this.value.toDateString();
    },
    toISOString() {
      return this.value.toISOString();
    },
    toJSON() {
      return this.value.toJSON();
    },
    toGMTString() {
      return this.value.toGMTString();
    },
    toLocaleDateString() {
      return this.value.toLocaleDateString();
    },
    toLocaleString() {
      return this.value.toLocaleString();
    },
    toLocaleTimeString() {
      return this.value.toLocaleTimeString();
    },
    toTimeString() {
      return this.value.toTimeString();
    },
    toUTCString() {
      return this.value.toUTCString();
    },
    toDate() {
      return new Date(this.value);
    }
  });
  Object.assign(Datetime2, {
    timestamp() {
      return (/* @__PURE__ */ new Date()).getTime() / 1e3;
    }
  });
  Object.assign(Datetime2.prototype, {
    unix(val) {
      let _val;
      if (!arguments.length || not(val)) {
        return Math.floor(this.valueOf() / 1e3);
      }
      _val = val * 1e3;
      if (this.mutable) {
        return this.time(_val);
      }
      return datetime2(this.value).time(_val);
    },
    timestamp() {
      return this.unix();
    }
  });
  Object.assign(Datetime2, {
    isYesterday(date) {
      const d3 = datetime2(date).align("day");
      const c3 = datetime2().align("day").add(-1, "day");
      return d3.time() === c3.time();
    }
  });
  Object.assign(Datetime2.prototype, {
    isYesterday() {
      return Datetime2.isYesterday(this);
    },
    yesterday() {
      if (!this.mutable) {
        return this.clone().immutable(false).add(-1, "day").immutable(!this.mutable);
      }
      return this.add(-1, "day");
    }
  });
  var getResult = (val) => {
    let res;
    let seconds = Math.floor(val / 1e3), minutes = Math.floor(seconds / 60), hours = Math.floor(minutes / 60), days = Math.floor(hours / 24), months = Math.floor(days / 30), years = Math.floor(months / 12);
    if (years >= 1) res = `${years} year`;
    if (months >= 1 && years < 1) res = `${months} mon`;
    if (days >= 1 && days <= 30) res = `${days} days`;
    if (hours && hours < 24) res = `${hours} hour`;
    if (minutes && (minutes >= 40 && minutes < 60)) res = "less a hour";
    if (minutes && minutes < 40) res = `${minutes} min`;
    if (seconds && seconds >= 30 && seconds < 60) res = `${seconds} sec`;
    if (seconds < 30) res = `few sec`;
    return res;
  };
  Object.assign(Datetime2, {
    timeLapse(d3) {
      let old = datetime2(d3), now = datetime2(), val = now - old;
      return getResult(val);
    }
  });
  Object.assign(Datetime2.prototype, {
    timeLapse() {
      let val = datetime2() - +this;
      return getResult(val);
    }
  });
  var ParseTimeMixin = {
    parseTime(t) {
      if (!isNaN(t)) return Math.abs(+t);
      const pattern = /([0-9]+d)|([0-9]{1,2}h)|([0-9]{1,2}m)|([0-9]{1,2}s)/gm;
      const match = t.match(pattern);
      return match.reduce((acc, val) => {
        let res;
        if (val.includes("d")) {
          res = 1e3 * 60 * 60 * 24 * parseInt(val);
        } else if (val.includes("h")) {
          res = 1e3 * 60 * 60 * parseInt(val);
        } else if (val.includes("m")) {
          res = 1e3 * 60 * parseInt(val);
        } else if (val.includes("s")) {
          res = 1e3 * parseInt(val);
        }
        return acc + res;
      }, 0);
    }
  };
  Object.assign(Datetime2, ParseTimeMixin);
  Object.assign(Datetime2.prototype, {
    moon() {
      const phases = [
        "new-moon",
        "waxing-crescent",
        "first-quarter",
        "waxing-gibbous",
        "full-moon",
        "waning-gibbous",
        "last-quarter",
        "waning-crescent"
      ];
      const phase = () => {
        let year = this.year(), month = this.month(), day = this.day();
        let e2;
        let jd;
        let b4;
        let c3 = e2 = jd = b4 = 0;
        if (month < 3) {
          year--;
          month += 12;
        }
        ++month;
        c3 = 365.25 * year;
        e2 = 30.6 * month;
        jd = c3 + e2 + day - 694039.09;
        jd /= 29.5305882;
        b4 = parseInt(jd);
        jd -= b4;
        b4 = Math.round(jd * 8);
        if (b4 >= 8) b4 = 0;
        return { phase: b4, name: phases[b4] };
      };
      return phase();
    }
  });
  var version = "3.2.2";
  var build_time = "09.03.2025, 06:30:54";
  var info = () => {
    console.info(`%c Datetime %c v${version} %c ${build_time} `, "color: #ffffff; font-weight: bold; background: #003152", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  Datetime2.info = info;

  // source/datetime/index.js
  Datetime2.correctDate = function(date) {
    return datetime2(date).addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
  };
  globalThis.Datetime = Datetime2;
  globalThis.datetime = datetime2;
  (function() {
    "use strict";
    const MONTHS = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
    const DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    var getLocale = Datetime2.getLocale;
    Datetime2.getLocale = function(locale) {
      var data;
      if (!Metro) {
        locale = "en";
        return getLocale.call(this, locale);
      }
      if (!Metro.locales[locale]) {
        locale = "en";
      }
      data = Metro.locales[locale];
      const months = MONTHS.map(function(el, i3) {
        return data[el];
      });
      const monthsShort = MONTHS.map(function(el, i3) {
        return data[`${el}_short`];
      });
      const weekdays = DAYS.map(function(el, i3) {
        return data[el];
      });
      const weekdaysShort = DAYS.map(function(el, i3) {
        return data[`${el}_short`];
      });
      const weekdaysMin = DAYS.map(function(el, i3) {
        return data[`${el}_short_2`];
      });
      return {
        months,
        monthsShort,
        weekdays,
        weekdaysShort,
        weekdaysMin,
        weekStart: data.weekStart
      };
    };
  })();

  // node_modules/@olton/string/dist/string.js
  var pr = Object.defineProperty;
  var ar = (r2, t) => {
    for (var e2 in t) pr(r2, e2, { get: t[e2], enumerable: true });
  };
  var qt = {};
  ar(qt, { append: () => Xt, camelCase: () => z, capitalize: () => F, chars: () => c, count: () => tt, countChars: () => W, countSubstr: () => rt, countUniqueChars: () => O, countUniqueWords: () => er, countWords: () => rr, dashedName: () => H, decapitalize: () => U, endsWith: () => gt, escapeHtml: () => et, first: () => st, includes: () => wt, insert: () => ht, isAlpha: () => xt, isAlphaDigit: () => _t, isBlank: () => Et, isDigit: () => dt, isEmpty: () => X, isLower: () => At, isString: () => Tt, isUpper: () => St, kebab: () => Z, last: () => nt, lower: () => R, lpad: () => ft, ltrim: () => M2, matches: () => Gt, nvl: () => Bt, pad: () => ct, prepend: () => kt, prune: () => lt, repeat: () => x, reverse: () => K, rpad: () => mt, rtrim: () => q, shorten: () => Lt, shuffle: () => J, slice: () => at, snake: () => Y, split: () => yt, sprintf: () => w, startsWith: () => bt, strip: () => Ct, stripBoom: () => Pt, stripTags: () => Rt, stripTagsAll: () => Ft, substring: () => m, swap: () => V, title: () => Q, trim: () => _, truncate: () => j, truncateWithAlign: () => pt, unescapeHtml: () => ot, unique: () => ut, uniqueWords: () => it, upper: () => G2, vsprintf: () => vt, words: () => a, wrap: () => It, wrapTag: () => Dt });
  var $ = "\\d";
  var L = "\\s\\uFEFF\\xA0";
  var E = "\\uD800-\\uDBFF";
  var A = "\\uDC00-\\uDFFF";
  var b = "\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F";
  var Wt = "\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF";
  var $t = "\\u2000-\\u206F";
  var zt = "\\x00-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7b-\\xBF\\xD7\\xF7";
  var Ht = "\\u2700-\\u27BF";
  var B = "a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F";
  var N = "\\x41-\\x5a\\xc0-\\xd6\\xd8-\\xde\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc\\u01c4\\u01c5\\u01c7\\u01c8\\u01ca\\u01cb\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f2\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e";
  var vr = new RegExp("([" + Wt + "]|[" + E + "][" + A + "]|[" + E + "](?![" + A + "])|(?:[^" + E + "]|^)[" + A + "])([" + b + "]+)", "g");
  var wr = new RegExp("([" + E + "])([" + A + "])", "g");
  var yr = new RegExp("((?:[" + Wt + "]|[" + E + "][" + A + "]|[" + E + "](?![" + A + "])|(?:[^" + E + "]|^)[" + A + "])(?:[" + b + "]+))|([" + E + "][" + A + "])|([\\n\\r\\u2028\\u2029])|(.)", "g");
  var Cr = new RegExp("[" + L + "]");
  var Ut = new RegExp("^[" + L + "]+");
  var Zt = new RegExp("[" + L + "]+$");
  var Kt = new RegExp("^" + $ + "+$");
  var Jt = /[<>&"'`]/g;
  var Yt = /(<([^>]+)>)/ig;
  var D = new RegExp("(?:[" + N + "][" + b + "]*)?(?:[" + B + "][" + b + "]*)+|(?:[" + N + "][" + b + "]*)+(?![" + B + "])|[" + $ + "]+|[" + Ht + "]|[^" + zt + $t + L + "]+", "g");
  var I = /[A-Z\xC0-\xD6\xD8-\xDE]?[a-z\xDF-\xF6\xF8-\xFF]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])|\d+/g;
  var Vt = new RegExp("^(?:[" + B + N + "][" + b + "]*)+$");
  var Qt = new RegExp("^((?:[" + B + N + "][" + b + "]*)|[" + $ + "])+$");
  var T = /^[\x01-\xFF]*$/;
  var u = (r2, t = "") => !r2 && typeof r2 != "number" && typeof r2 != "boolean" ? t : typeof r2 == "string" ? r2 : Array.isArray(r2) ? r2.join("") : JSON.stringify(r2);
  var Ot = (r2, t) => typeof r2 > "u" || r2 === null ? t : r2;
  var a = (r2, t, e2) => {
    let i3;
    return t ? t instanceof RegExp ? i3 = t : i3 = new RegExp(t, Ot(e2, "")) : i3 = T.test(r2) ? I : D, Ot(u(r2).match(i3), []);
  };
  var F = (r2, t = false) => {
    let e2 = u(r2), i3 = e2.substring(1);
    return e2.substring(0, 1).toUpperCase() + (t ? i3.toLowerCase() : i3);
  };
  var z = (r2) => a(u(r2)).map((t, e2) => e2 === 0 ? t.toLowerCase() : F(t)).join("");
  var H = (r2) => a(u(r2)).map((t) => t.toLowerCase()).join("-");
  var U = (r2) => {
    let t = u(r2);
    return t.substring(0, 1).toLowerCase() + t.substr(1);
  };
  var Z = (r2, t = "-") => a(u(r2)).map((e2) => e2.toLowerCase()).join(t);
  var R = (r2) => u(r2).toLowerCase();
  var c = (r2, t = []) => u(r2).split("").filter((e2) => !t.includes(e2));
  var K = (r2, t) => c(u(r2), t).reverse().join("");
  var tr = (r2 = []) => {
    let t = [...r2], e2 = t.length, i3, o2;
    for (; e2 !== 0; ) o2 = Math.floor(Math.random() * e2), e2 -= 1, i3 = t[e2], t[e2] = t[o2], t[o2] = i3;
    return t;
  };
  var J = (r2) => tr(u(r2).split("")).join("");
  var Y = (r2) => a(u(r2)).map((t) => t.toLowerCase()).join("_");
  var lr = (r2, t) => {
    let e2 = t.toLowerCase(), i3 = t.toUpperCase();
    return r2 + (t === e2 ? i3 : e2);
  };
  var V = (r2) => u(r2).split("").reduce(lr, "");
  var Q = (r2, t, e2 = "") => {
    let i3 = u(r2), o2 = T.test(i3) ? I : D, n2 = Array.isArray(t) ? t : typeof t != "string" ? [] : t.split(e2);
    return r2.replace(o2, (s3, p3) => p3 && n2.includes(i3[p3 - 1]) ? R(s3) : F(s3));
  };
  var G2 = (r2) => u(r2).toUpperCase();
  var tt = (r2) => u(r2).length;
  var v = (r2 = []) => {
    let t = [...r2];
    for (let e2 = 0; e2 < t.length; ++e2) for (let i3 = e2 + 1; i3 < t.length; ++i3) t[e2] === t[i3] && t.splice(i3--, 1);
    return t;
  };
  var W = (r2, t) => c(r2, t).length;
  var O = (r2, t) => v(c(r2, t)).length;
  var rt = (r2, t = "") => {
    let e2 = u(r2), i3 = u(t);
    return e2 === "" || i3 === "" ? 0 : e2.split(i3).length - 1;
  };
  var rr = (r2, t, e2) => a(r2, t, e2).length;
  var er = (r2, t, e2) => v(a(r2, t, e2)).length;
  var fr = { "<": "&lt;", ">": "&gt;", "&": "&amp;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" };
  function mr(r2) {
    return fr[r2];
  }
  var et = (r2) => u(r2).replace(Jt, mr);
  var or = { "<": /(&lt;)|(&#x0*3c;)|(&#0*60;)/gi, ">": /(&gt;)|(&#x0*3e;)|(&#0*62;)/gi, "&": /(&amp;)|(&#x0*26;)|(&#0*38;)/gi, '"': /(&quot;)|(&#x0*22;)|(&#0*34;)/gi, "'": /(&#x0*27;)|(&#0*39;)/gi, "`": /(&#x0*60;)|(&#0*96;)/gi };
  var cr = Object.keys(or);
  function hr(r2, t) {
    return r2.replace(or[t], t);
  }
  var ot = (r2) => cr.reduce(hr, u(r2));
  var ut = (r2, t) => v(c(r2, t)).join("");
  var it = (r2, t, e2) => v(a(r2, t, e2)).join("");
  var m = (r2, t, e2) => u(r2).substring(t, e2);
  var st = (r2, t = 0) => m(u(r2), 0, t);
  var nt = (r2, t = 0) => {
    let e2 = u(r2);
    return e2 ? m(e2, e2.length - t) : "";
  };
  var ur = "\uFEFF";
  var S = (r2, t, e2 = 9007199254740991) => r2 < t ? t : r2 > e2 ? e2 : r2;
  var g = (r2) => r2 === 1 / 0 ? 9007199254740991 : r2 === -1 / 0 ? -9007199254740991 : ~~r2;
  var j = (r2, t = 0, e2 = "...") => {
    let i3 = u(r2), o2 = t ? S(g(t), 0, 9007199254740991) : i3.length;
    return m(i3, 0, o2) + (i3.length === o2 ? "" : e2);
  };
  var pt = (r2, t = 0, e2 = "...") => {
    let i3 = j(r2, t, "");
    return i3.slice(r2, i3.lastIndexOf(" ")) + e2;
  };
  var at = (r2, t = 1) => {
    let e2 = u(r2), i3 = [], o2 = Math.round(e2.length / t);
    for (let n2 = 0; n2 < t; n2++) i3.push(m(e2, n2 * o2, o2));
    return i3;
  };
  var lt = (r2, t = 0, e2 = "") => {
    let i3 = u(r2), o2 = t ? S(g(t), 0, 9007199254740991) : i3.length, n2 = 0, s3 = T.test(i3) ? I : D;
    return i3.replace(s3, (p3, h3) => {
      let d3 = h3 + p3.length;
      d3 <= o2 - e2.length && (n2 = d3);
    }), i3.substring(0, n2) + e2;
  };
  var x = (r2, t = 0) => {
    let e2 = u(r2), i3 = t ? S(g(t), 0, 9007199254740991) : e2.length, o2 = e2;
    if (t === 0) return "";
    for (let n2 = 0; n2 < i3 - 1; n2++) e2 += o2;
    return e2;
  };
  var jt = (r2, t = 0) => {
    let e2 = r2.length, i3 = t - e2;
    return x(r2, i3 + 1).substring(0, t);
  };
  var ir = (r2, t = "", e2 = 0, i3 = false) => {
    let o2 = u(r2), n2 = e2 ? S(g(e2), 0, 9007199254740991) : o2.length, s3 = t.length, p3 = n2 - o2.length, h3 = p3;
    if (p3 <= 0 || s3 === 0) return o2;
    let d3 = jt(t, h3);
    return i3 ? d3 + o2 : o2 + d3;
  };
  var ft = (r2, t = " ", e2 = 0) => ir(r2, t, e2, true);
  var mt = (r2, t = " ", e2 = 0) => ir(r2, t, e2, false);
  var ct = (r2, t = "", e2 = 0) => {
    let i3 = u(r2), o2 = e2 ? S(g(e2), 0, 9007199254740991) : i3.length, n2 = t.length, s3 = o2 - i3.length, p3 = g(s3 / 2), h3 = s3 % 2;
    return s3 <= 0 || n2 === 0 ? i3 : jt(t, p3) + i3 + jt(t, p3 + h3);
  };
  var ht = (r2, t = "", e2 = 0) => {
    let i3 = u(r2);
    return i3.substring(0, e2) + t + i3.substring(e2);
  };
  var gr = Array.prototype.reduce;
  var xr = Array.prototype.reduceRight;
  var _ = (r2, t) => M2(q(r2, t), t);
  var M2 = (r2, t) => {
    let e2 = u(r2);
    if (!t) return e2.replace(Ut, "");
    if (t === "" || e2 === "") return e2;
    typeof t != "string" && (t = "");
    let i3 = true;
    return gr.call(e2, (o2, n2) => i3 && t.includes(n2) ? o2 : (i3 = false, o2 + n2), "");
  };
  var q = (r2, t) => {
    let e2 = u(r2);
    if (!t) return e2.replace(Zt, "");
    if (t === "" || e2 === "") return e2;
    typeof t != "string" && (t = "");
    let i3 = true;
    return xr.call(e2, (o2, n2) => i3 && t.includes(n2) ? o2 : (i3 = false, n2 + o2), "");
  };
  var gt = (r2, t, e2) => u(r2).endsWith(t, e2);
  var xt = (r2) => Vt.test(u(r2));
  var _t = (r2) => Qt.test(u(r2));
  var dt = (r2) => Kt.test(u(r2));
  var Et = (r2, t = true) => t ? u(r2).length === 0 : _(r2).length === 0;
  var X = (r2) => _(r2).length === 0;
  var At = (r2) => R(r2) === r2;
  var St = (r2) => G2(r2) === r2;
  var bt = (r2, t, e2) => u(r2).startsWith(t, e2);
  var Ft = (r2) => u(r2).replace(Yt, "");
  var Rt = (r2, t = []) => {
    let e2 = u(r2), i3 = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
    return e2.replace(i3, (o2, n2) => t.includes(n2) ? o2 : "");
  };
  var f = { not_string: /[^s]/, not_bool: /[^t]/, not_type: /[^T]/, not_primitive: /[^v]/, number: /[diefg]/, numeric_arg: /[bcdiefguxX]/, json: /[j]/, not_json: /[^j]/, text: /^[^\x25]+/, modulo: /^\x25{2}/, placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/, key: /^([a-z_][a-z_\d]*)/i, key_access: /^\.([a-z_][a-z_\d]*)/i, index_access: /^\[(\d+)\]/, sign: /^[+-]/ };
  function _r(r2, t) {
    let e2 = 1, i3 = r2.length, o2, n2 = "", s3, p3, h3, d3, Nt2, y3;
    for (let C4 = 0; C4 < i3; C4++) if (typeof r2[C4] == "string") n2 += r2[C4];
    else if (typeof r2[C4] == "object") {
      if (s3 = r2[C4], s3.keys) {
        o2 = t[e2];
        for (let P3 = 0; P3 < s3.keys.length; P3++) {
          if (typeof o2 > "u") throw new Error(w('[sprintf] Cannot access property "%s" of undefined value "%s"', s3.keys[P3], s3.keys[P3 - 1]));
          o2 = o2[s3.keys[P3]];
        }
      } else s3.param_no ? o2 = t[s3.param_no] : o2 = t[e2++];
      if (f.not_type.test(s3.type) && f.not_primitive.test(s3.type) && o2 instanceof Function && (o2 = o2()), f.numeric_arg.test(s3.type) && typeof o2 != "number" && isNaN(o2)) throw new TypeError(w("[sprintf] expecting number but found %T", o2));
      switch (f.number.test(s3.type) && (Nt2 = o2 >= 0), s3.type) {
        case "b":
          o2 = parseInt(o2, 10).toString(2);
          break;
        case "c":
          o2 = String.fromCharCode(parseInt(o2, 10));
          break;
        case "d":
        case "i":
          o2 = parseInt(o2, 10);
          break;
        case "j":
          o2 = JSON.stringify(o2, null, s3.width ? parseInt(s3.width) : 0);
          break;
        case "e":
          o2 = s3.precision ? parseFloat(o2).toExponential(s3.precision) : parseFloat(o2).toExponential();
          break;
        case "f":
          o2 = s3.precision ? parseFloat(o2).toFixed(s3.precision) : parseFloat(o2);
          break;
        case "g":
          o2 = s3.precision ? String(Number(o2.toPrecision(s3.precision))) : parseFloat(o2);
          break;
        case "o":
          o2 = (parseInt(o2, 10) >>> 0).toString(8);
          break;
        case "s":
          o2 = String(o2), o2 = s3.precision ? o2.substring(0, s3.precision) : o2;
          break;
        case "t":
          o2 = String(!!o2), o2 = s3.precision ? o2.substring(0, s3.precision) : o2;
          break;
        case "T":
          o2 = Object.prototype.toString.call(o2).slice(8, -1).toLowerCase(), o2 = s3.precision ? o2.substring(0, s3.precision) : o2;
          break;
        case "u":
          o2 = parseInt(o2, 10) >>> 0;
          break;
        case "v":
          o2 = o2.valueOf(), o2 = s3.precision ? o2.substring(0, s3.precision) : o2;
          break;
        case "x":
          o2 = (parseInt(o2, 10) >>> 0).toString(16);
          break;
        case "X":
          o2 = (parseInt(o2, 10) >>> 0).toString(16).toUpperCase();
          break;
      }
      f.json.test(s3.type) ? n2 += o2 : (f.number.test(s3.type) && (!Nt2 || s3.sign) ? (y3 = Nt2 ? "+" : "-", o2 = o2.toString().replace(f.sign, "")) : y3 = "", h3 = s3.pad_char ? s3.pad_char === "0" ? "0" : s3.pad_char.charAt(1) : " ", d3 = s3.width - (y3 + o2).length, p3 = s3.width && d3 > 0 ? h3.repeat(d3) : "", n2 += s3.align ? y3 + o2 + p3 : h3 === "0" ? y3 + p3 + o2 : p3 + y3 + o2);
    }
    return n2;
  }
  var Mt = /* @__PURE__ */ Object.create(null);
  function dr(r2) {
    if (Mt[r2]) return Mt[r2];
    let t = r2, e2, i3 = [], o2 = 0;
    for (; t; ) {
      if ((e2 = f.text.exec(t)) !== null) i3.push(e2[0]);
      else if ((e2 = f.modulo.exec(t)) !== null) i3.push("%");
      else if ((e2 = f.placeholder.exec(t)) !== null) {
        if (e2[2]) {
          o2 |= 1;
          let n2 = [], s3 = e2[2], p3 = [];
          if ((p3 = f.key.exec(s3)) !== null) for (n2.push(p3[1]); (s3 = s3.substring(p3[0].length)) !== ""; ) if ((p3 = f.key_access.exec(s3)) !== null) n2.push(p3[1]);
          else if ((p3 = f.index_access.exec(s3)) !== null) n2.push(p3[1]);
          else throw new SyntaxError("[sprintf] failed to parse named argument key");
          else throw new SyntaxError("[sprintf] failed to parse named argument key");
          e2[2] = n2;
        } else o2 |= 2;
        if (o2 === 3) throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
        i3.push({ placeholder: e2[0], param_no: e2[1], keys: e2[2], sign: e2[3], pad_char: e2[4], align: e2[5], width: e2[6], precision: e2[7], type: e2[8] });
      } else throw new SyntaxError("[sprintf] unexpected placeholder");
      t = t.substring(e2[0].length);
    }
    return Mt[r2] = i3;
  }
  var w = (r2) => _r(dr(r2), arguments);
  var vt = (r2, t) => w.apply(null, [r2].concat(t || []));
  var wt = (r2, t, e2) => u(r2).includes(t, e2);
  var yt = (r2, t = void 0, e2 = void 0, i3 = true) => u(r2).split(t, e2).map((o2) => i3 ? o2.trim() : o2).filter((o2) => i3 ? !X(o2) : true);
  var Ct = (r2, t = null, e2 = "") => {
    let i3 = u(r2), o2;
    return t ? (o2 = new RegExp(t, "g"), i3.replace(o2, e2)) : i3;
  };
  var Dt = (r2, t = "div", e2 = {}) => {
    let i3 = u(r2), o2 = Object.keys(e2).map((n2) => `${n2}="${e2[n2]}"`).join(" ");
    return o2 && (o2 = " " + o2), `<${t}${o2}>${i3}</${t}>`;
  };
  var It = (r2, t = "", e2 = "") => t + u(r2) + e2;
  var Tt = (r2) => typeof r2 == "string";
  var Gt = (r2, t, e2 = "") => {
    let i3 = u(r2), o2;
    if (!(t instanceof RegExp)) {
      if (o2 = t ? _(u(t)) : "", !o2) return false;
      t = new RegExp(o2, e2);
    }
    return t.test(i3);
  };
  var Xt = (r2, t = "", e2 = 1) => u(r2) + x(t, e2);
  var kt = (r2, t = "", e2 = 1) => x(t, e2) + u(r2);
  var Pt = (r2) => {
    let t = u(r2);
    return t === "" ? t : t[0] === ur ? t.substring(1) : t;
  };
  var Lt = (r2, t = 5, e2 = "...") => r2 && `${r2.substring(0, t)}${e2}${r2.substring(r2.length - t)}`;
  var sr = (r2) => typeof r2 > "u" || r2 === null;
  var Bt = (r2, ...t) => {
    if (!sr(r2)) return r2;
    if (t.length === 0) throw new Error("nvl: No default value provided");
    for (let e2 of t) if (typeof e2 < "u" && e2 !== null) return e2;
  };
  var k = class {
    constructor(t = "", { mutable: e2 = true } = {}) {
      this.value = t.toString(), this.mutable = e2;
    }
    [Symbol.toPrimitive](t) {
      return t === "number" ? +this.value : this.value;
    }
    get [Symbol.toStringTag]() {
      return "Str";
    }
    val(t) {
      return typeof t > "u" || t === null ? this.value : (this.value = t.toString(), this);
    }
    get length() {
      return this.value.length;
    }
    immutable(t = true) {
      this.mutable = !t;
    }
    toString() {
      return Array.isArray(this.value) ? this.value.join("") : this.value;
    }
    _result(t) {
      return this.mutable ? (this.value = t, this) : nr(t);
    }
    camelCase() {
      return this._result(z(this.value));
    }
    capitalize(t) {
      return this._result(F(this.value, t));
    }
    chars(t) {
      return this._result(c(this.value, t));
    }
    count() {
      return tt(this.value);
    }
    countChars(t) {
      return W(this.value, t);
    }
    countUniqueChars(t) {
      return O(this.value, t);
    }
    countSubstr(t) {
      return rt(this.value, t);
    }
    countWords(t, e2) {
      return W(this.value, t, e2);
    }
    countUniqueWords(t, e2) {
      return O(this.value, t, e2);
    }
    dashedName() {
      return this._result(H(this.value));
    }
    decapitalize() {
      return this._result(U(this.value));
    }
    endsWith(t, e2) {
      return gt(this.value, t, e2);
    }
    escapeHtml() {
      return this._result(et(this.value));
    }
    first() {
      return this._result(st(this.value));
    }
    includes(t, e2) {
      return wt(this.value, t, e2);
    }
    insert(t, e2) {
      return this._result(ht(this.value, t, e2));
    }
    isAlpha() {
      return xt(this.value);
    }
    isAlphaDigit() {
      return _t(this.value);
    }
    isBlank(t) {
      return Et(this.value, t);
    }
    isDigit() {
      return dt(this.value);
    }
    isEmpty() {
      return X(this.value);
    }
    isLower() {
      return At(this.value);
    }
    static isString(t) {
      return Tt(t);
    }
    isUpper() {
      return St(this.value);
    }
    kebab(t) {
      return this._result(Z(this.value, t));
    }
    last(t) {
      return this._result(nt(this.value, t));
    }
    lower() {
      return this._result(R(this.value));
    }
    matches(t, e2) {
      return Gt(this.value, t, e2);
    }
    pad(t, e2) {
      return this._result(ct(this.value, t, e2));
    }
    lpad(t, e2) {
      return this._result(ft(this.value, t, e2));
    }
    rpad(t, e2) {
      return this._result(mt(this.value, t, e2));
    }
    prune(t, e2) {
      return this._result(lt(this.value, t, e2));
    }
    repeat(t) {
      return this._result(x(this.value, t));
    }
    append(t, e2) {
      return this._result(Xt(this.value, t, e2));
    }
    prepend(t, e2) {
      return this._result(kt(this.value, t, e2));
    }
    reverse(t) {
      return this._result(K(this.value, t));
    }
    shuffle() {
      return this._result(J(this.value));
    }
    slice(t) {
      return this._result(at(this.value, t));
    }
    snake() {
      return this._result(Y(this.value));
    }
    split(t, e2, i3) {
      return this._result(yt(this.value, t, e2, i3));
    }
    sprintf(...t) {
      return this._result(w(this.value, ...t));
    }
    vsprintf(...t) {
      return this._result(vt(this.value, ...t));
    }
    startsWith(t, e2) {
      return bt(this.value, t, e2);
    }
    stripBoom() {
      return this._result(Pt(this.value));
    }
    stripTags(t) {
      return this._result(Rt(this.value, t));
    }
    stripTagsAll() {
      return this._result(Ft(this.value));
    }
    strip(t, e2) {
      return this._result(Ct(this.value, t, e2));
    }
    substring(t, e2) {
      return this._result(m(this.value, t, e2));
    }
    swap() {
      return this._result(V(this.value));
    }
    title(t, e2) {
      return this._result(Q(this.value, t, e2));
    }
    trim(t) {
      return this._result(_(this.value, t));
    }
    ltrim(t) {
      return this._result(M2(this.value, t));
    }
    rtrim(t) {
      return this._result(q(this.value, t));
    }
    truncate(t, e2) {
      return this._result(j(this.value, t, e2));
    }
    truncateWithAlign(t, e2) {
      return this._result(pt(this.value, t, e2));
    }
    unescapeHtml() {
      return this._result(ot(this.value));
    }
    unique(t) {
      return this._result(ut(this.value, t));
    }
    uniqueWords(t, e2) {
      return this._result(it(this.value, t, e2));
    }
    upper() {
      return this._result(G2(this.value));
    }
    words(t, e2) {
      return a(this.value, t, e2);
    }
    wrap(t, e2) {
      return this._result(It(this.value, t, e2));
    }
    wrapTag(t) {
      return this._result(Dt(this.value, t));
    }
    shorten(t, e2) {
      return this._result(Lt(this.value, t, e2));
    }
    nvl(...t) {
      return this._result(Bt(this.value, ...t));
    }
  };
  Object.assign(k, qt);
  var nr = (r2, t = true) => new k(r2, { mutable: t });
  var Er = "0.10.0";
  var Ar = "16.03.2025, 19:17:56";
  var Sr = () => {
    console.info(`%c String %c v${Er} %c ${Ar} `, "color: #000000; font-weight: bold; background: #fff200", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  k.info = Sr;

  // source/string/index.js
  globalThis.Str = k;
  globalThis.str = nr;

  // node_modules/@olton/dom/dist/dom.js
  var numProps = ["opacity", "zIndex"];
  function nothing() {
    return null;
  }
  function isSimple(v4) {
    return typeof v4 === "string" || typeof v4 === "boolean" || typeof v4 === "number";
  }
  function isVisible(elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  }
  function isHidden(elem) {
    const s3 = getComputedStyle(elem);
    return !isVisible(elem) || +s3.opacity === 0 || elem.hidden || s3.visibility === "hidden";
  }
  function not2(value) {
    return value === void 0 || value === null;
  }
  function camelCase(string) {
    return string.replace(/-([a-z])/g, function(all, letter) {
      return letter.toUpperCase();
    });
  }
  function isPlainObject(obj) {
    let proto;
    if (!obj || Object.prototype.toString.call(obj) !== "[object Object]") {
      return false;
    }
    proto = obj.prototype !== void 0;
    if (!proto) {
      return true;
    }
    return proto.constructor && typeof proto.constructor === "function";
  }
  function isEmptyObject(obj) {
    for (const name2 in obj) {
      if (hasProp(obj, name2)) return false;
    }
    return true;
  }
  function isArrayLike(o2) {
    return o2 instanceof Object && "length" in o2;
  }
  function str2arr(str2, sep) {
    sep = sep || " ";
    return str2.split(sep).map(function(el) {
      return ("" + el).trim();
    }).filter(function(el) {
      return el !== "";
    });
  }
  function parseUnit(str2, out) {
    if (!out) out = [0, ""];
    str2 = String(str2);
    out[0] = parseFloat(str2);
    out[1] = str2.match(/[\d.\-+]*\s*(.*)/)[1] || "";
    return out;
  }
  function getUnit(val, und) {
    const split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn|fr|lh|cqw|cqh|cqi|cqb|cqmin|cqmax|q)?$/.exec(val);
    return typeof split[1] !== "undefined" ? split[1] : und;
  }
  function setStyleProp(el, key, val) {
    key = camelCase(key);
    if (["scrollLeft", "scrollTop"].indexOf(key) > -1) {
      el[key] = parseInt(val);
    } else {
      el.style[key] = isNaN(val) || numProps.indexOf("" + key) > -1 ? val : val + "px";
    }
  }
  function acceptData(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  }
  function getData(data) {
    try {
      return JSON.parse(data);
    } catch (e2) {
      return data;
    }
  }
  function dataAttr(elem, key, data) {
    let name2;
    if (not2(data) && elem.nodeType === 1) {
      name2 = "data-" + key.replace(/[A-Z]/g, "-$&").toLowerCase();
      data = elem.getAttribute(name2);
      if (typeof data === "string") {
        data = getData(data);
        dataSet.set(elem, key, data);
      } else {
        data = void 0;
      }
    }
    return data;
  }
  function normName(name2) {
    return typeof name2 !== "string" ? void 0 : name2.replace(/-/g, "").toLowerCase();
  }
  function hasProp(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function isLocalhost(host) {
    const hostname = host || globalThis.location.hostname;
    return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "[::1]" || hostname === "" || hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/) !== null;
  }
  function isTouch() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  function isPrivateAddress(host) {
    const hostname = host || globalThis.location.hostname;
    return /(^localhost)|(^127\.)|(^192\.168\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2\d\.)|(^172\.3[0-1]\.)|(^::1$)|(^[fF][cCdD])/.test(hostname);
  }
  var matches = Element.prototype.matches;
  var $2 = (selector, context) => new $2.init(selector, context);
  $2.version = "1.4.0";
  $2.build_time = "08.03.2025, 03:24:58";
  $2.info = () => console.info(`%c Dom %c v${$2.version} %c ${$2.build_time} `, "color: white; font-weight: bold; background: #fd6a02", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  $2.fn = $2.prototype = Object.create(Array.prototype);
  $2.prototype.constructor = $2;
  $2.prototype.uid = "";
  $2.extend = $2.fn.extend = function() {
    let options, name2, target = arguments[0] || {}, i3 = 1, length = arguments.length;
    if (typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    if (i3 === length) {
      target = this;
      i3--;
    }
    for (; i3 < length; i3++) {
      if ((options = arguments[i3]) != null) {
        for (name2 in options) {
          if (hasProp(options, name2))
            target[name2] = options[name2];
        }
      }
    }
    return target;
  };
  $2.assign = function() {
    let options, name2, target = arguments[0] || {}, i3 = 1, length = arguments.length;
    if (typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    if (i3 === length) {
      target = this;
      i3--;
    }
    for (; i3 < length; i3++) {
      if ((options = arguments[i3]) != null) {
        for (name2 in options) {
          if (hasProp(options, name2) && options[name2] !== void 0)
            target[name2] = options[name2];
        }
      }
    }
    return target;
  };
  (function(workerScript) {
    try {
      const blob = new Blob([`
            var fakeIdToId = {};
            onmessage = function (event) {
                var data = event.data,
                    name = data.name,
                    fakeId = data.fakeId,
                    time;
                if(data.hasOwnProperty('time')) {
                    time = data.time;
                }
                switch (name) {
                    case 'setInterval':
                        fakeIdToId[fakeId] = setInterval(function () {
                            postMessage({fakeId: fakeId});
                        }, time);
                        break;
                    case 'clearInterval':
                        if (fakeIdToId.hasOwnProperty (fakeId)) {
                            clearInterval(fakeIdToId[fakeId]);
                            delete fakeIdToId[fakeId];
                        }
                        break;
                    case 'setTimeout':
                        fakeIdToId[fakeId] = setTimeout(function () {
                            postMessage({fakeId: fakeId});
                            if (fakeIdToId.hasOwnProperty (fakeId)) {
                                delete fakeIdToId[fakeId];
                            }
                        }, time);
                        break;
                    case 'clearTimeout':
                        if (fakeIdToId.hasOwnProperty (fakeId)) {
                            clearTimeout(fakeIdToId[fakeId]);
                            delete fakeIdToId[fakeId];
                        }
                        break;
                }
            }
        `]);
      workerScript = window.URL.createObjectURL(blob);
    } catch (error) {
    }
    let worker, fakeIdToCallback = {}, lastFakeId = 0, maxFakeId = 2147483647, logPrefix = "";
    function getFakeId() {
      do {
        if (lastFakeId === maxFakeId) {
          lastFakeId = 0;
        } else {
          lastFakeId++;
        }
      } while (fakeIdToCallback.hasOwnProperty(lastFakeId));
      return lastFakeId;
    }
    if (typeof Worker === "undefined") {
      return;
    }
    try {
      worker = new Worker(workerScript);
      window.setInterval = function(callback, time) {
        const fakeId = getFakeId();
        fakeIdToCallback[fakeId] = {
          callback,
          parameters: Array.prototype.slice.call(arguments, 2)
        };
        worker.postMessage({
          name: "setInterval",
          fakeId,
          time
        });
        return fakeId;
      };
      window.clearInterval = function(fakeId) {
        if (fakeIdToCallback.hasOwnProperty(fakeId)) {
          delete fakeIdToCallback[fakeId];
          worker.postMessage({
            name: "clearInterval",
            fakeId
          });
        }
      };
      window.setTimeout = function(callback, time) {
        const fakeId = getFakeId();
        fakeIdToCallback[fakeId] = {
          callback,
          parameters: Array.prototype.slice.call(arguments, 2),
          isTimeout: true
        };
        worker.postMessage({
          name: "setTimeout",
          fakeId,
          time
        });
        return fakeId;
      };
      window.clearTimeout = function(fakeId) {
        if (fakeIdToCallback.hasOwnProperty(fakeId)) {
          delete fakeIdToCallback[fakeId];
          worker.postMessage({
            name: "clearTimeout",
            fakeId
          });
        }
      };
      window.setImmediate = function(callback) {
        return setTimeout(callback, 0);
      };
      window.clearImmediate = function(fakeId) {
        clearTimeout(fakeId);
      };
      worker.onmessage = function(event) {
        let data = event.data, fakeId = data.fakeId, request, parameters, callback;
        if (fakeIdToCallback.hasOwnProperty(fakeId)) {
          request = fakeIdToCallback[fakeId];
          callback = request.callback;
          parameters = request.parameters;
          if (request.hasOwnProperty("isTimeout") && request.isTimeout) {
            delete fakeIdToCallback[fakeId];
          }
        }
        if (typeof callback === "string") {
          try {
            callback = new Function(callback);
          } catch (error) {
            console.error(logPrefix + "Error parsing callback code string: ", error);
          }
        }
        if (typeof callback === "function") {
          callback.apply(window, parameters);
        }
      };
      worker.onerror = function(event) {
        console.error(event);
      };
    } catch (error) {
      console.log(`Can't create worker for Intervals, use standard functions.`);
    }
  })();
  $2.fn.extend({
    index: function(sel) {
      let el, _index = -1;
      if (this.length === 0) {
        return _index;
      }
      if (not2(sel)) {
        el = this[0];
      } else if (sel instanceof $2 && sel.length > 0) {
        el = sel[0];
      } else if (typeof sel === "string") {
        el = $2(sel)[0];
      } else {
        el = void 0;
      }
      if (not2(el)) {
        return _index;
      }
      if (el && el.parentNode) $2.each(el.parentNode.children, function(i3) {
        if (this === el) {
          _index = i3;
        }
      });
      return _index;
    },
    indexOf: function(sel) {
      let el, _index = -1;
      if (this.length === 0) {
        return _index;
      }
      if (not2(sel)) {
        el = this[0];
      } else if (sel instanceof $2 && sel.length > 0) {
        el = sel[0];
      } else if (typeof sel === "string") {
        el = $2(sel)[0];
      } else {
        el = void 0;
      }
      if (not2(el)) {
        return _index;
      }
      this.each(function(i3) {
        if (this === el) {
          _index = i3;
        }
      });
      return _index;
    },
    get: function(i3) {
      if (i3 === void 0) {
        return this.items();
      }
      return i3 < 0 ? this[i3 + this.length] : this[i3];
    },
    eq: function(i3) {
      return !not2(i3) && this.length > 0 ? $2.extend($2(this.get(i3)), { _prevObj: this }) : this;
    },
    is: function(s3) {
      let result = false;
      if (this.length === 0) {
        return false;
      }
      if (s3 instanceof $2) {
        return this.same(s3);
      }
      if (s3 === ":selected") {
        this.each(function() {
          if (this.selected) result = true;
        });
      } else if (s3 === ":checked") {
        this.each(function() {
          if (this.checked) result = true;
        });
      } else if (s3 === ":visible") {
        this.each(function() {
          if (isVisible(this)) result = true;
        });
      } else if (s3 === ":hidden") {
        this.each(function() {
          const styles = getComputedStyle(this);
          if (this.getAttribute("type") === "hidden" || this.hidden || styles.display === "none" || styles.visibility === "hidden" || parseInt(styles.opacity) === 0) result = true;
        });
      } else if (typeof s3 === "string" && [":selected"].indexOf(s3) === -1) {
        this.each(function() {
          if (matches.call(this, s3)) {
            result = true;
          }
        });
      } else if (isArrayLike(s3)) {
        this.each(function() {
          const el = this;
          $2.each(s3, function() {
            const sel = this;
            if (el === sel) {
              result = true;
            }
          });
        });
      } else if (typeof s3 === "object" && s3.nodeType === 1) {
        this.each(function() {
          if (this === s3) {
            result = true;
          }
        });
      }
      return result;
    },
    same: function(o2) {
      let result = true;
      if (!(o2 instanceof $2)) {
        o2 = $2(o2);
      }
      if (this.length !== o2.length) return false;
      this.each(function() {
        if (o2.items().indexOf(this) === -1) {
          result = false;
        }
      });
      return result;
    },
    last: function() {
      return this.eq(this.length - 1);
    },
    first: function() {
      return this.eq(0);
    },
    odd: function() {
      const result = this.filter(function(el, i3) {
        return i3 % 2 === 0;
      });
      return $2.extend(result, { _prevObj: this });
    },
    even: function() {
      const result = this.filter(function(el, i3) {
        return i3 % 2 !== 0;
      });
      return $2.extend(result, { _prevObj: this });
    },
    filter: function(fn) {
      if (typeof fn === "string") {
        const sel = fn;
        fn = function(el) {
          return matches.call(el, sel);
        };
      }
      return $2.extend($2.merge($2(), [].filter.call(this, fn)), { _prevObj: this });
    },
    find: function(s3) {
      let res = [], result;
      if (s3 instanceof $2) return s3;
      if (this.length === 0) {
        result = this;
      } else {
        this.each(function() {
          const el = this;
          if (typeof el.querySelectorAll === "undefined") {
            return;
          }
          res = res.concat([].slice.call(el.querySelectorAll(s3)));
        });
        result = $2.merge($2(), res);
      }
      return $2.extend(result, { _prevObj: this });
    },
    contains: function(s3) {
      return this.find(s3).length > 0;
    },
    children: function(s3) {
      let i3, res = [];
      if (s3 instanceof $2) return s3;
      this.each(function() {
        const el = this;
        for (i3 = 0; i3 < el.children.length; i3++) {
          if (el.children[i3].nodeType === 1)
            res.push(el.children[i3]);
        }
      });
      res = s3 ? res.filter(function(el) {
        return matches.call(el, s3);
      }) : res;
      return $2.extend($2.merge($2(), res), { _prevObj: this });
    },
    parent: function(s3) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s3 instanceof $2) return s3;
      this.each(function() {
        if (this.parentNode) {
          if (res.indexOf(this.parentNode) === -1) res.push(this.parentNode);
        }
      });
      res = s3 ? res.filter(function(el) {
        return matches.call(el, s3);
      }) : res;
      return $2.extend($2.merge($2(), res), { _prevObj: this });
    },
    parents: function(s3) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s3 instanceof $2) return s3;
      this.each(function() {
        let par = this.parentNode;
        while (par) {
          if (par.nodeType === 1 && res.indexOf(par) === -1) {
            if (!not2(s3)) {
              if (matches.call(par, s3)) {
                res.push(par);
              }
            } else {
              res.push(par);
            }
          }
          par = par.parentNode;
        }
      });
      return $2.extend($2.merge($2(), res), { _prevObj: this });
    },
    siblings: function(s3) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s3 instanceof $2) return s3;
      this.each(function() {
        const el = this;
        if (el.parentNode) {
          $2.each(el.parentNode.children, function() {
            if (el !== this) res.push(this);
          });
        }
      });
      if (s3) {
        res = res.filter(function(el) {
          return matches.call(el, s3);
        });
      }
      return $2.extend($2.merge($2(), res), { _prevObj: this });
    },
    _siblingAll: function(dir, s3) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s3 instanceof $2) return s3;
      this.each(function() {
        let el = this;
        while (el) {
          el = el[dir];
          if (!el) break;
          res.push(el);
        }
      });
      if (s3) {
        res = res.filter(function(el) {
          return matches.call(el, s3);
        });
      }
      return $2.extend($2.merge($2(), res), { _prevObj: this });
    },
    _sibling: function(dir, s3) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s3 instanceof $2) return s3;
      this.each(function() {
        const el = this[dir];
        if (el && el.nodeType === 1) {
          res.push(el);
        }
      });
      if (s3) {
        res = res.filter(function(el) {
          return matches.call(el, s3);
        });
      }
      return $2.extend($2.merge($2(), res), { _prevObj: this });
    },
    prev: function(s3) {
      return this._sibling("previousElementSibling", s3);
    },
    next: function(s3) {
      return this._sibling("nextElementSibling", s3);
    },
    prevAll: function(s3) {
      return this._siblingAll("previousElementSibling", s3);
    },
    nextAll: function(s3) {
      return this._siblingAll("nextElementSibling", s3);
    },
    closest: function(s3) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s3 instanceof $2) return s3;
      if (!s3) {
        return this.parent(s3);
      }
      this.each(function() {
        let el = this;
        while (el) {
          if (!el) break;
          if (matches.call(el, s3)) {
            res.push(el);
            return;
          }
          el = el.parentElement;
        }
      });
      return $2.extend($2.merge($2(), res.reverse()), { _prevObj: this });
    },
    has: function(selector) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      this.each(function() {
        const el = $2(this);
        const child = el.children(selector);
        if (child.length > 0) {
          res.push(this);
        }
      });
      return $2.extend($2.merge($2(), res), { _prevObj: this });
    },
    back: function(to_start) {
      let ret;
      if (to_start === true) {
        ret = this._prevObj;
        while (ret) {
          if (!ret._prevObj) break;
          ret = ret._prevObj;
        }
      } else {
        ret = this._prevObj ? this._prevObj : this;
      }
      return ret;
    }
  });
  function createScript(script, into = document.body) {
    const s3 = document.createElement("script");
    s3.type = "text/javascript";
    if (not2(script)) return $2(s3);
    const _script = $2(script)[0];
    if (_script.src) {
      s3.src = _script.src;
    } else {
      s3.textContent = _script.innerText;
    }
    if (_script.type) s3.type = _script.type;
    if (_script.async) s3.async = _script.async;
    into.appendChild(s3);
    if (_script.parentNode) _script.parentNode.removeChild(_script);
    return s3;
  }
  $2.extend({
    script: function(el, into) {
      if (not2(el)) {
        return;
      }
      if (el instanceof $2) {
        el = el[0];
      }
      if (el.tagName && el.tagName === "SCRIPT") {
        createScript(el, into);
      } else {
        const scripts = $2(el).find("script");
        $2.each(scripts, function() {
          createScript(this, into);
        });
      }
    },
    loadScript: function(url, into = document.body, callback) {
      const script = document.createElement("script");
      script.type = "text/javascript";
      script.src = url;
      script.onload = callback;
      into.appendChild(script);
    }
  });
  $2.fn.extend({
    script: function(into) {
      return this.each(function() {
        $2.script(this, into);
      });
    }
  });
  $2.fn.extend({
    _prop: function(prop, value) {
      if (arguments.length === 1) {
        return this.length === 0 ? void 0 : this[0][prop];
      }
      if (not2(value)) {
        value = "";
      }
      return this.each(function() {
        const el = this;
        el[prop] = value;
        if (prop === "innerHTML") {
          $2.script(el, el);
        }
      });
    },
    prop: function(prop, value) {
      return arguments.length === 1 ? this._prop(prop) : this._prop(prop, typeof value === "undefined" ? "" : value);
    },
    val: function(value) {
      if (not2(value)) {
        return this.length === 0 ? void 0 : this[0].value;
      }
      return this.each(function() {
        const el = $2(this);
        if (typeof this.value !== "undefined") {
          this.value = value;
        } else {
          el.html(value);
        }
      });
    },
    html: function(value) {
      const that = this, v4 = [];
      if (arguments.length === 0) {
        return this._prop("innerHTML");
      }
      if (value instanceof $2) {
        value.each(function() {
          v4.push($2(this).outerHTML());
        });
      } else {
        v4.push(value);
      }
      that._prop("innerHTML", v4.join("\n"));
      return this;
    },
    outerHTML: function() {
      return this._prop("outerHTML");
    },
    text: function(value) {
      return arguments.length === 0 ? this._prop("textContent") : this._prop("textContent", typeof value === "undefined" ? "" : value);
    },
    innerText: function(value) {
      return arguments.length === 0 ? this._prop("innerText") : this._prop("innerText", typeof value === "undefined" ? "" : value);
    },
    empty: function() {
      return this.each(function() {
        if (typeof this.innerHTML !== "undefined") this.innerHTML = "";
      });
    },
    clear: function() {
      return this.empty();
    }
  });
  $2.each = function(ctx, cb) {
    let index = 0;
    if (isArrayLike(ctx)) {
      [].forEach.call(ctx, function(val, key) {
        cb.apply(val, [key, val]);
      });
    } else {
      for (const key in ctx) {
        if (hasProp(ctx, key))
          cb.apply(ctx[key], [key, ctx[key], index++]);
      }
    }
    return ctx;
  };
  $2.fn.extend({
    each: function(cb) {
      return $2.each(this, cb);
    }
  });
  var Data = function(ns) {
    this.expando = "DATASET:UID:" + ns.toUpperCase();
    Data.uid++;
  };
  Data.uid = -1;
  Data.prototype = {
    cache: function(owner) {
      let value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      let prop, cache = this.cache(owner);
      if (typeof data === "string") {
        cache[camelCase(data)] = value;
      } else {
        for (prop in data) {
          if (hasProp(data, prop))
            cache[camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === void 0 ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function(owner, key, value) {
      if (key === void 0 || key && typeof key === "string" && value === void 0) {
        return this.get(owner, key);
      }
      this.set(owner, key, value);
      return value !== void 0 ? value : key;
    },
    remove: function(owner, key) {
      let i3, cache = owner[this.expando];
      if (cache === void 0) {
        return;
      }
      if (key !== void 0) {
        if (Array.isArray(key)) {
          key = key.map(camelCase);
        } else {
          key = camelCase(key);
          key = key in cache ? [key] : key.match(/[^\x20\t\r\n\f]+/g) || [];
        }
        i3 = key.length;
        while (i3--) {
          delete cache[key[i3]];
        }
      }
      if (key === void 0 || isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = void 0;
        } else {
          delete owner[this.expando];
        }
      }
      return true;
    },
    hasData: function(owner) {
      const cache = owner[this.expando];
      return cache !== void 0 && !isEmptyObject(cache);
    }
  };
  var dataSet = new Data("dom");
  $2.extend({
    hasData: function(elem) {
      return dataSet.hasData(elem);
    },
    data: function(elem, key, val) {
      return dataSet.access(elem, key, val);
    },
    removeData: function(elem, key) {
      return dataSet.remove(elem, key);
    },
    dataSet: function(ns) {
      if (not2(ns)) return dataSet;
      if (["INTERNAL", "DOM"].indexOf(ns.toUpperCase()) > -1) {
        throw Error("You can not use reserved name for your dataset");
      }
      return new Data(ns);
    }
  });
  $2.fn.extend({
    data: function(key, val) {
      let res, elem, data, attrs, name2, i3;
      if (this.length === 0) {
        return;
      }
      elem = this[0];
      if (arguments.length === 0) {
        if (this.length) {
          data = dataSet.get(elem);
          if (elem.nodeType === 1) {
            attrs = elem.attributes;
            i3 = attrs.length;
            while (i3--) {
              if (attrs[i3]) {
                name2 = attrs[i3].name;
                if (name2.indexOf("data-") === 0) {
                  name2 = camelCase(name2.slice(5));
                  dataAttr(elem, name2, data[name2]);
                }
              }
            }
          }
        }
        return data;
      }
      if (arguments.length === 1) {
        res = dataSet.get(elem, key);
        if (res === void 0) {
          if (elem.nodeType === 1) {
            if (elem.hasAttribute("data-" + key)) {
              res = elem.getAttribute("data-" + key);
            }
          }
        }
        return res;
      }
      return this.each(function() {
        dataSet.set(this, key, val);
      });
    },
    removeData: function(key) {
      return this.each(function() {
        dataSet.remove(this, key);
      });
    },
    origin: function(name2, value, def) {
      if (this.length === 0) {
        return this;
      }
      if (not2(name2) && not2(value)) {
        return $2.data(this[0]);
      }
      if (not2(value)) {
        const res = $2.data(this[0], "origin-" + name2);
        return !not2(res) ? res : def;
      }
      this.data("origin-" + name2, value);
      return this;
    }
  });
  $2.extend({
    device: /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase()),
    localhost: isLocalhost(),
    isLocalhost,
    touchable: isTouch(),
    isPrivateAddress,
    uniqueId: function(prefix) {
      let d3 = (/* @__PURE__ */ new Date()).getTime();
      if (not2(prefix)) {
        prefix = "m4q";
      }
      return (prefix !== "" ? prefix + "-" : "") + "xxxx-xxxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c3) {
        const r2 = (d3 + Math.random() * 16) % 16 | 0;
        d3 = Math.floor(d3 / 16);
        return (c3 === "x" ? r2 : r2 & 3 | 8).toString(16);
      });
    },
    toArray: function(n2) {
      let i3, out = [];
      for (i3 = 0; i3 < n2.length; i3++) {
        out.push(n2[i3]);
      }
      return out;
    },
    import: function(ctx) {
      const res = [];
      this.each(ctx, function() {
        res.push(this);
      });
      return this.merge($2(), res);
    },
    merge: function(first, second) {
      let len = +second.length, j4 = 0, i3 = first.length;
      for (; j4 < len; j4++) {
        first[i3++] = second[j4];
      }
      first.length = i3;
      return first;
    },
    type: function(obj) {
      return Object.prototype.toString.call(obj).replace(/^\[object (.+)]$/, "$1").toLowerCase();
    },
    isSelector: function(selector) {
      if (typeof selector !== "string") {
        return false;
      }
      try {
        document.querySelector(selector);
        return true;
      } catch (error) {
        return false;
      }
    },
    remove: function(s3) {
      return $2(s3).remove();
    },
    isPlainObject,
    isEmptyObject,
    isArrayLike,
    acceptData,
    not: not2,
    parseUnit,
    getUnit,
    unit: parseUnit,
    isVisible,
    isHidden,
    matches: function(el, s3) {
      return matches.call(el, s3);
    },
    random: function(from, to2) {
      if (arguments.length === 1 && isArrayLike(from)) {
        return from[Math.floor(Math.random() * from.length)];
      }
      return Math.floor(Math.random() * (to2 - from + 1) + from);
    },
    hasProp,
    dark: globalThis.matchMedia && globalThis.matchMedia("(prefers-color-scheme: dark)").matches,
    serializeToArray: function(form) {
      const _form = $2(form)[0];
      if (!_form || _form.nodeName !== "FORM") {
        console.warn("Element is not a HTMLFromElement");
        return;
      }
      let i3, j4, q4 = [];
      for (i3 = _form.elements.length - 1; i3 >= 0; i3 = i3 - 1) {
        if (_form.elements[i3].name === "") {
          continue;
        }
        switch (_form.elements[i3].nodeName) {
          case "INPUT":
            switch (_form.elements[i3].type) {
              case "checkbox":
              case "radio":
                if (_form.elements[i3].checked) {
                  q4.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
                }
                break;
              case "file":
                break;
              default:
                q4.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
            }
            break;
          case "TEXTAREA":
            q4.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
            break;
          case "SELECT":
            switch (_form.elements[i3].type) {
              case "select-one":
                q4.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
                break;
              case "select-multiple":
                for (j4 = _form.elements[i3].options.length - 1; j4 >= 0; j4 = j4 - 1) {
                  if (_form.elements[i3].options[j4].selected) {
                    q4.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].options[j4].value));
                  }
                }
                break;
            }
            break;
          case "BUTTON":
            switch (_form.elements[i3].type) {
              case "reset":
              case "submit":
              case "button":
                q4.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
                break;
            }
            break;
        }
      }
      return q4;
    },
    serialize: function(form) {
      return $2.serializeToArray(form).join("&");
    },
    viewport: function() {
      const w5 = window, d3 = document, e2 = d3.documentElement, g4 = d3.getElementsByTagName("body")[0], x4 = w5.innerWidth || e2.clientWidth || g4.clientWidth, y3 = w5.innerHeight || e2.clientHeight || g4.clientHeight;
      return { width: x4, height: y3 };
    }
  });
  $2.fn.extend({
    items: function() {
      return $2.toArray(this);
    }
  });
  var overriddenStop = Event.prototype.stopPropagation;
  var overriddenPrevent = Event.prototype.preventDefault;
  Event.prototype.stopPropagation = function() {
    this.isPropagationStopped = true;
    overriddenStop.apply(this, arguments);
  };
  Event.prototype.preventDefault = function() {
    this.isPreventedDefault = true;
    overriddenPrevent.apply(this, arguments);
  };
  Event.prototype.stop = function(immediate) {
    return immediate ? this.stopImmediatePropagation() : this.stopPropagation();
  };
  $2.extend({
    events: [],
    eventHooks: {},
    eventUID: -1,
    /*
    * el, eventName, handler, selector, ns, id, options
    * */
    setEventHandler: function(obj) {
      let i3, freeIndex = -1, eventObj, resultIndex;
      if (this.events.length > 0) {
        for (i3 = 0; i3 < this.events.length; i3++) {
          if (this.events[i3].handler === null) {
            freeIndex = i3;
            break;
          }
        }
      }
      eventObj = {
        element: obj.el,
        event: obj.event,
        handler: obj.handler,
        selector: obj.selector,
        ns: obj.ns,
        id: obj.id,
        options: obj.options
      };
      if (freeIndex === -1) {
        this.events.push(eventObj);
        resultIndex = this.events.length - 1;
      } else {
        this.events[freeIndex] = eventObj;
        resultIndex = freeIndex;
      }
      return resultIndex;
    },
    getEventHandler: function(index) {
      if (this.events[index] !== void 0 && this.events[index] !== null) {
        this.events[index] = null;
        return this.events[index].handler;
      }
      return void 0;
    },
    off: function() {
      $2.each(this.events, function() {
        this.element.removeEventListener(this.event, this.handler, true);
      });
      this.events = [];
      return this;
    },
    getEvents: function() {
      return this.events;
    },
    getEventHooks: function() {
      return this.eventHooks;
    },
    addEventHook: function(event, handler, type = "before") {
      $2.each(str2arr(event), function() {
        this.eventHooks[camelCase(type + "-" + this)] = handler;
      });
      return this;
    },
    removeEventHook: function(event, type = "before") {
      $2.each(str2arr(event), function() {
        delete this.eventHooks[camelCase(type + "-" + this)];
      });
      return this;
    },
    removeEventHooks: function(event) {
      const that = this;
      if (not2(event)) {
        this.eventHooks = {};
      } else {
        $2.each(str2arr(event), function() {
          delete that.eventHooks[camelCase("before-" + this)];
          delete that.eventHooks[camelCase("after-" + this)];
        });
      }
      return this;
    }
  });
  $2.fn.extend({
    on: function(eventsList, sel, handler, options) {
      if (this.length === 0) {
        return;
      }
      if (typeof sel === "function") {
        options = handler;
        handler = sel;
        sel = void 0;
      }
      if (!isPlainObject(options)) {
        options = {};
      }
      return this.each(function() {
        const el = this;
        $2.each(str2arr(eventsList), function() {
          let h3, ev = this, event = ev.split("."), name2 = normName(event[0]), ns = options.ns ? options.ns : event[1], index, originEvent;
          $2.eventUID++;
          h3 = function(e2) {
            let target = e2.target;
            const beforeHook = $2.eventHooks[camelCase("before-" + name2)];
            const afterHook = $2.eventHooks[camelCase("after-" + name2)];
            if (typeof beforeHook === "function") {
              beforeHook.call(target, e2);
            }
            if (!sel) {
              handler.call(el, e2);
            } else {
              while (target && target !== el) {
                if (matches.call(target, sel)) {
                  handler.call(target, e2);
                  if (e2.isPropagationStopped) {
                    e2.stopImmediatePropagation();
                    break;
                  }
                }
                target = target.parentNode;
              }
            }
            if (typeof afterHook === "function") {
              afterHook.call(target, e2);
            }
            if (options.once) {
              index = +$2(el).origin("event-" + e2.type + (sel ? ":" + sel : "") + (ns ? ":" + ns : ""));
              if (!isNaN(index)) $2.events.splice(index, 1);
            }
          };
          Object.defineProperty(h3, "name", {
            value: handler.name && handler.name !== "" ? handler.name : "func_event_" + name2 + "_" + $2.eventUID
          });
          originEvent = name2 + (sel ? ":" + sel : "") + (ns ? ":" + ns : "");
          el.addEventListener(name2, h3, !isEmptyObject(options) ? options : false);
          index = $2.setEventHandler({
            el,
            event: name2,
            handler: h3,
            selector: sel,
            ns,
            id: $2.eventUID,
            options: !isEmptyObject(options) ? options : false
          });
          $2(el).origin("event-" + originEvent, index);
        });
      });
    },
    one: function(events, sel, handler, options) {
      if (!isPlainObject(options)) {
        options = {};
      }
      options.once = true;
      return this.on.apply(this, [events, sel, handler, options]);
    },
    off: function(eventsList, sel, options) {
      if (isPlainObject(sel)) {
        options = sel;
        sel = null;
      }
      if (!isPlainObject(options)) {
        options = {};
      }
      if (not2(eventsList) || eventsList.toLowerCase() === "all") {
        return this.each(function() {
          const el = this;
          $2.each($2.events, function() {
            const e2 = this;
            if (e2.element === el) {
              el.removeEventListener(e2.event, e2.handler, e2.options);
              e2.handler = null;
              $2(el).origin("event-" + name + (e2.selector ? ":" + e2.selector : "") + (e2.ns ? ":" + e2.ns : ""), null);
            }
          });
        });
      }
      return this.each(function() {
        const el = this;
        $2.each(str2arr(eventsList), function() {
          let evMap = this.split("."), name2 = normName(evMap[0]), ns = options.ns ? options.ns : evMap[1], originEvent, index;
          originEvent = "event-" + name2 + (sel ? ":" + sel : "") + (ns ? ":" + ns : "");
          index = $2(el).origin(originEvent);
          if (index !== void 0 && $2.events[index].handler) {
            el.removeEventListener(name2, $2.events[index].handler, $2.events[index].options);
            $2.events[index].handler = null;
          }
          $2(el).origin(originEvent, null);
        });
      });
    },
    trigger: function(name2, data) {
      return this.fire(name2, data);
    },
    fire: function(name2, data) {
      let _name, e2;
      if (this.length === 0) {
        return;
      }
      _name = normName(name2);
      if (["focus", "blur"].indexOf(_name) > -1) {
        this[0][_name]();
        return this;
      }
      e2 = new CustomEvent(_name, {
        bubbles: true,
        cancelable: true,
        detail: data
      });
      return this.each(function() {
        this.dispatchEvent(e2);
      });
    }
  });
  "blur focus resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu touchstart touchend touchmove touchcancel".split(" ").forEach(
    function(name2) {
      $2.fn[name2] = function(sel, fn, opt2) {
        return arguments.length > 0 ? this.on(name2, sel, fn, opt2) : this.fire(name2);
      };
    }
  );
  $2.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  $2.ready = function(fn, options) {
    document.addEventListener("DOMContentLoaded", fn, options || false);
  };
  $2.load = function(fn) {
    return $2(window).on("load", fn);
  };
  $2.unload = function(fn) {
    return $2(window).on("unload", fn);
  };
  $2.fn.extend({
    unload: function(fn) {
      return this.length === 0 || this[0].self !== window ? void 0 : $2.unload(fn);
    }
  });
  $2.beforeunload = function(fn) {
    if (typeof fn === "string") {
      return $2(window).on("beforeunload", function(e2) {
        e2.returnValue = fn;
        return fn;
      });
    } else {
      return $2(window).on("beforeunload", fn);
    }
  };
  $2.fn.extend({
    beforeunload: function(fn) {
      return this.length === 0 || this[0].self !== window ? void 0 : $2.beforeunload(fn);
    }
  });
  $2.fn.extend({
    ready: function(fn) {
      if (this.length && this[0] === document && typeof fn === "function") {
        return $2.ready(fn);
      }
    }
  });
  $2.ajax = function(p3) {
    return new Promise(function(resolve, reject) {
      const xhr = new XMLHttpRequest();
      let method = (p3.method || "GET").toUpperCase();
      const headers = [];
      const async = not2(p3.async) ? true : p3.async;
      let url = p3.url;
      let data;
      const exec = function(fn, params) {
        if (typeof fn === "function") {
          fn.apply(null, params);
        }
      };
      const isGet = function(method2) {
        return ["GET", "JSON"].indexOf(method2) !== -1;
      };
      const plainObjectToData = function(obj) {
        const _data = [];
        $2.each(obj, function(k4, v4) {
          const _v = isSimple(v4) ? v4 : JSON.stringify(v4);
          _data.push(k4 + "=" + _v);
        });
        return _data.join("&");
      };
      if (p3.data instanceof HTMLFormElement) {
        let _action = p3.data.getAttribute("action").trim();
        let _method = p3.data.getAttribute("method").trim();
        if (not2(url) && _action) {
          url = _action;
        }
        if (_method) {
          method = _method.toUpperCase();
        }
      }
      if (p3.timeout) {
        xhr.timeout = p3.timeout;
      }
      if (p3.withCredentials) {
        xhr.withCredentials = p3.withCredentials;
      }
      if (p3.data instanceof HTMLFormElement) {
        data = $2.serialize(p3.data);
      } else if (p3.data instanceof HTMLElement && p3.data.getAttribute("type") && p3.data.getAttribute("type").toLowerCase() === "file") {
        const _name = p3.data.getAttribute("name");
        data = new FormData();
        for (let i3 = 0; i3 < p3.data.files.length; i3++) {
          data.append(_name, p3.data.files[i3]);
        }
      } else if (isPlainObject(p3.data)) {
        data = plainObjectToData(p3.data);
      } else if (p3.data instanceof FormData) {
        data = p3.data;
      } else if (typeof p3.data === "string") {
        data = p3.data;
      } else {
        data = new FormData();
        data.append("_data", JSON.stringify(p3.data));
      }
      if (isGet(method)) {
        url += typeof data === "string" ? "?" + data : isEmptyObject(data) ? "" : "?" + JSON.stringify(data);
      }
      xhr.open(method, url, async, p3.user, p3.password);
      if (p3.headers) {
        $2.each(p3.headers, function(k4, v4) {
          xhr.setRequestHeader(k4, v4);
          headers.push(k4);
        });
      }
      if (!isGet(method)) {
        if (headers.indexOf("Content-type") === -1 && p3.contentType !== false) {
          xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        }
      }
      xhr.send(data);
      xhr.addEventListener("load", function(e2) {
        if (xhr.readyState === 4 && xhr.status < 300) {
          let _return = p3.returnValue && p3.returnValue === "xhr" ? xhr : xhr.response;
          if (p3.parseJson) {
            try {
              _return = JSON.parse(_return);
            } catch (ex) {
              _return = {};
            }
          }
          exec(resolve, [_return]);
          exec(p3.onSuccess, [e2, xhr]);
        } else {
          exec(reject, [xhr]);
          exec(p3.onFail, [e2, xhr]);
        }
        exec(p3.onLoad, [e2, xhr]);
      });
      $2.each(["readystatechange", "error", "timeout", "progress", "loadstart", "loadend", "abort"], function() {
        const ev = camelCase("on-" + (this === "readystatechange" ? "state" : this));
        xhr.addEventListener(ev, function(e2) {
          exec(p3[ev], [e2, xhr]);
        });
      });
    });
  };
  ["GET", "POST", "PUT", "PATCH", "DELETE", "JSON"].forEach(function(method) {
    $2[method.toLowerCase()] = function(url, data, options) {
      const _options = {
        method: method === "JSON" ? "GET" : method,
        url,
        data,
        parseJson: method === "JSON"
      };
      return $2.ajax($2.extend({}, _options, options));
    };
  });
  $2.fn.extend({
    load: function(url, data, options) {
      const that = this;
      if (this.length && this[0].self === window) {
        return $2.load(url);
      }
      return $2.get(url, data, options).then(function(data2) {
        that.each(function() {
          this.innerHTML = data2;
        });
      });
    }
  });
  $2.fn.extend({
    style: function(name2, pseudo) {
      let el;
      function _getStyle2(el2, prop, pseudo2) {
        return ["scrollLeft", "scrollTop"].indexOf(prop) > -1 ? $2(el2)[prop]() : getComputedStyle(el2, pseudo2)[prop];
      }
      if (typeof name2 === "string" && this.length === 0) {
        return void 0;
      }
      if (this.length === 0) {
        return this;
      }
      el = this[0];
      if (not2(name2) || name2 === "all") {
        return getComputedStyle(el, pseudo);
      } else {
        let result = {}, names = name2.split(", ").map(function(el2) {
          return ("" + el2).trim();
        });
        if (names.length === 1) {
          return _getStyle2(el, names[0], pseudo);
        } else {
          $2.each(names, function() {
            const prop = this;
            result[this] = _getStyle2(el, prop, pseudo);
          });
          return result;
        }
      }
    },
    removeStyleProperty: function(name2) {
      if (not2(name2) || this.length === 0) return this;
      const names = name2.split(", ").map(function(el) {
        return ("" + el).trim();
      });
      return this.each(function() {
        const el = this;
        $2.each(names, function() {
          el.style.removeProperty(this);
        });
      });
    },
    removeStyle: function(name2) {
      if (!name2) return this;
      const names = str2arr(name2, ", ");
      return this.each(function() {
        const el = this;
        $2.each(names, function() {
          el.style[this] = "";
        });
      });
    },
    css: function(key, val) {
      key = key || "all";
      if (typeof key === "string" && not2(val)) {
        return this.style(key);
      }
      return this.each(function() {
        const el = this;
        if (typeof key === "object") {
          $2.each(key, function(key2, val2) {
            setStyleProp(el, key2, val2);
          });
        } else if (typeof key === "string") {
          setStyleProp(el, key, val);
        }
      });
    },
    cssVar: function(name2, val) {
      if (not2(name2)) return this;
      if (not2(val)) {
        return getComputedStyle(this[0]).getPropertyValue("--" + name2);
      } else {
        return this.each(function() {
          this.style.setProperty("--" + name2, val);
        });
      }
    }
  });
  $2.fn.extend({
    addClass: function() {
    },
    removeClass: function() {
    },
    toggleClass: function() {
    },
    containsClass: function(cls) {
      return this.hasClass(cls);
    },
    hasClass: function(cls) {
      let result = false;
      const classes = cls.split(" ").filter(function(v4) {
        return ("" + v4).trim() !== "";
      });
      if (not2(cls)) {
        return false;
      }
      this.each(function() {
        const el = this;
        $2.each(classes, function() {
          if (!result && el.classList && el.classList.contains(this)) {
            result = true;
          }
        });
      });
      return result;
    },
    clearClasses: function() {
      return this.each(function() {
        this.className = "";
      });
    },
    cls: function(array = false) {
      return this.length === 0 ? void 0 : array ? this[0].className.split(" ") : this[0].className;
    },
    removeClassBy: function(mask) {
      return this.each(function() {
        const el = $2(this);
        const classes = el.cls(true);
        $2.each(classes, function() {
          const elClass = this;
          if (elClass.indexOf(mask) > -1) {
            el.removeClass(elClass);
          }
        });
      });
    },
    classNames: function() {
      const args = Array.prototype.slice.call(arguments, 0);
      const classes = [];
      $2.each(args, function(_4, a3) {
        if (typeof a3 === "string") {
          classes.push(a3);
        } else if (isPlainObject(a3)) {
          $2.each(a3, function(k4, v4) {
            if (v4) {
              classes.push(k4);
            }
          });
        } else {
          nothing();
        }
      });
      return this.each(function() {
        this.className += " " + classes.join(" ");
      });
    }
  });
  ["add", "remove", "toggle"].forEach(function(method) {
    $2.fn[method + "Class"] = function(cls) {
      const _classes = !cls ? [] : Array.isArray(cls) ? cls : cls.split(" ").filter(function(v4) {
        return !!v4;
      });
      if (!_classes.length) return this;
      return this.each(function() {
        const el = this;
        const hasClassList = typeof el.classList !== "undefined";
        if (hasClassList) {
          $2.each(_classes, function(_4, v4) {
            el.classList[method](v4);
          });
        } else {
          el.className += _classes.join(" ");
        }
      });
    };
  });
  $2.parseHTML = function(data) {
    let base, singleTag, result = [], ctx, _context;
    const regexpSingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    if (typeof data !== "string") {
      return [];
    }
    data = data.trim();
    ctx = document.implementation.createHTMLDocument("");
    base = ctx.createElement("base");
    base.href = document.location.href;
    ctx.head.appendChild(base);
    _context = ctx.body;
    singleTag = regexpSingleTag.exec(data);
    if (singleTag) {
      result.push(document.createElement(singleTag[1]));
    } else {
      _context.innerHTML = data;
      for (let i3 = 0; i3 < _context.childNodes.length; i3++) {
        result.push(_context.childNodes[i3]);
      }
    }
    return result;
  };
  $2.fn.extend({
    _size: function(prop, val) {
      if (this.length === 0) return;
      if (not2(val)) {
        const el = this[0];
        if (prop === "height") {
          return el === window ? window.innerHeight : el === document ? el.body.clientHeight : parseInt(getComputedStyle(el).height);
        }
        if (prop === "width") {
          return el === window ? window.innerWidth : el === document ? el.body.clientWidth : parseInt(getComputedStyle(el).width);
        }
      }
      return this.each(function() {
        const el = this;
        if (el === window || el === document) {
          return;
        }
        el.style[prop] = isNaN(val) ? val : val + "px";
      });
    },
    height: function(val) {
      return this._size("height", val);
    },
    width: function(val) {
      return this._size("width", val);
    },
    _sizeOut: function(prop, val) {
      let el, size, style, result;
      if (this.length === 0) {
        return;
      }
      if (!not2(val) && typeof val !== "boolean") {
        return this.each(function() {
          const el2 = this;
          if (el2 === window || el2 === document) {
            return;
          }
          let h3, style2 = getComputedStyle(el2), bs = prop === "width" ? parseInt(style2["border-left-width"]) + parseInt(style2["border-right-width"]) : parseInt(style2["border-top-width"]) + parseInt(style2["border-bottom-width"]), pa = prop === "width" ? parseInt(style2["padding-left"]) + parseInt(style2["padding-right"]) : parseInt(style2["padding-top"]) + parseInt(style2["padding-bottom"]);
          h3 = $2(this)[prop](val)[prop]() - bs - pa;
          el2.style[prop] = h3 + "px";
        });
      }
      el = this[0];
      size = el[prop === "width" ? "offsetWidth" : "offsetHeight"];
      style = getComputedStyle(el);
      result = size + parseInt(style[prop === "width" ? "margin-left" : "margin-top"]) + parseInt(style[prop === "width" ? "margin-right" : "margin-bottom"]);
      return val === true ? result : size;
    },
    outerWidth: function(val) {
      return this._sizeOut("width", val);
    },
    outerHeight: function(val) {
      return this._sizeOut("height", val);
    },
    padding: function(p3) {
      if (this.length === 0) return;
      const s3 = getComputedStyle(this[0], p3);
      return {
        top: parseInt(s3["padding-top"]),
        right: parseInt(s3["padding-right"]),
        bottom: parseInt(s3["padding-bottom"]),
        left: parseInt(s3["padding-left"])
      };
    },
    margin: function(p3) {
      if (this.length === 0) return;
      const s3 = getComputedStyle(this[0], p3);
      return {
        top: parseInt(s3["margin-top"]),
        right: parseInt(s3["margin-right"]),
        bottom: parseInt(s3["margin-bottom"]),
        left: parseInt(s3["margin-left"])
      };
    },
    border: function(p3) {
      if (this.length === 0) return;
      const s3 = getComputedStyle(this[0], p3);
      return {
        top: parseInt(s3["border-top-width"]),
        right: parseInt(s3["border-right-width"]),
        bottom: parseInt(s3["border-bottom-width"]),
        left: parseInt(s3["border-left-width"])
      };
    }
  });
  $2.fn.extend({
    offset: function(val) {
      let rect;
      if (not2(val)) {
        if (this.length === 0) return void 0;
        rect = this[0].getBoundingClientRect();
        return {
          top: rect.top + scrollY,
          left: rect.left + scrollX
        };
      }
      return this.each(function() {
        let el = $2(this), top = val.top, left = val.left, position = getComputedStyle(this).position, offset = el.offset();
        if (position === "static") {
          el.css("position", "relative");
        }
        if (["absolute", "fixed"].indexOf(position) === -1) {
          top = top - offset.top;
          left = left - offset.left;
        }
        el.css({
          top,
          left
        });
      });
    },
    position: function(margin = false) {
      let ml = 0, mt3 = 0, el, style;
      if (this.length === 0) {
        return void 0;
      }
      el = this[0];
      style = getComputedStyle(el);
      if (margin) {
        ml = parseInt(style["margin-left"]);
        mt3 = parseInt(style["margin-top"]);
      }
      return {
        left: el.offsetLeft - ml,
        top: el.offsetTop - mt3
      };
    },
    left: function(val, margin) {
      if (this.length === 0) return;
      if (not2(val)) {
        return this.position(margin).left;
      }
      if (typeof val === "boolean") {
        margin = val;
        return this.position(margin).left;
      }
      return this.each(function() {
        $2(this).css({
          left: val
        });
      });
    },
    top: function(val, margin) {
      if (this.length === 0) return;
      if (not2(val)) {
        return this.position(margin).top;
      }
      if (typeof val === "boolean") {
        margin = val;
        return this.position(margin).top;
      }
      return this.each(function() {
        $2(this).css({
          top: val
        });
      });
    },
    rect: function() {
      return this.length === 0 ? void 0 : this[0].getBoundingClientRect();
    },
    pos: function() {
      if (this.length === 0) return;
      const el = this[0];
      return {
        top: parseInt(el.style("top")),
        left: parseInt(el.style("left"))
      };
    }
  });
  $2.fn.extend({
    attr: function(name2, val) {
      const attributes = {};
      if (this.length === 0 && arguments.length === 0) {
        return void 0;
      }
      if (this.length && arguments.length === 0) {
        $2.each(this[0].attributes, function() {
          attributes[this.nodeName] = this.nodeValue;
        });
        return attributes;
      }
      if (arguments.length === 1 && typeof name2 === "string") {
        return this.length && this[0].nodeType === 1 && this[0].hasAttribute(name2) ? this[0].getAttribute(name2) : void 0;
      }
      return this.each(function() {
        const el = this;
        if (isPlainObject(name2)) {
          $2.each(name2, function(k4, v4) {
            el.setAttribute(k4, v4);
          });
        } else {
          el.setAttribute(name2, val);
        }
      });
    },
    removeAttr: function(name2) {
      let attributes;
      if (not2(name2)) {
        return this.each(function() {
          const el = this;
          $2.each(this.attributes, function() {
            el.removeAttribute(this);
          });
        });
      }
      attributes = typeof name2 === "string" ? name2.split(",").map(function(el) {
        return el.trim();
      }) : name2;
      return this.each(function() {
        const el = this;
        $2.each(attributes, function() {
          if (el.hasAttribute(this)) el.removeAttribute(this);
        });
      });
    },
    toggleAttr: function(name2, val) {
      return this.each(function() {
        const el = this;
        if (not2(val)) {
          el.removeAttribute(name2);
        } else {
          el.setAttribute(name2, val);
        }
      });
    },
    id: function(val) {
      if (typeof val === "undefined") {
        return this.length === 1 ? $2(this[0]).attr("id") : this.map((el) => $2(el).attr("id"));
      }
      return this.each(function() {
        $2(this).attr("id", val);
      });
    },
    title: function(val) {
      if (typeof val === "undefined") {
        return this.length ? $2(this[0]).attr("title") : void 0;
      }
      return this.each(function() {
        $2(this).attr("title", val);
      });
    },
    href: function(val) {
      if (typeof val === "undefined") {
        return this.length ? this[0].tagName === "A" ? this[0].href : void 0 : void 0;
      }
      return this.each(function() {
        if (this.tagName === "A") {
          this.href = val;
        }
      });
    },
    name: function(val) {
      if (typeof val === "undefined") {
        return this.length ? this[0].name ? this[0].name : void 0 : void 0;
      }
      return this.each(function() {
        if (this.name) {
          this.name = val;
        }
      });
    },
    src: function(val) {
      if (typeof val === "undefined") {
        return this.length ? this[0].src ? this[0].src : void 0 : void 0;
      }
      return this.each(function() {
        if (this.src) {
          this.src = val;
        }
      });
    }
  });
  $2.extend({
    meta: function(name2) {
      return not2(name2) ? $2("meta") : $2("meta[name='$name']".replace("$name", name2));
    },
    metaBy: function(name2) {
      return not2(name2) ? $2("meta") : $2("meta[$name]".replace("$name", name2));
    },
    doctype: function() {
      return $2("doctype");
    },
    html: function() {
      return $2("html");
    },
    head: function() {
      return $2("html").find("head");
    },
    body: function() {
      return $2("body");
    },
    document: function() {
      return $2(document);
    },
    window: function() {
      return $2(window);
    },
    charset: function(val) {
      if (val) {
        const m4 = $2("meta[charset]");
        if (m4.length > 0) {
          m4.attr("charset", val);
        }
      }
      return document.characterSet;
    },
    lang: function(val) {
      if (val) {
        const h3 = $2("html");
        if (h3.length > 0) {
          h3.attr("lang", val);
        }
      }
      return document.documentElement.lang;
    },
    title: function(val) {
      if (typeof val === "undefined") {
        return document.title;
      }
      document.title = val;
    }
  });
  $2.extend({
    bind: (fn, ctx) => fn.bind(ctx)
  });
  (function(arr) {
    arr.forEach(function(item) {
      ["append", "prepend"].forEach(function(where) {
        if (hasProp(item, where)) {
          return;
        }
        Object.defineProperty(item, where, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: function() {
            const argArr = Array.prototype.slice.call(arguments), docFrag = document.createDocumentFragment();
            argArr.forEach(function(argItem) {
              const isNode = argItem instanceof Node;
              docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
            });
            if (where === "prepend")
              this.insertBefore(docFrag, this.firstChild);
            else
              this.appendChild(docFrag);
          }
        });
      });
    });
  })([Element.prototype, Document.prototype, DocumentFragment.prototype]);
  var normalizeElements = function(s3) {
    let result;
    if (typeof s3 === "string") result = $2.isSelector(s3) ? $2(s3) : $2.parseHTML(s3);
    else if (s3 instanceof HTMLElement) result = [s3];
    else if (isArrayLike(s3)) result = s3;
    return result;
  };
  $2.fn.extend({
    appendText: function(text) {
      return this.each(function(elIndex, el) {
        el.innerHTML += text;
      });
    },
    prependText: function(text) {
      return this.each(function(elIndex, el) {
        el.innerHTML = text + el.innerHTML;
      });
    },
    append: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function(elIndex, el) {
        $2.each(_elements, function() {
          if (el === this) return;
          const child = elIndex === 0 ? this : this.cloneNode(true);
          if (child.tagName && child.tagName === "SCRIPT") {
            $2.script(child, el);
          } else {
            el.append(child);
          }
        });
      });
    },
    appendTo: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function() {
        const el = this;
        $2.each(_elements, function(parIndex, parent2) {
          if (el === this) return;
          parent2.append(parIndex === 0 ? el : el.cloneNode(true));
        });
      });
    },
    prepend: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function(elIndex, el) {
        $2.each(_elements, function() {
          if (el === this) return;
          const child = elIndex === 0 ? this : this.cloneNode(true);
          $2.script(child);
          if (child.tagName && child.tagName !== "SCRIPT") el.prepend(child);
        });
      });
    },
    prependTo: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function() {
        const el = this;
        $2.each(_elements, function(parIndex, parent2) {
          if (el === this) return;
          $2(parent2).prepend(parIndex === 0 ? el : el.cloneNode(true));
        });
      });
    },
    insertBefore: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function() {
        const el = this;
        $2.each(_elements, function(elIndex) {
          if (el === this) return;
          const parent2 = this.parentNode;
          if (parent2) {
            parent2.insertBefore(elIndex === 0 ? el : el.cloneNode(true), this);
          }
        });
      });
    },
    insertAfter: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function() {
        const el = this;
        $2.each(_elements, function(elIndex, element2) {
          if (el === this) return;
          const parent2 = this.parentNode;
          if (parent2) {
            parent2.insertBefore(elIndex === 0 ? el : el.cloneNode(true), element2.nextSibling);
          }
        });
      });
    },
    after: function(html) {
      return this.each(function() {
        const el = this;
        if (typeof html === "string") {
          el.insertAdjacentHTML("afterend", html);
        } else {
          $2(html).insertAfter(el);
        }
      });
    },
    before: function(html) {
      return this.each(function() {
        const el = this;
        if (typeof html === "string") {
          el.insertAdjacentHTML("beforebegin", html);
        } else {
          $2(html).insertBefore(el);
        }
      });
    },
    clone: function(deep, withData) {
      const res = [];
      if (not2(deep)) {
        deep = false;
      }
      if (not2(withData)) {
        withData = false;
      }
      this.each(function() {
        const el = this.cloneNode(deep);
        const $el = $2(el);
        let data;
        if (withData && $2.hasData(this)) {
          data = $2(this).data();
          $2.each(data, function(k4, v4) {
            $el.data(k4, v4);
          });
        }
        res.push(el);
      });
      return $2.merge($2(), res);
    },
    import: function(deep) {
      const res = [];
      if (not2(deep)) {
        deep = false;
      }
      this.each(function() {
        res.push(document.importNode(this, deep));
      });
      return $2.merge($2(), res);
    },
    adopt: function() {
      const res = [];
      this.each(function() {
        res.push(document.adoptNode(this));
      });
      return $2.merge($2(), res);
    },
    remove: function(selector) {
      let i3 = 0, node, out, res = [];
      if (this.length === 0) {
        return;
      }
      out = selector ? this.filter(function(el) {
        return matches.call(el, selector);
      }) : this.items();
      for (; (node = out[i3]) != null; i3++) {
        if (node.parentNode) {
          res.push(node.parentNode.removeChild(node));
          $2.removeData(node);
        }
      }
      return $2.merge($2(), res);
    },
    wrap: function(el) {
      if (this.length === 0) {
        return;
      }
      const wrapper = $2(normalizeElements(el));
      if (!wrapper.length) {
        return;
      }
      const res = [];
      this.each(function() {
        let _target, _wrapper;
        _wrapper = wrapper.clone(true, true);
        _wrapper.insertBefore(this);
        _target = _wrapper;
        while (_target.children().length) {
          _target = _target.children().eq(0);
        }
        _target.append(this);
        res.push(_wrapper);
      });
      return $2(res);
    },
    wrapAll: function(el) {
      let wrapper, _wrapper, _target;
      if (this.length === 0) {
        return;
      }
      wrapper = $2(normalizeElements(el));
      if (!wrapper.length) {
        return;
      }
      _wrapper = wrapper.clone(true, true);
      _wrapper.insertBefore(this[0]);
      _target = _wrapper;
      while (_target.children().length) {
        _target = _target.children().eq(0);
      }
      this.each(function() {
        _target.append(this);
      });
      return _wrapper;
    },
    wrapInner: function(el) {
      if (this.length === 0) {
        return;
      }
      const wrapper = $2(normalizeElements(el));
      if (!wrapper.length) {
        return;
      }
      const res = [];
      this.each(function() {
        const elem = $2(this);
        const html = elem.html();
        const wrp = wrapper.clone(true, true);
        elem.html(wrp.html(html));
        res.push(wrp);
      });
      return $2(res);
    }
  });
  $2.extend({
    animation: {
      duration: 1e3,
      ease: "linear",
      elements: {}
    }
  });
  if (typeof window["setupAnimation"] === "object") {
    $2.each(window["setupAnimation"], function(key, val) {
      if (typeof $2.animation[key] !== "undefined" && !not2(val))
        $2.animation[key] = val;
    });
  }
  var transformProps = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY"];
  var numberProps = ["opacity", "zIndex"];
  var floatProps = ["opacity", "volume"];
  var scrollProps = ["scrollLeft", "scrollTop"];
  var reverseProps = ["opacity", "volume"];
  function _validElement(el) {
    return el instanceof HTMLElement || el instanceof SVGElement;
  }
  function _getRelativeValue(to2, from) {
    const operator = /^(\*=|\+=|-=)/.exec(to2);
    if (!operator) return to2;
    const u4 = getUnit(to2) || 0;
    const x4 = parseFloat(from);
    const y3 = parseFloat(to2.replace(operator[0], ""));
    switch (operator[0][0]) {
      case "+":
        return x4 + y3 + u4;
      case "-":
        return x4 - y3 + u4;
      case "*":
        return x4 * y3 + u4;
      case "/":
        return x4 / y3 + u4;
    }
  }
  function _getStyle(el, prop, pseudo) {
    if (typeof el[prop] !== "undefined") {
      if (scrollProps.indexOf(prop) > -1) {
        return prop === "scrollLeft" ? el === window ? scrollX : el.scrollLeft : el === window ? scrollY : el.scrollTop;
      } else {
        return el[prop] || 0;
      }
    }
    return el.style[prop] || getComputedStyle(el, pseudo)[prop];
  }
  function _setStyle(el, key, val, unit, toInt) {
    if (not2(toInt)) {
      toInt = false;
    }
    key = camelCase(key);
    if (toInt) {
      val = parseInt(val);
    }
    if (_validElement(el)) {
      if (typeof el[key] !== "undefined") {
        el[key] = val;
      } else {
        el.style[key] = key === "transform" || key.toLowerCase().indexOf("color") > -1 ? val : val + unit;
      }
    } else {
      el[key] = val;
    }
  }
  function _applyStyles(el, mapProps, p3) {
    $2.each(mapProps, function(key, val) {
      _setStyle(el, key, val[0] + val[2] * p3, val[3], val[4]);
    });
  }
  function _getElementTransforms(el) {
    if (!_validElement(el)) return {};
    const str2 = el.style.transform || "";
    const reg = /(\w+)\(([^)]*)\)/g;
    const transforms = {};
    let m4;
    while (m4 = reg.exec(str2))
      transforms[m4[1]] = m4[2];
    return transforms;
  }
  function _getColorArrayFromHex(val) {
    const a3 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(val ? val : "#000000");
    return a3.slice(1).map(function(v4) {
      return parseInt(v4, 16);
    });
  }
  function _getColorArrayFromElement(el, key) {
    return getComputedStyle(el)[key].replace(/[^\d.,]/g, "").split(",").map(function(v4) {
      return parseInt(v4);
    });
  }
  function _applyTransform(el, mapProps, p3) {
    const t = [];
    const elTransforms = _getElementTransforms(el);
    $2.each(mapProps, function(key, val) {
      let from = val[0], to2 = val[1], delta = val[2], unit = val[3];
      key = "" + key;
      if (key.indexOf("rotate") > -1 || key.indexOf("skew") > -1) {
        if (unit === "") unit = "deg";
      }
      if (key.indexOf("scale") > -1) {
        unit = "";
      }
      if (key.indexOf("translate") > -1 && unit === "") {
        unit = "px";
      }
      if (unit === "turn") {
        t.push(key + "(" + to2 * p3 + unit + ")");
      } else {
        t.push(key + "(" + (from + delta * p3) + unit + ")");
      }
    });
    $2.each(elTransforms, function(key, val) {
      if (mapProps[key] === void 0) {
        t.push(key + "(" + val + ")");
      }
    });
    el.style.transform = t.join(" ");
  }
  function _applyColors(el, mapProps, p3) {
    $2.each(mapProps, function(key, val) {
      let i3, result = [0, 0, 0], v4;
      for (i3 = 0; i3 < 3; i3++) {
        result[i3] = Math.floor(val[0][i3] + val[2][i3] * p3);
      }
      v4 = "rgb(" + result.join(",") + ")";
      el.style[key] = v4;
    });
  }
  function _expandColorValue(val) {
    const regExp = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    if (val[0] === "#" && val.length === 4) {
      return "#" + val.replace(regExp, function(m4, r2, g4, b4) {
        return r2 + r2 + g4 + g4 + b4 + b4;
      });
    }
    return val[0] === "#" ? val : "#" + val;
  }
  function applyProps(el, map, p3) {
    _applyStyles(el, map.props, p3);
    _applyTransform(el, map.transform, p3);
    _applyColors(el, map.color, p3);
  }
  function createAnimationMap(el, draw, dir) {
    const map = {
      props: {},
      transform: {},
      color: {}
    };
    let i3, from, to2, delta, unit, temp;
    const elTransforms = _getElementTransforms(el);
    if (not2(dir)) {
      dir = "normal";
    }
    $2.each(draw, function(key, val) {
      const isTransformProp = transformProps.indexOf("" + key) > -1;
      const isNumProp = numberProps.indexOf("" + key) > -1;
      const isColorProp = ("" + key).toLowerCase().indexOf("color") > -1;
      if (Array.isArray(val) && val.length === 1) {
        val = val[0];
      }
      if (!Array.isArray(val)) {
        if (isTransformProp) {
          from = elTransforms[key] || key === "scale" ? 1 : 0;
        } else if (isColorProp) {
          from = _getColorArrayFromElement(el, key);
        } else {
          from = _getStyle(el, key, void 0);
        }
        from = !isColorProp ? parseUnit(from) : from;
        to2 = !isColorProp ? parseUnit(_getRelativeValue(val, Array.isArray(from) ? from[0] : from)) : _getColorArrayFromHex(val);
      } else {
        from = !isColorProp ? parseUnit(val[0]) : _getColorArrayFromHex(_expandColorValue(val[0]));
        to2 = !isColorProp ? parseUnit(val[1]) : _getColorArrayFromHex(_expandColorValue(val[1]));
      }
      if (reverseProps.indexOf("" + key) > -1 && from[0] === to2[0]) {
        from[0] = to2[0] > 0 ? 0 : 1;
      }
      if (dir === "reverse") {
        temp = from;
        from = to2;
        to2 = temp;
      }
      unit = el instanceof HTMLElement && to2[1] === "" && !isNumProp && !isTransformProp ? "px" : to2[1];
      if (isColorProp) {
        delta = [0, 0, 0];
        for (i3 = 0; i3 < 3; i3++) {
          delta[i3] = to2[i3] - from[i3];
        }
      } else {
        delta = to2[0] - from[0];
      }
      if (isTransformProp) {
        map.transform[key] = [from[0], to2[0], delta, unit];
      } else if (isColorProp) {
        map.color[key] = [from, to2, delta, unit];
      } else {
        map.props[key] = [from[0], to2[0], delta, unit, floatProps.indexOf("" + key) === -1];
      }
    });
    return map;
  }
  function minMax(val, min, max) {
    return Math.min(Math.max(val, min), max);
  }
  var Easing = {
    linear: function() {
      return function(t) {
        return t;
      };
    }
  };
  Easing.default = Easing.linear;
  var eases = {
    Sine: function() {
      return function(t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
    },
    Circ: function() {
      return function(t) {
        return 1 - Math.sqrt(1 - t * t);
      };
    },
    Back: function() {
      return function(t) {
        return t * t * (3 * t - 2);
      };
    },
    Bounce: function() {
      return function(t) {
        let pow2, b4 = 4;
        while (t < ((pow2 = Math.pow(2, --b4)) - 1) / 11) {
        }
        return 1 / Math.pow(4, 3 - b4) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
    },
    Elastic: function(amplitude, period) {
      if (not2(amplitude)) {
        amplitude = 1;
      }
      if (not2(period)) {
        period = 0.5;
      }
      const a3 = minMax(amplitude, 1, 10);
      const p3 = minMax(period, 0.1, 2);
      return function(t) {
        return t === 0 || t === 1 ? t : -a3 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p3 / (Math.PI * 2) * Math.asin(1 / a3)) * (Math.PI * 2) / p3);
      };
    }
  };
  ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function(name2, i3) {
    eases[name2] = function() {
      return function(t) {
        return Math.pow(t, i3 + 2);
      };
    };
  });
  Object.keys(eases).forEach(function(name2) {
    const easeIn = eases[name2];
    Easing["easeIn" + name2] = easeIn;
    Easing["easeOut" + name2] = function(a3, b4) {
      return function(t) {
        return 1 - easeIn(a3, b4)(1 - t);
      };
    };
    Easing["easeInOut" + name2] = function(a3, b4) {
      return function(t) {
        return t < 0.5 ? easeIn(a3, b4)(t * 2) / 2 : 1 - easeIn(a3, b4)(t * -2 + 2) / 2;
      };
    };
  });
  var defaultAnimationProps = {
    id: null,
    el: null,
    draw: {},
    dur: $2.animation.duration,
    ease: $2.animation.ease,
    loop: 0,
    pause: 0,
    dir: "normal",
    defer: 0,
    onStart: function() {
    },
    onStop: function() {
    },
    onStopAll: function() {
    },
    onPause: function() {
    },
    onPauseAll: function() {
    },
    onResume: function() {
    },
    onResumeAll: function() {
    },
    onFrame: function() {
    },
    onDone: function() {
    }
  };
  function animate(args) {
    return new Promise(function(resolve) {
      const that = this;
      const props = $2.assign({}, defaultAnimationProps, { dur: $2.animation.duration, ease: $2.animation.ease }, args);
      let id = props.id, el = props.el, draw = props.draw, dur = props.dur, ease = props.ease, loop = props.loop, onStart = props.onStart, onFrame = props.onFrame, onDone = props.onDone, pauseStart = props.pause, dir = props.dir, defer = props.defer;
      let map = {};
      let easeName = "linear", easeArgs = [], easeFn = Easing.linear, matchArgs;
      let direction = dir === "alternate" ? "normal" : dir;
      let replay = false;
      let animationID = id ? id : +(performance.now() * Math.pow(10, 14));
      if (not2(el)) {
        throw new Error("Unknown element!");
      }
      if (typeof el === "string") {
        el = document.querySelector(el);
      }
      if (typeof draw !== "function" && typeof draw !== "object") {
        throw new Error("Unknown draw object. Must be a function or object!");
      }
      if (dur === 0) {
        dur = 1;
      }
      if (dir === "alternate" && typeof loop === "number") {
        loop *= 2;
      }
      if (typeof ease === "string") {
        matchArgs = /\(([^)]+)\)/.exec(ease);
        easeName = ease.split("(")[0];
        easeArgs = matchArgs ? matchArgs[1].split(",").map(function(p3) {
          return parseFloat(p3);
        }) : [];
        easeFn = Easing[easeName] || Easing.linear;
      } else if (typeof ease === "function") {
        easeFn = ease;
      } else {
        easeFn = Easing.linear;
      }
      $2.animation.elements[animationID] = {
        element: el,
        id: null,
        stop: 0,
        pause: 0,
        loop: 0,
        t: -1,
        started: 0,
        paused: 0
      };
      const play = function() {
        if (typeof draw === "object") {
          map = createAnimationMap(el, draw, direction);
        }
        if (typeof onStart === "function") {
          onStart.apply(el);
        }
        $2.animation.elements[animationID].loop += 1;
        $2.animation.elements[animationID].started = performance.now();
        $2.animation.elements[animationID].duration = dur;
        $2.animation.elements[animationID].id = requestAnimationFrame(animate1);
      };
      const done = function() {
        cancelAnimationFrame($2.animation.elements[animationID].id);
        delete $2.animation.elements[id];
        if (typeof onDone === "function") {
          onDone.apply(el);
        }
        resolve(that);
      };
      const animate1 = function(time) {
        let p3, t;
        let { stop, pause, started: start } = $2.animation.elements[animationID];
        if ($2.animation.elements[animationID].paused) {
          start = time - $2.animation.elements[animationID].t * dur;
          $2.animation.elements[animationID].started = start;
        }
        t = ((time - start) / dur).toFixed(4);
        if (t > 1) t = 1;
        if (t < 0) t = 0;
        p3 = easeFn.apply(null, easeArgs)(t);
        $2.animation.elements[animationID].t = t;
        $2.animation.elements[animationID].p = p3;
        if (pause) {
          $2.animation.elements[animationID].id = requestAnimationFrame(animate1);
          return;
        }
        if (stop > 0) {
          if (stop === 2) {
            if (typeof draw === "function") {
              draw.bind(el)(1, 1);
            } else {
              applyProps(el, map, 1);
            }
          }
          done();
          return;
        }
        if (typeof draw === "function") {
          draw.bind(el)(t, p3);
        } else {
          applyProps(el, map, p3);
        }
        if (typeof onFrame === "function") {
          onFrame.apply(el, [t, p3]);
        }
        if (t <= 1) {
          $2.animation.elements[animationID].id = requestAnimationFrame(animate1);
        }
        if (t >= 1) {
          if (loop) {
            if (dir === "alternate") {
              direction = direction === "normal" ? "reverse" : "normal";
            }
            if (typeof loop === "boolean") {
              setTimeout(function() {
                play();
              }, pauseStart);
            } else {
              if (loop > $2.animation.elements[animationID].loop) {
                setTimeout(function() {
                  play();
                }, pauseStart);
              } else {
                done();
              }
            }
          } else {
            if (dir === "alternate" && !replay) {
              direction = direction === "normal" ? "reverse" : "normal";
              replay = true;
              play();
            } else {
              done();
            }
          }
        }
      };
      if (defer > 0) {
        setTimeout(function() {
          play();
        }, defer);
      } else {
        play();
      }
    });
  }
  function stopAnimation(id, done) {
    const an = $2.animation.elements[id];
    if (typeof an === "undefined") {
      return;
    }
    if (not2(done)) {
      done = true;
    }
    an.stop = done === true ? 2 : 1;
    if (typeof an.onStop === "function") {
      an.onStop.apply(an.element);
    }
  }
  function stopAnimationAll(done, filter) {
    $2.each($2.animation.elements, function(k4, v4) {
      if (filter) {
        if (typeof filter === "string") {
          if (matches.call(v4.element, filter)) stopAnimation(k4, done);
        } else if (filter.length) {
          $2.each(filter, function() {
            if (v4.element === this) stopAnimation(k4, done);
          });
        } else if (filter instanceof Element) {
          if (v4.element === filter) stopAnimation(k4, done);
        }
      } else {
        stopAnimation(k4, done);
      }
    });
  }
  function pauseAnimation(id) {
    const an = $2.animation.elements[id];
    if (typeof an === "undefined") {
      return;
    }
    an.pause = 1;
    an.paused = performance.now();
    if (typeof an.onPause === "function") {
      an.onPause.apply(an.element);
    }
  }
  function pauseAnimationAll(filter) {
    $2.each($2.animation.elements, function(k4, v4) {
      if (filter) {
        if (typeof filter === "string") {
          if (matches.call(v4.element, filter)) pauseAnimation(k4);
        } else if (filter.length) {
          $2.each(filter, function() {
            if (v4.element === this) pauseAnimation(k4);
          });
        } else if (filter instanceof Element) {
          if (v4.element === filter) pauseAnimation(k4);
        }
      } else {
        pauseAnimation(k4);
      }
    });
  }
  function resumeAnimation(id) {
    const an = $2.animation.elements[id];
    if (typeof an === "undefined") {
      return;
    }
    an.pause = 0;
    an.paused = 0;
    if (typeof an.onResume === "function") {
      an.onResume.apply(an.element);
    }
  }
  function resumeAnimationAll(filter) {
    $2.each($2.animation.elements, function(k4, v4) {
      if (filter) {
        if (typeof filter === "string") {
          if (matches.call(v4.element, filter)) resumeAnimation(k4);
        } else if (filter.length) {
          $2.each(filter, function() {
            if (v4.element === this) resumeAnimation(k4);
          });
        } else if (filter instanceof Element) {
          if (v4.element === filter) resumeAnimation(k4);
        }
      } else {
        resumeAnimation(k4);
      }
    });
  }
  var defaultChainOptions = {
    loop: false,
    onChainItem: null,
    onChainItemComplete: null,
    onChainComplete: null
  };
  function chain(arr, opt2) {
    const o2 = $2.extend({}, defaultChainOptions, opt2);
    if (typeof o2.loop !== "boolean") {
      o2.loop--;
    }
    if (!Array.isArray(arr)) {
      console.warn("Chain array is not defined!");
      return false;
    }
    const reducer = function(acc, item) {
      return acc.then(function() {
        if (typeof o2["onChainItem"] === "function") {
          o2["onChainItem"](item);
        }
        return animate(item).then(function() {
          if (typeof o2["onChainItemComplete"] === "function") {
            o2["onChainItemComplete"](item);
          }
        });
      });
    };
    arr.reduce(reducer, Promise.resolve()).then(function() {
      if (typeof o2["onChainComplete"] === "function") {
        o2["onChainComplete"]();
      }
      if (o2.loop) {
        chain(arr, o2);
      }
    });
  }
  $2.easing = {};
  $2.extend($2.easing, Easing);
  $2.extend({
    animate: function(args) {
      let el, draw, dur, ease, cb;
      if (arguments.length > 1) {
        el = $2(arguments[0])[0];
        draw = arguments[1];
        dur = arguments[2] || $2.animation.duration;
        ease = arguments[3] || $2.animation.ease;
        cb = arguments[4];
        if (typeof dur === "function") {
          cb = dur;
          ease = $2.animation.ease;
          dur = $2.animation.duration;
        }
        if (typeof ease === "function") {
          cb = ease;
          ease = $2.animation.ease;
        }
        return animate({
          el,
          draw,
          dur,
          ease,
          onDone: cb
        });
      }
      return animate(args);
    },
    chain,
    stop: stopAnimation,
    stopAll: stopAnimationAll,
    resume: resumeAnimation,
    resumeAll: resumeAnimationAll,
    pause: pauseAnimation,
    pauseAll: pauseAnimationAll
  });
  $2.fn.extend({
    /**
         *
    
         args = {
         draw: {} | function,
         dur: 1000,
         ease: "linear",
         loop: 0,
         pause: 0,
         dir: "normal",
         defer: 0,
         onFrame: function,
         onDone: function
         }
    
         * @returns {this}
         */
    animate: function(args) {
      const that = this;
      let draw, dur, easing, cb;
      const a3 = args;
      let compatibilityMode;
      compatibilityMode = !Array.isArray(args) && (arguments.length > 1 || arguments.length === 1 && typeof arguments[0].draw === "undefined");
      if (compatibilityMode) {
        draw = arguments[0];
        dur = arguments[1] || $2.animation.duration;
        easing = arguments[2] || $2.animation.ease;
        cb = arguments[3];
        if (typeof dur === "function") {
          cb = dur;
          dur = $2.animation.duration;
          easing = $2.animation.ease;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $2.animation.ease;
        }
        return this.each(function() {
          return $2.animate({
            el: this,
            draw,
            dur,
            ease: easing,
            onDone: cb
          });
        });
      }
      if (Array.isArray(args)) {
        $2.each(args, function() {
          const a22 = this;
          that.each(function() {
            a22.el = this;
            $2.animate(a22);
          });
        });
        return this;
      }
      return this.each(function() {
        a3.el = this;
        $2.animate(a3);
      });
    },
    chain: function(arr, loop) {
      return this.each(function() {
        const el = this;
        $2.each(arr, function() {
          this.el = el;
        });
        $2.chain(arr, loop);
      });
    },
    /**
     *
     * @param done
     * @returns {this}
     */
    stop: function(done) {
      return this.each(function() {
        const el = this;
        $2.each($2.animation.elements, function(k4, o2) {
          if (o2.element === el) {
            stopAnimation(k4, done);
          }
        });
      });
    },
    pause: function() {
      return this.each(function() {
        const el = this;
        $2.each($2.animation.elements, function(k4, o2) {
          if (o2.element === el) {
            pauseAnimation(k4);
          }
        });
      });
    },
    resume: function() {
      return this.each(function() {
        const el = this;
        $2.each($2.animation.elements, function(k4, o2) {
          if (o2.element === el) {
            resumeAnimation(k4);
          }
        });
      });
    }
  });
  $2.extend({
    hidden: function(el, val, cb) {
      el = $2(el)[0];
      if (typeof val === "string") {
        val = val.toLowerCase() === "true";
      }
      if (typeof val === "function") {
        cb = val;
        val = !el.hidden;
      }
      el.hidden = val;
      if (typeof cb === "function") {
        $2.bind(cb, el);
        cb.call(el, arguments);
      }
      return this;
    },
    hide: function(el, cb) {
      const $el = $2(el);
      el = $el[0];
      const inline = el.style.display;
      const css = getComputedStyle(el, null).display;
      $el.origin("display", {
        inline,
        css
      });
      el.style.display = "none";
      if (typeof cb === "function") {
        $2.bind(cb, el);
        cb.call(el, arguments);
      }
      return this;
    },
    show: function(el, cb) {
      const $el = $2(el);
      const display = $el.origin("display");
      el = $2(el)[0];
      el.style.display = "";
      if (display) {
        const inline = display.inline || "";
        const css = display.css || "";
        if (inline && inline !== "none") {
          el.style.display = inline;
        } else if (css === "none") {
          el.style.display = "block";
        }
      } else {
        el.style.display = "block";
      }
      if (parseInt(el.style.opacity) === 0) {
        el.style.opacity = "1";
      }
      if (typeof cb === "function") {
        $2.bind(cb, el);
        cb.call(el, arguments);
      }
      return this;
    },
    visible: function(el, mode, cb) {
      if (mode === void 0) {
        mode = true;
      }
      el.style.visibility = mode ? "visible" : "hidden";
      if (typeof cb === "function") {
        $2.bind(cb, el);
        cb.call(el, arguments);
      }
      return this;
    },
    toggle: function(el, cb) {
      const func = getComputedStyle(el, null).display !== "none" ? "hide" : "show";
      return $2[func](el, cb);
    }
  });
  $2.fn.extend({
    hide: function() {
      let callback;
      $2.each(arguments, function() {
        if (typeof this === "function") {
          callback = this;
        }
      });
      return this.each(function() {
        $2.hide(this, callback);
      });
    },
    show: function() {
      let callback;
      $2.each(arguments, function() {
        if (typeof this === "function") {
          callback = this;
        }
      });
      return this.each(function() {
        $2.show(this, callback);
      });
    },
    visible: function(mode, cb) {
      return this.each(function() {
        $2.visible(this, mode, cb);
      });
    },
    toggle: function(cb) {
      return this.each(function() {
        $2.toggle(this, cb);
      });
    },
    hidden: function(val, cb) {
      return this.each(function() {
        $2.hidden(this, val, cb);
      });
    }
  });
  $2.extend({
    fx: {
      off: false
    }
  });
  $2.fn.extend({
    fadeIn: function(dur, easing, cb) {
      return this.each(function() {
        const el = this;
        const $el = $2(el);
        const visible = !(!isVisible(el) || isVisible(el) && +$el.style("opacity") === 0);
        if (not2(dur) && not2(easing) && not2(cb)) {
          cb = null;
          dur = $2.animation.duration;
        } else if (typeof dur === "function") {
          cb = dur;
          dur = $2.animation.duration;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $2.animation.ease;
        }
        if ($2.fx.off) {
          dur = 0;
        }
        if (visible) {
          if (typeof cb === "function") {
            $2.bind(cb, this)();
          }
          return this;
        }
        const originDisplay = $el.origin("display", void 0, "block");
        el.style.opacity = "0";
        el.style.display = originDisplay;
        return $2.animate({
          el,
          draw: {
            opacity: 1
          },
          dur,
          ease: easing,
          onDone: function() {
            if (typeof cb === "function") {
              $2.bind(cb, this)();
            }
          }
        });
      });
    },
    fadeOut: function(dur, easing, cb) {
      return this.each(function() {
        const el = this;
        const $el = $2(el);
        if (not2(dur) && not2(easing) && not2(cb)) {
          cb = null;
          dur = $2.animation.duration;
        } else if (typeof dur === "function") {
          cb = dur;
          dur = $2.animation.duration;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $2.animation.ease;
        }
        $el.origin("display", $el.style("display"));
        if (!isVisible(el)) {
          if (typeof cb === "function") {
            $2.bind(cb, this)();
          }
          return this;
        }
        return $2.animate({
          el,
          draw: {
            opacity: 0
          },
          dur,
          ease: easing,
          onDone: function() {
            this.style.display = "none";
            if (typeof cb === "function") {
              $2.bind(cb, this)();
            }
          }
        });
      });
    },
    slideUp: function(dur, easing, cb) {
      return this.each(function() {
        const el = this;
        const $el = $2(el);
        let currHeight;
        if ($el.height() === 0) return;
        if (not2(dur) && not2(easing) && not2(cb)) {
          cb = null;
          dur = $2.animation.duration;
        } else if (typeof dur === "function") {
          cb = dur;
          dur = $2.animation.duration;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $2.animation.ease;
        }
        currHeight = $el.height();
        $el.origin("height", currHeight);
        $el.origin("display", $2(el).style("display"));
        $el.css({
          overflow: "hidden"
        });
        return $2.animate({
          el,
          draw: {
            height: 0
          },
          dur,
          ease: easing,
          onDone: function() {
            $el.hide().removeStyleProperty("overflow, height");
            if (typeof cb === "function") {
              $2.bind(cb, this)();
            }
          }
        });
      });
    },
    slideDown: function(dur, easing, cb) {
      return this.each(function() {
        const el = this;
        const $el = $2(el);
        let targetHeight, originDisplay;
        if (not2(dur) && not2(easing) && not2(cb)) {
          cb = null;
          dur = $2.animation.duration;
        } else if (typeof dur === "function") {
          cb = dur;
          dur = $2.animation.duration;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $2.animation.ease;
        }
        $el.show().visible(false);
        targetHeight = +$el.origin("height", void 0, $el.height());
        if (parseInt(targetHeight) === 0) {
          targetHeight = el.scrollHeight;
        }
        originDisplay = $el.origin("display", $el.style("display"), "block");
        $el.height(0).visible(true);
        $el.css({
          overflow: "hidden",
          display: originDisplay === "none" ? "block" : originDisplay
        });
        return $2.animate({
          el,
          draw: {
            height: targetHeight
          },
          dur,
          ease: easing,
          onDone: function() {
            $2(el).removeStyleProperty("overflow, height, visibility");
            if (typeof cb === "function") {
              $2.bind(cb, this)();
            }
          }
        });
      });
    },
    moveTo: function(x4, y3, dur, ease, cb) {
      const draw = {
        top: y3,
        left: x4
      };
      if (typeof dur === "function") {
        cb = dur;
        dur = $2.animation.duration;
        ease = $2.animation.ease;
      }
      if (typeof ease === "function") {
        cb = ease;
        ease = $2.animation.ease;
      }
      return this.each(function() {
        $2.animate({
          el: this,
          draw,
          dur,
          ease,
          onDone: cb
        });
      });
    },
    centerTo: function(x4, y3, dur, ease, cb) {
      if (typeof dur === "function") {
        cb = dur;
        dur = $2.animation.duration;
        ease = $2.animation.ease;
      }
      if (typeof ease === "function") {
        cb = ease;
        ease = $2.animation.ease;
      }
      return this.each(function() {
        const draw = {
          left: x4 - this.clientWidth / 2,
          top: y3 - this.clientHeight / 2
        };
        $2.animate({
          el: this,
          draw,
          dur,
          ease,
          onDone: cb
        });
      });
    },
    colorTo: function(color, dur, easing, cb) {
      const draw = {
        color
      };
      if (typeof dur === "function") {
        cb = dur;
        dur = $2.animation.duration;
        easing = $2.animation.ease;
      }
      if (typeof easing === "function") {
        cb = easing;
        easing = $2.animation.ease;
      }
      return this.each(function() {
        $2.animate({
          el: this,
          draw,
          dur,
          ease: easing,
          onDone: cb
        });
      });
    },
    backgroundTo: function(color, dur, easing, cb) {
      const draw = {
        backgroundColor: color
      };
      if (typeof dur === "function") {
        cb = dur;
        dur = $2.animation.duration;
        easing = $2.animation.ease;
      }
      if (typeof easing === "function") {
        cb = easing;
        easing = $2.animation.ease;
      }
      return this.each(function() {
        $2.animate({
          el: this,
          draw,
          dur,
          ease: easing,
          onDone: cb
        });
      });
    },
    zoomIn: function(dur, easing, cb) {
      const draw = {
        scale: [0, 1]
      };
      if (typeof dur === "function") {
        cb = dur;
        dur = $2.animation.duration;
        easing = $2.animation.ease;
      }
      if (typeof easing === "function") {
        cb = easing;
        easing = $2.animation.ease;
      }
      return this.each(function() {
        $2.animate({
          el: this,
          draw,
          dur,
          ease: easing,
          onDone: cb
        });
      });
    },
    zoomOut: function(dur = 1e3, ease = "linear", cb = () => {
    }) {
      if (typeof dur === "function") {
        cb = dur;
        dur = $2.animation.duration;
        ease = $2.animation.ease;
      }
      if (typeof ease === "function") {
        cb = ease;
        ease = $2.animation.ease;
      }
      return this.each(function() {
        $2.animate({
          el: this,
          draw: {
            scale: 0
          },
          dur,
          ease,
          onDone: cb
        });
      });
    }
  });
  $2.extend({
    scrollTop: function(val) {
      if (not2(val)) {
        return window.scrollY;
      }
      window.scrollTo(window.scrollX, val);
    },
    scrollLeft: function(val) {
      if (not2(val)) {
        return window.scrollX;
      }
      window.scrollTo(val, window.scrollY);
    },
    scrollTo: function(x4, y3) {
      window.scrollTo(x4, y3);
    },
    scrollToElement: function(el) {
      $2(el).scrollTo();
    }
  });
  $2.fn.extend({
    scrollTop: function(val) {
      if (not2(val)) {
        return this.length === 0 ? void 0 : this[0] === window ? scrollY : this[0].scrollTop;
      }
      return this.each(function() {
        this.scrollTop = val;
      });
    },
    scrollLeft: function(val) {
      if (not2(val)) {
        return this.length === 0 ? void 0 : this[0] === window ? scrollX : this[0].scrollLeft;
      }
      return this.each(function() {
        this.scrollLeft = val;
      });
    },
    scrollTo: function(relativeToViewport = false) {
      if (this.length === 0) {
        return this;
      }
      const rect = this[0].getBoundingClientRect();
      const x4 = rect.left + (relativeToViewport ? 0 : window.scrollX);
      const y3 = rect.top + (relativeToViewport ? 0 : window.scrollY);
      window.scrollTo(x4, y3);
      return this;
    }
  });
  $2.init = function(sel, ctx) {
    let parsed;
    const that = this;
    if (typeof sel === "string") {
      sel = sel.trim();
    }
    this.uid = $2.uniqueId();
    if (!sel) {
      return this;
    }
    if (typeof sel === "function") {
      return $2.ready(sel);
    }
    if (sel instanceof Element) {
      this.push(sel);
      return this;
    }
    if (sel instanceof $2) {
      $2.each(sel, function() {
        that.push(this);
      });
      return this;
    }
    if (sel === "window") sel = window;
    if (sel === "document") sel = document;
    if (sel === "body") sel = document.body;
    if (sel === "html") sel = document.documentElement;
    if (sel === "doctype") sel = document.doctype;
    if (sel && (sel.nodeType || sel.self === window)) {
      this.push(sel);
      return this;
    }
    if (isArrayLike(sel)) {
      $2.each(sel, function() {
        $2(this).each(function() {
          that.push(this);
        });
      });
      return this;
    }
    if (typeof sel !== "string" && (sel.self && sel.self !== window)) {
      return this;
    }
    if (sel === "#" || sel === ".") {
      console.error("Selector can't be # or .");
      return this;
    }
    if (sel[0] === "@") {
      $2("[data-role]").each(function() {
        const roles = str2arr($2(this).attr("data-role"), ",");
        if (roles.indexOf(sel.slice(1)) > -1) {
          that.push(this);
        }
      });
    } else {
      parsed = $2.parseHTML(sel);
      if (parsed.length === 1 && parsed[0].nodeType === 3) {
        try {
          [].push.apply(this, document.querySelectorAll(sel));
        } catch (e2) {
        }
      } else {
        $2.merge(this, parsed);
      }
    }
    if (ctx !== void 0) {
      if (ctx instanceof $2) {
        this.each(function() {
          $2(ctx).append(that);
        });
      } else if (ctx instanceof HTMLElement) {
        $2(ctx).append(that);
      } else {
        if (isPlainObject(ctx)) {
          $2.each(this, function() {
            for (const name2 in ctx) {
              if (hasProp(ctx, name2))
                this.setAttribute(name2, ctx[name2]);
            }
          });
        }
      }
    }
    return this;
  };
  $2.init.prototype = $2.fn;

  // source/dom/index.js
  globalThis.$ = $2;
  globalThis.Dom = $2;

  // node_modules/@olton/hooks/dist/hooks.js
  var hooks_exports = {};
  __export(hooks_exports, {
    EVENTS: () => EVENTS,
    info: () => info2,
    useClickOutside: () => useClickOutside,
    useCompose: () => useCompose,
    useCookie: () => useCookie,
    useCurry: () => useCurry,
    useDebounce: () => useDebounce,
    useEvent: () => useEvent,
    useId: () => useId,
    useInterval: () => useInterval,
    useMediaQuery: () => useMediaQuery,
    useMemo: () => useMemo,
    usePipe: () => usePipe,
    useQueue: () => useQueue,
    useState: () => useState,
    useThrottle: () => useThrottle,
    useToggle: () => useToggle
  });
  function useClickOutside(element2, callback) {
    if (!element2) return { attach: () => {
    }, detach: () => {
    } };
    const handleClick = (e2) => {
      if (!element2.contains(e2.target)) {
        callback();
      }
    };
    const attach = () => document.addEventListener("click", handleClick);
    const detach = () => document.removeEventListener("click", handleClick);
    return { attach, detach };
  }
  function useCompose(...functions) {
    if (!functions.every((fn) => typeof fn === "function")) {
      throw new Error("useCompose: \u0432\u0441\u0435 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u044B \u0434\u043E\u043B\u0436\u043D\u044B \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u044F\u043C\u0438");
    }
    switch (functions.length) {
      case 0:
        return (x4) => x4;
      case 1:
        return functions[0];
      case 2: {
        const [f5, g4] = functions;
        return (...args) => f5(g4(...args));
      }
      default:
        return function composed(...args) {
          let result = functions[functions.length - 1](...args);
          for (let i3 = functions.length - 2; i3 >= 0; i3--) {
            result = functions[i3](result);
          }
          return result;
        };
    }
  }
  function useCookie(name2) {
    function getCookie() {
      const matches2 = document.cookie.match(
        new RegExp(`(?:^|; )${name2.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1")}=([^;]*)`)
      );
      return matches2 ? decodeURIComponent(matches2[1]) : null;
    }
    function setCookie(value, options = {}) {
      options = { path: "/", ...options };
      document.cookie = `${name2}=${encodeURIComponent(value)}; ${Object.keys(options).map((key) => `${key}=${options[key]}`).join("; ")}`;
    }
    function deleteCookie() {
      setCookie("", { "max-age": -1 });
    }
    return { get: getCookie, set: setCookie, delete: deleteCookie };
  }
  function useCurry(func) {
    if (typeof func !== "function") {
      throw new Error("useCurry: \u043F\u0435\u0440\u0432\u044B\u0439 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442 \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u0435\u0439");
    }
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      }
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      };
    };
  }
  function useDebounce(fn, wait, options = {}) {
    if (typeof fn !== "function") {
      throw new Error("useDebounce: \u043F\u0435\u0440\u0432\u044B\u0439 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442 \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u0435\u0439");
    }
    if (wait < 0) {
      throw new Error("useDebounce: \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043F\u043E\u043B\u043E\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u043C \u0447\u0438\u0441\u043B\u043E\u043C");
    }
    let timer = null;
    let result;
    function debounced(...args) {
      const context = this;
      const callNow = options.immediate && !timer;
      if (timer !== null) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        timer = null;
        if (!options.immediate) {
          result = fn.apply(context, args);
        }
      }, wait);
      if (callNow) {
        result = fn.apply(context, args);
      }
      return result;
    }
    debounced.cancel = function() {
      if (timer !== null) {
        clearTimeout(timer);
        timer = null;
      }
    };
    return debounced;
  }
  var EVENTS = /* @__PURE__ */ ((EVENTS2) => {
    EVENTS2["LOAD"] = "load";
    EVENTS2["VIEWPORT"] = "viewport";
    EVENTS2["ATTRIBUTE"] = "attribute";
    EVENTS2["CHILDREN"] = "children";
    EVENTS2["DATA"] = "data";
    return EVENTS2;
  })(EVENTS || {});
  var useEvent = ({ event, root, target, effect }) => {
    const _target = typeof target === "string" ? document.querySelector(target) : target;
    if (typeof effect !== "function") {
      throw Error("Side effect must be a function!");
    }
    if (!_target) {
      throw Error("Please specify a target element!");
    }
    switch (event) {
      case "load": {
        const observer = new MutationObserver((mutations, observer2) => {
          const el = document.querySelector(target);
          if (el !== null) {
            effect(el);
            observer2.disconnect();
          }
        });
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
        break;
      }
      case "viewport": {
        const _root = root instanceof HTMLElement ? root : typeof root === "string" ? document.querySelector(root) : null;
        const observerOptions = {
          root: _root,
          rootMargin: "0px",
          threshold: 0.5
        };
        const observer = new IntersectionObserver((entries, observer2) => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              effect(_target);
            }
          }
        }, observerOptions);
        observer.observe(_target);
        break;
      }
      case "attribute": {
        const observer = new MutationObserver((mutations) => {
          for (const mut of mutations) {
            if (mut.target === _target && mut.type === "attributes") {
              effect(_target, mut.attributeName, _target.getAttribute(mut.attributeName));
            }
          }
        });
        observer.observe(_target, {
          attributes: true
        });
        break;
      }
      case "children": {
        const observer = new MutationObserver((mutations) => {
          for (const mut of mutations) {
            if (mut.target === _target && mut.type === "childList") {
              effect(_target, mut.addedNodes, mut.removedNodes);
            }
          }
        });
        observer.observe(_target, {
          childList: true,
          subtree: true
        });
        break;
      }
      case "data": {
        const observer = new MutationObserver((mutations) => {
          for (const mut of mutations) {
            if (mut.target === _target && mut.type === "characterData") {
              effect(_target, _target.textContent);
            }
          }
        });
        observer.observe(_target, {
          characterData: true
        });
        break;
      }
      default: {
        if (_target instanceof HTMLElement) {
          _target.addEventListener(event, (e2) => {
            effect(_target, e2);
          });
        }
      }
    }
  };
  var idStore = /* @__PURE__ */ new Map();
  var idCounter = 0;
  function normalizeKeyForId(keyStr) {
    return keyStr.replace(/[^a-zA-Z0-9_-]/g, "_");
  }
  function useId(key, options = {}) {
    const actualKey = key ?? Symbol("id-key");
    const { divider = "-", prefix = "id", forceNew = false } = options;
    if (!forceNew && idStore.has(actualKey)) {
      return idStore.get(actualKey);
    }
    const isClient = typeof document !== "undefined";
    const maxAttempts = 1e3;
    let attempts = 0;
    const generateId = () => {
      let keyType;
      if (key instanceof HTMLElement) {
        keyType = key.tagName.toLowerCase();
      } else if (typeof key === "object" && key !== null) {
        keyType = "object";
      } else if (key !== void 0) {
        keyType = normalizeKeyForId(String(key));
      } else {
        keyType = "generic";
      }
      return `${prefix}${divider}${keyType}${divider}${idCounter++}`;
    };
    let id = generateId();
    if (isClient) {
      while (document.getElementById(id)) {
        if (attempts++ > maxAttempts) {
          throw new Error("useId: \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0439 ID \u043F\u043E\u0441\u043B\u0435 \u043C\u043D\u043E\u0433\u043E\u0447\u0438\u0441\u043B\u0435\u043D\u043D\u044B\u0445 \u043F\u043E\u043F\u044B\u0442\u043E\u043A");
        }
        id = generateId();
      }
    }
    idStore.set(actualKey, id);
    return id;
  }
  function useInterval(callback, delay) {
    let timerId = null;
    function start() {
      if (timerId) return;
      timerId = window.setInterval(() => callback(), delay);
    }
    function stop() {
      if (timerId) {
        window.clearInterval(timerId);
        timerId = null;
      }
    }
    return { start, stop };
  }
  function useMediaQuery(query) {
    const mediaQuery = window.matchMedia(query);
    function getMatches() {
      return mediaQuery.matches;
    }
    let matches2 = getMatches();
    function handleChange() {
      matches2 = getMatches();
    }
    mediaQuery.addEventListener("change", handleChange);
    return matches2;
  }
  var useMemo = (fn, options = {}) => {
    const cache = /* @__PURE__ */ new Map();
    const { maxSize } = options;
    const memoized = (...args) => {
      const key = JSON.stringify(args);
      if (cache.has(key)) {
        return cache.get(key);
      }
      const result = fn(...args);
      if (maxSize && cache.size >= maxSize) {
        const firstKey = cache.keys().next().value;
        cache.delete(firstKey);
      }
      cache.set(key, result);
      return result;
    };
    memoized.clearCache = () => {
      cache.clear();
      return true;
    };
    return memoized;
  };
  function usePipe(...functions) {
    if (!functions.every((fn) => typeof fn === "function")) {
      throw new Error("usePipe: \u0432\u0441\u0435 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u044B \u0434\u043E\u043B\u0436\u043D\u044B \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u044F\u043C\u0438");
    }
    switch (functions.length) {
      case 0:
        return (x4) => x4;
      case 1:
        return functions[0];
      case 2: {
        const [f5, g4] = functions;
        return (...args) => g4(f5(...args));
      }
      default:
        return function piped(...args) {
          let result = functions[0](...args);
          for (let i3 = 1; i3 < functions.length; i3++) {
            result = functions[i3](result);
          }
          return result;
        };
    }
  }
  function useQueue() {
    const queue = [];
    return {
      enqueue: (item) => {
        queue.push(item);
        return queue.length;
      },
      dequeue: () => queue.shift(),
      peek: () => queue[0] || null,
      size: () => queue.length,
      isEmpty: () => queue.length === 0,
      clear: () => {
        queue.length = 0;
      }
    };
  }
  var state = [];
  var stateIndex = -1;
  var StateValue = class {
    constructor(index) {
      this.index = index;
    }
    valueOf() {
      return state[this.index].value;
    }
    toString() {
      const value = state[this.index].value;
      return String(value);
    }
    // Чтобы при консоль логе показывалось актуальное значение
    [Symbol.toPrimitive](hint) {
      const value = state[this.index].value;
      if (hint === "number" && typeof value === "number") return value;
      if (hint === "string") return String(value);
      return value;
    }
  };
  var useState = (initialState, onStateChange) => {
    const index = stateIndex++;
    if (!state[index]) {
      state[index] = { value: initialState };
    }
    const stateValue = new StateValue(index);
    const setState = (arg) => {
      const old = state[index].value;
      const newValue = typeof arg === "function" ? arg(old) : arg;
      state[index].value = newValue;
      if (typeof onStateChange === "function") {
        onStateChange(newValue, old);
      }
    };
    return [stateValue, setState];
  };
  function useThrottle(fn, wait, options = {}) {
    if (typeof fn !== "function") {
      throw new Error("useThrottle: \u043F\u0435\u0440\u0432\u044B\u0439 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442 \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u0435\u0439");
    }
    if (wait < 0) {
      throw new Error("useThrottle: \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043F\u043E\u043B\u043E\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u043C \u0447\u0438\u0441\u043B\u043E\u043C");
    }
    let timer = null;
    let lastArgs = null;
    let lastThis = null;
    let result;
    let lastCallTime = null;
    const { leading = true, trailing = true } = options;
    function invokeFunction() {
      result = fn.apply(lastThis, lastArgs);
      lastArgs = lastThis = null;
      lastCallTime = Date.now();
    }
    function throttled(...args) {
      const now = Date.now();
      if (!lastCallTime && !leading) {
        lastCallTime = now;
      }
      const remainingTime = wait - (now - lastCallTime);
      lastArgs = args;
      lastThis = this;
      if (remainingTime <= 0 || remainingTime > wait) {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        invokeFunction();
      } else if (!timer && trailing) {
        timer = setTimeout(() => {
          timer = null;
          if (trailing && lastArgs) {
            invokeFunction();
          }
        }, remainingTime);
      }
      return result;
    }
    throttled.cancel = function() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      lastArgs = lastThis = null;
      lastCallTime = null;
    };
    return throttled;
  }
  function useToggle(initialValue = false) {
    let value = initialValue;
    return {
      get: () => value,
      toggle: () => {
        value = !value;
        return value;
      },
      set: (newValue) => {
        value = newValue;
        return value;
      }
    };
  }
  var version2 = "0.13.0";
  var build_time2 = "07.03.2025, 15:05:04";
  var info2 = () => {
    console.info(`%c Hooks %c v${version2} %c ${build_time2} `, "color: #ffffff; font-weight: bold; background: #5c2c05", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };

  // source/hooks/index.js
  globalThis.Hooks = hooks_exports;

  // node_modules/@olton/farbe/dist/farbe.es.js
  var HSV = class {
    constructor(h3 = 0, s3 = 0, v4 = 0) {
      this.h = h3;
      this.s = s3;
      this.v = v4;
    }
    toString() {
      return "hsv(" + [Math.round(this.h), Math.round(this.s * 100) + "%", Math.round(this.v * 100) + "%"].join(", ") + ")";
    }
  };
  var HSL = class {
    constructor(h3 = 0, s3 = 0, l3 = 0) {
      this.h = h3;
      this.s = ("" + s3).includes("%") ? parseInt(s3) / 100 : s3;
      this.l = ("" + l3).includes("%") ? parseInt(l3) / 100 : l3;
    }
    toString() {
      return "hsl(" + [Math.round(this.h), Math.round(this.s * 100) + "%", Math.round(this.l * 100) + "%"].join(", ") + ")";
    }
  };
  var HSLA = class {
    constructor(h3 = 0, s3 = 0, l3 = 0, a3 = 0) {
      this.h = h3;
      this.s = ("" + s3).includes("%") ? parseInt(s3) / 100 : s3;
      this.l = ("" + l3).includes("%") ? parseInt(l3) / 100 : l3;
      this.a = a3;
    }
    toString() {
      return "hsla(" + [Math.round(this.h), Math.round(this.s * 100) + "%", Math.round(this.l * 100) + "%", parseFloat(this.a).toFixed(2)].join(", ") + ")";
    }
  };
  var RGB = class {
    constructor(r2 = 0, g4 = 0, b4 = 0) {
      this.r = r2;
      this.g = g4;
      this.b = b4;
    }
    toString() {
      return `rgb(${this.r},${this.g},${this.b})`;
    }
  };
  var RGBA = class {
    constructor(r2 = 0, g4 = 0, b4 = 0, a3 = 0) {
      this.r = r2;
      this.g = g4;
      this.b = b4;
      this.a = a3;
    }
    toString() {
      return `rgba(${this.r},${this.g},${this.b},${this.a})`;
    }
  };
  var CMYK = class {
    constructor(c3 = 0, m4 = 0, y3 = 0, k4 = 0) {
      this.c = c3;
      this.m = m4;
      this.y = y3;
      this.k = k4;
    }
    toString() {
      return `cmyk(${this.c},${this.m},${this.y},${this.k})`;
    }
  };
  var StandardColorPalette = {
    aliceBlue: "#f0f8ff",
    antiqueWhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedAlmond: "#ffebcd",
    blue: "#0000ff",
    blueViolet: "#8a2be2",
    brown: "#a52a2a",
    burlyWood: "#deb887",
    cadetBlue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerBlue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkBlue: "#00008b",
    darkCyan: "#008b8b",
    darkGoldenRod: "#b8860b",
    darkGray: "#a9a9a9",
    darkGreen: "#006400",
    darkKhaki: "#bdb76b",
    darkMagenta: "#8b008b",
    darkOliveGreen: "#556b2f",
    darkOrange: "#ff8c00",
    darkOrchid: "#9932cc",
    darkRed: "#8b0000",
    darkSalmon: "#e9967a",
    darkSeaGreen: "#8fbc8f",
    darkSlateBlue: "#483d8b",
    darkSlateGray: "#2f4f4f",
    darkTurquoise: "#00ced1",
    darkViolet: "#9400d3",
    deepPink: "#ff1493",
    deepSkyBlue: "#00bfff",
    dimGray: "#696969",
    dodgerBlue: "#1e90ff",
    fireBrick: "#b22222",
    floralWhite: "#fffaf0",
    forestGreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#DCDCDC",
    ghostWhite: "#F8F8FF",
    gold: "#ffd700",
    goldenRod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenYellow: "#adff2f",
    honeyDew: "#f0fff0",
    hotPink: "#ff69b4",
    indianRed: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderBlush: "#fff0f5",
    lawnGreen: "#7cfc00",
    lemonChiffon: "#fffacd",
    lightBlue: "#add8e6",
    lightCoral: "#f08080",
    lightCyan: "#e0ffff",
    lightGoldenRodYellow: "#fafad2",
    lightGray: "#d3d3d3",
    lightGreen: "#90ee90",
    lightPink: "#ffb6c1",
    lightSalmon: "#ffa07a",
    lightSeaGreen: "#20b2aa",
    lightSkyBlue: "#87cefa",
    lightSlateGray: "#778899",
    lightSteelBlue: "#b0c4de",
    lightYellow: "#ffffe0",
    lime: "#00ff00",
    limeGreen: "#32dc32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumAquaMarine: "#66cdaa",
    mediumBlue: "#0000cd",
    mediumOrchid: "#ba55d3",
    mediumPurple: "#9370db",
    mediumSeaGreen: "#3cb371",
    mediumSlateBlue: "#7b68ee",
    mediumSpringGreen: "#00fa9a",
    mediumTurquoise: "#48d1cc",
    mediumVioletRed: "#c71585",
    midnightBlue: "#191970",
    mintCream: "#f5fffa",
    mistyRose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajoWhite: "#ffdead",
    navy: "#000080",
    oldLace: "#fdd5e6",
    olive: "#808000",
    oliveDrab: "#6b8e23",
    orange: "#ffa500",
    orangeRed: "#ff4500",
    orchid: "#da70d6",
    paleGoldenRod: "#eee8aa",
    paleGreen: "#98fb98",
    paleTurquoise: "#afeeee",
    paleVioletRed: "#db7093",
    papayaWhip: "#ffefd5",
    peachPuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderBlue: "#b0e0e6",
    purple: "#800080",
    rebeccaPurple: "#663399",
    red: "#ff0000",
    rosyBrown: "#bc8f8f",
    royalBlue: "#4169e1",
    saddleBrown: "#8b4513",
    salmon: "#fa8072",
    sandyBrown: "#f4a460",
    seaGreen: "#2e8b57",
    seaShell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    slyBlue: "#87ceeb",
    slateBlue: "#6a5acd",
    slateGray: "#708090",
    snow: "#fffafa",
    springGreen: "#00ff7f",
    steelBlue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whiteSmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowGreen: "#9acd32"
  };
  var MetroColorPalette = {
    lime: "#a4c400",
    green: "#60a917",
    emerald: "#008a00",
    blue: "#00AFF0",
    teal: "#00aba9",
    cyan: "#1ba1e2",
    cobalt: "#0050ef",
    indigo: "#6a00ff",
    violet: "#aa00ff",
    pink: "#dc4fad",
    magenta: "#d80073",
    crimson: "#a20025",
    red: "#CE352C",
    orange: "#fa6800",
    amber: "#f0a30a",
    yellow: "#fff000",
    brown: "#825a2c",
    olive: "#6d8764",
    steel: "#647687",
    mauve: "#76608a",
    taupe: "#87794e"
  };
  var Palette = {
    color: function(name2, palette = StandardColorPalette, undefined_color = void 0) {
      return palette[name2] !== void 0 ? palette[name2] : undefined_color;
    },
    palette: function(palette = StandardColorPalette) {
      return Object.keys(palette);
    },
    colors: function(palette = StandardColorPalette) {
      return Object.values(palette);
    }
  };
  var Primitives$1 = {
    HSV,
    HSL,
    HSLA,
    RGB,
    RGBA,
    CMYK
  };
  var colorTypes = {
    HEX: "hex",
    RGB: "rgb",
    RGBA: "rgba",
    HSV: "hsv",
    HSL: "hsl",
    HSLA: "hsla",
    CMYK: "cmyk",
    UNKNOWN: "unknown"
  };
  var colorDefaultProps = {
    angle: 30,
    algorithm: 1,
    step: 0.1,
    distance: 5,
    tint1: 0.8,
    tint2: 0.4,
    shade1: 0.6,
    shade2: 0.3,
    alpha: 1,
    baseLight: "#ffffff",
    baseDark: "self"
  };
  function convert(source, format) {
    let result;
    switch (format) {
      case "hex":
        result = source.map(function(v4) {
          return toHEX(v4);
        });
        break;
      case "rgb":
        result = source.map(function(v4) {
          return toRGB(v4);
        });
        break;
      case "rgba":
        result = source.map(function(v4) {
          return toRGBA(v4, opt.alpha);
        });
        break;
      case "hsl":
        result = source.map(function(v4) {
          return toHSL(v4);
        });
        break;
      case "hsla":
        result = source.map(function(v4) {
          return toHSLA(v4, opt.alpha);
        });
        break;
      case "cmyk":
        result = source.map(function(v4) {
          return toCMYK(v4);
        });
        break;
      default:
        result = source;
    }
    return result;
  }
  function clamp(num, min, max) {
    return Math.max(min, Math.min(num, max));
  }
  function toRange(a3, b4, c3) {
    return a3 < b4 ? b4 : a3 > c3 ? c3 : a3;
  }
  function shift(h3, s3) {
    h3 += s3;
    while (h3 >= 360) h3 -= 360;
    while (h3 < 0) h3 += 360;
    return h3;
  }
  var test = (color) => {
    const _isHEX = (color2) => /^#([A-Fa-f0-9]{3}){1,2}$/.test(color2);
    const _isRGB = (color2) => /^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(color2);
    const _isRGBA = (color2) => /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)$/.test(color2);
    const _isHSV = (color2) => /^hsv\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(color2);
    const _isHSL = (color2) => /^hsl\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(color2);
    const _isHSLA = (color2) => /^hsla\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)$/.test(color2);
    const _isCMYK = (color2) => /^cmyk\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(color2);
    return _isHEX(color) || _isRGB(color) || _isHSV(color) || _isHSLA(color) || _isHSLA(color) || _isRGBA(color) || _isHSL(color) || _isCMYK(color);
  };
  var createColor = (colorType2 = "hex", from = "#000000") => {
    let baseColor;
    if (typeof from === "string") {
      baseColor = parseColor(from);
    }
    if (!isColor(baseColor)) {
      baseColor = "#000000";
    }
    return toColor(baseColor, colorType2.toLowerCase());
  };
  var create = createColor;
  var expandHexColor = function(hex) {
    if (isColor(hex) && typeof hex !== "string") {
      return hex;
    }
    if (typeof hex !== "string") {
      throw new Error("Value is not a string!");
    }
    if (hex[0] === "#" && hex.length === 4) {
      const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      return "#" + hex.replace(shorthandRegex, (m4, r2, g4, b4) => {
        return r2 + r2 + g4 + g4 + b4 + b4;
      });
    }
    return hex[0] === "#" ? hex : "#" + hex;
  };
  var expand = expandHexColor;
  var isDark = (color) => {
    color = parseColor(color);
    if (!isColor(color)) return;
    const rgb = toRGB(color);
    const YIQ = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    return YIQ < 128;
  };
  var isLight = (color) => {
    return !isDark(color);
  };
  var isHSV = (color) => {
    return parseColor(color) instanceof HSV;
  };
  var isHSL = (color) => {
    return parseColor(color) instanceof HSL;
  };
  var isHSLA = (color) => {
    return parseColor(color) instanceof HSLA;
  };
  var isRGB = (color) => {
    return parseColor(color) instanceof RGB;
  };
  var isRGBA = (color) => {
    return parseColor(color) instanceof RGBA;
  };
  var isCMYK = (color) => {
    return parseColor(color) instanceof CMYK;
  };
  var isHEX = (color) => {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
  };
  var isColor = (color) => {
    if (!color) return false;
    if (typeof color === "string") {
      return test(color);
    }
    return isHEX(color) || isRGB(color) || isRGBA(color) || isHSV(color) || isHSL(color) || isHSLA(color) || isCMYK(color);
  };
  var colorType = (color) => {
    if (isHEX(color)) return colorTypes.HEX;
    if (isRGB(color)) return colorTypes.RGB;
    if (isRGBA(color)) return colorTypes.RGBA;
    if (isHSV(color)) return colorTypes.HSV;
    if (isHSL(color)) return colorTypes.HSL;
    if (isHSLA(color)) return colorTypes.HSLA;
    if (isCMYK(color)) return colorTypes.CMYK;
    return colorTypes.UNKNOWN;
  };
  var equal = (color1, color2) => {
    if (!isColor(color1) || !isColor(color2)) {
      return false;
    }
    return toHEX(color1) === toHEX(color2);
  };
  var colorToString = (color) => {
    return color.toString();
  };
  var hex2rgb = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
      expandHexColor(hex)
    );
    const rgb = [
      parseInt(result[1], 16),
      parseInt(result[2], 16),
      parseInt(result[3], 16)
    ];
    return result ? new RGB(...rgb) : null;
  };
  var rgb2hex = (rgb) => {
    return "#" + ((1 << 24) + (rgb.r << 16) + (rgb.g << 8) + rgb.b).toString(16).slice(1);
  };
  var rgb2hsv = (rgb) => {
    const hsv = new HSV();
    let h3, s3, v4;
    const r2 = rgb.r / 255, g4 = rgb.g / 255, b4 = rgb.b / 255;
    const max = Math.max(r2, g4, b4);
    const min = Math.min(r2, g4, b4);
    const delta = max - min;
    v4 = max;
    if (max === 0) {
      s3 = 0;
    } else {
      s3 = 1 - min / max;
    }
    if (max === min) {
      h3 = 0;
    } else if (max === r2 && g4 >= b4) {
      h3 = 60 * ((g4 - b4) / delta);
    } else if (max === r2 && g4 < b4) {
      h3 = 60 * ((g4 - b4) / delta) + 360;
    } else if (max === g4) {
      h3 = 60 * ((b4 - r2) / delta) + 120;
    } else if (max === b4) {
      h3 = 60 * ((r2 - g4) / delta) + 240;
    } else {
      h3 = 0;
    }
    hsv.h = h3;
    hsv.s = s3;
    hsv.v = v4;
    return hsv;
  };
  var hsv2rgb = (hsv) => {
    let r2, g4, b4;
    const h3 = hsv.h, s3 = hsv.s * 100, v4 = hsv.v * 100;
    const Hi = Math.floor(h3 / 60);
    const Vmin = (100 - s3) * v4 / 100;
    const alpha = (v4 - Vmin) * (h3 % 60 / 60);
    const Vinc = Vmin + alpha;
    const Vdec = v4 - alpha;
    switch (Hi) {
      case 0:
        r2 = v4;
        g4 = Vinc;
        b4 = Vmin;
        break;
      case 1:
        r2 = Vdec;
        g4 = v4;
        b4 = Vmin;
        break;
      case 2:
        r2 = Vmin;
        g4 = v4;
        b4 = Vinc;
        break;
      case 3:
        r2 = Vmin;
        g4 = Vdec;
        b4 = v4;
        break;
      case 4:
        r2 = Vinc;
        g4 = Vmin;
        b4 = v4;
        break;
      case 5:
        r2 = v4;
        g4 = Vmin;
        b4 = Vdec;
        break;
    }
    return new RGB(
      Math.round(r2 * 255 / 100),
      Math.round(g4 * 255 / 100),
      Math.round(b4 * 255 / 100)
    );
  };
  var hsv2hex = (hsv) => {
    return rgb2hex(hsv2rgb(hsv));
  };
  var hex2hsv = (hex) => {
    return rgb2hsv(hex2rgb(hex));
  };
  var rgb2cmyk = (rgb) => {
    const cmyk = new CMYK();
    const r2 = rgb.r / 255;
    const g4 = rgb.g / 255;
    const b4 = rgb.b / 255;
    cmyk.k = Math.min(1 - r2, 1 - g4, 1 - b4);
    cmyk.c = 1 - cmyk.k === 0 ? 0 : (1 - r2 - cmyk.k) / (1 - cmyk.k);
    cmyk.m = 1 - cmyk.k === 0 ? 0 : (1 - g4 - cmyk.k) / (1 - cmyk.k);
    cmyk.y = 1 - cmyk.k === 0 ? 0 : (1 - b4 - cmyk.k) / (1 - cmyk.k);
    cmyk.c = Math.round(cmyk.c * 100);
    cmyk.m = Math.round(cmyk.m * 100);
    cmyk.y = Math.round(cmyk.y * 100);
    cmyk.k = Math.round(cmyk.k * 100);
    return cmyk;
  };
  var cmyk2rgb = (cmyk) => {
    const r2 = Math.floor(255 * (1 - cmyk.c / 100) * (1 - cmyk.k / 100));
    const g4 = Math.ceil(255 * (1 - cmyk.m / 100) * (1 - cmyk.k / 100));
    const b4 = Math.ceil(255 * (1 - cmyk.y / 100) * (1 - cmyk.k / 100));
    return new RGB(r2, g4, b4);
  };
  var hsv2hsl = (hsv) => {
    let h3, s3, l3, d3;
    h3 = parseInt(hsv.h);
    l3 = (2 - hsv.s) * hsv.v;
    s3 = hsv.s * hsv.v;
    if (l3 === 0) {
      s3 = 0;
    } else {
      d3 = l3 <= 1 ? l3 : 2 - l3;
      if (d3 === 0) {
        s3 = 0;
      } else {
        s3 /= d3;
      }
    }
    l3 /= 2;
    if (Number.isNaN(s3)) s3 = 0;
    if (Number.isNaN(l3)) l3 = 0;
    return new HSL(h3, s3, l3);
  };
  var hsl2hsv = (hsl) => {
    let h3, s3, v4, l3;
    h3 = hsl.h;
    l3 = hsl.l * 2;
    s3 = hsl.s * (l3 <= 1 ? l3 : 2 - l3);
    v4 = (l3 + s3) / 2;
    if (l3 + s3 === 0) {
      s3 = 0;
    } else {
      s3 = 2 * s3 / (l3 + s3);
    }
    return new HSV(h3, s3, v4);
  };
  var rgb2websafe = (rgb) => {
    return new RGB(
      Math.round(rgb.r / 51) * 51,
      Math.round(rgb.g / 51) * 51,
      Math.round(rgb.b / 51) * 51
    );
  };
  var rgba2websafe = (rgba) => {
    const rgbWebSafe = rgb2websafe(rgba);
    return new RGBA(rgbWebSafe.r, rgbWebSafe.g, rgbWebSafe.b, rgba.a);
  };
  var hex2websafe = (hex) => {
    return rgb2hex(rgb2websafe(hex2rgb(hex)));
  };
  var hsv2websafe = (hsv) => {
    return rgb2hsv(rgb2websafe(toRGB(hsv)));
  };
  var hsl2websafe = (hsl) => {
    return hsv2hsl(rgb2hsv(rgb2websafe(toRGB(hsl))));
  };
  var cmyk2websafe = (cmyk) => {
    return rgb2cmyk(rgb2websafe(cmyk2rgb(cmyk)));
  };
  var websafe = (color) => {
    if (isHEX(color)) return hex2websafe(color);
    if (isRGB(color)) return rgb2websafe(color);
    if (isRGBA(color)) return rgba2websafe(color);
    if (isHSV(color)) return hsv2websafe(color);
    if (isHSL(color)) return hsl2websafe(color);
    if (isCMYK(color)) return cmyk2websafe(color);
    return color;
  };
  var toColor = (color, mode = "rgb", alpha = 1) => {
    let result;
    switch (mode.toLowerCase()) {
      case "hex":
        result = toHEX(color);
        break;
      case "rgb":
        result = toRGB(color);
        break;
      case "rgba":
        result = toRGBA(color, alpha);
        break;
      case "hsl":
        result = toHSL(color);
        break;
      case "hsla":
        result = toHSLA(color, alpha);
        break;
      case "hsv":
        result = toHSV(color);
        break;
      case "cmyk":
        result = toCMYK(color);
        break;
      default:
        result = color;
    }
    return result;
  };
  var toHEX = (color) => {
    return typeof color === "string" && color[0] === "#" ? expandHexColor(color) : rgb2hex(toRGB(parse(color)));
  };
  var toRGB = (color) => {
    if (isRGB(color)) return color;
    if (isRGBA(color)) return new RGB(color.r, color.g, color.b);
    if (isHSV(color)) return hsv2rgb(color);
    if (isHSL(color)) return hsv2rgb(hsl2hsv(color));
    if (isHSLA(color)) return hsv2rgb(hsl2hsv(color));
    if (isHEX(color)) return hex2rgb(color);
    if (isCMYK(color)) return cmyk2rgb(color);
    throw new Error("Unknown color format!");
  };
  var toRGBA = (color, alpha = 1) => {
    if (isRGBA(color)) {
      if (alpha) {
        color.a = alpha;
      }
      return color;
    }
    const rgb = toRGB(color);
    return new RGBA(rgb.r, rgb.g, rgb.b, typeof color.a !== "undefined" ? color.a : alpha);
  };
  var toHSV = (color) => {
    return rgb2hsv(toRGB(color));
  };
  var toHSL = (color) => {
    return hsv2hsl(rgb2hsv(toRGB(color)));
  };
  var toHSLA = (color, alpha = 1) => {
    if (isHSLA(color)) {
      if (alpha) {
        color.a = alpha;
      }
      return color;
    }
    let hsla = hsv2hsl(rgb2hsv(toRGB(color)));
    hsla.a = typeof color.a !== "undefined" ? color.a : alpha;
    return new HSLA(hsla.h, hsla.s, hsla.l, hsla.a);
  };
  var toCMYK = (color) => {
    return rgb2cmyk(toRGB(color));
  };
  var grayscale = (color) => {
    const rgb = toRGB(color);
    const type = colorType(color).toLowerCase();
    const gray = Math.round(rgb.r * 0.2125 + rgb.g * 0.7154 + rgb.b * 0.0721);
    const mono = new RGB(gray, gray, gray);
    return toColor(mono, type);
  };
  var darken = (color, amount = 10) => {
    return lighten(color, -1 * Math.abs(amount));
  };
  var lighten = (color, amount = 10) => {
    let type, res, ring = amount > 0;
    const calc = function(_color, _amount) {
      let r2, g4, b4;
      const col = _color.slice(1);
      const num = parseInt(col, 16);
      r2 = (num >> 16) + _amount;
      if (r2 > 255) r2 = 255;
      else if (r2 < 0) r2 = 0;
      b4 = (num >> 8 & 255) + _amount;
      if (b4 > 255) b4 = 255;
      else if (b4 < 0) b4 = 0;
      g4 = (num & 255) + _amount;
      if (g4 > 255) g4 = 255;
      else if (g4 < 0) g4 = 0;
      return "#" + (g4 | b4 << 8 | r2 << 16).toString(16);
    };
    type = colorType(color).toLowerCase();
    if (type === colorTypes.RGBA) {
      color.a;
    }
    do {
      res = calc(toHEX(color), amount);
      ring ? amount-- : amount++;
    } while (res.length < 7);
    return toColor(res, type);
  };
  var hueShift = (color, angle, alpha = 1) => {
    const hsv = toHSV(color);
    const type = colorType(color).toLowerCase();
    let h3 = hsv.h;
    h3 += angle;
    while (h3 >= 360) h3 -= 360;
    while (h3 < 0) h3 += 360;
    hsv.h = h3;
    return toColor(hsv, type, alpha);
  };
  var mix = (color1, color2, amount) => {
    amount = amount === 0 ? 0 : amount || 50;
    const rgb = new RGB(0, 0, 0);
    const rgb1 = toRGB(color1);
    const rgb2 = toRGB(color2);
    const p3 = amount / 100;
    rgb.r = Math.round((rgb2.r - rgb1.r) * p3 + rgb1.r);
    rgb.g = Math.round((rgb2.g - rgb1.g) * p3 + rgb1.g);
    rgb.b = Math.round((rgb2.b - rgb1.b) * p3 + rgb1.b);
    return toHEX(rgb);
  };
  var multiply = (color1, color2) => {
    const rgb1 = toRGB(color1);
    const rgb2 = toRGB(color2);
    const rgb = new RGB();
    rgb1.b = Math.floor(rgb1.b * rgb2.b / 255);
    rgb1.g = Math.floor(rgb1.g * rgb2.g / 255);
    rgb1.r = Math.floor(rgb1.r * rgb2.r / 255);
    return toHEX(rgb);
  };
  var shade = (color, amount) => {
    if (!isColor(color)) {
      throw new Error(color + " is not a valid color value!");
    }
    amount /= 100;
    const type = colorType(color).toLowerCase();
    const rgb = toRGB(color);
    const t = amount < 0 ? 0 : 255;
    const p3 = amount < 0 ? amount * -1 : amount;
    let r2, g4, b4, a3;
    r2 = Math.round((t - rgb.r) * p3) + rgb.r;
    g4 = Math.round((t - rgb.g) * p3) + rgb.g;
    b4 = Math.round((t - rgb.b) * p3) + rgb.b;
    if (type === colorTypes.RGBA || type === colorTypes.HSLA) {
      a3 = color.a;
    }
    return toColor(new RGB(r2, g4, b4), type, a3);
  };
  var saturate = (color, amount) => {
    let hsl, type, alpha;
    if (!isColor(color)) {
      throw new Error(color + " is not a valid color value!");
    }
    hsl = toHSL(color);
    hsl.s += amount / 100;
    hsl.s = clamp(0, 1, hsl.s);
    type = colorType(color).toLowerCase();
    if (type === colorTypes.RGBA || type === colorTypes.HSLA) {
      alpha = color.a;
    }
    return toColor(hsl, type, alpha);
  };
  var desaturate = (color, amount) => {
    let hsl, type, alpha;
    if (!isColor(color)) {
      throw new Error(color + " is not a valid color value!");
    }
    hsl = toHSL(color);
    hsl.s -= amount / 100;
    hsl.s = clamp(hsl.s);
    type = colorType(color).toLowerCase();
    if (type === colorTypes.RGBA || type === colorTypes.HSLA) {
      alpha = color.a;
    }
    return toColor(hsl, type, alpha);
  };
  var spin = (color, amount) => {
    let hsl, type, alpha, hue;
    if (!isColor(color)) {
      throw new Error(color + " is not a valid color value!");
    }
    hsl = toHSL(color);
    hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    type = colorType(color).toLowerCase();
    if (type === colorTypes.RGBA || type === colorTypes.HSLA) {
      alpha = color.a;
    }
    return toColor(hsl, type, alpha);
  };
  var brighten = (color, amount) => {
    let rgb, type, alpha;
    if (!isColor(color)) {
      throw new Error(color + " is not a valid color value!");
    }
    rgb = toRGB(color);
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    type = colorType(color).toLowerCase();
    if (type === colorTypes.RGBA || type === colorTypes.HSLA) {
      alpha = color.a;
    }
    return toColor(rgb, type, alpha);
  };
  var add = (val1, val2, returnAs) => {
    const color1 = parse(val1);
    const color2 = parse(val2);
    const c1 = toRGBA(color1, void 0);
    const c22 = toRGBA(color2, void 0);
    const result = new RGBA();
    ("" + returnAs).toLowerCase() || "hex";
    result.r = Math.round((c1.r + c22.r) / 2);
    result.g = Math.round((c1.g + c22.g) / 2);
    result.b = Math.round((c1.b + c22.b) / 2);
    result.a = Math.round((c1.a + c22.a) / 2);
    return toColor(result, returnAs, result.a);
  };
  var createColorScheme = (color, name2, format = colorTypes.HEX, options) => {
    const opt2 = Object.assign({}, colorDefaultProps, options);
    let i3;
    const scheme = [];
    let hsv;
    let rgb, h3, s3, v4;
    hsv = toHSV(color);
    if (isHSV(hsv) === false) {
      console.warn("The value is a not supported color format!");
      return false;
    }
    h3 = hsv.h;
    s3 = hsv.s;
    v4 = hsv.v;
    switch (name2) {
      case "monochromatic":
      case "mono": {
        if (opt2.algorithm === 1) {
          rgb = hsv2rgb(hsv);
          rgb.r = toRange(
            Math.round(rgb.r + (255 - rgb.r) * opt2.tint1),
            0,
            255
          );
          rgb.g = toRange(
            Math.round(rgb.g + (255 - rgb.g) * opt2.tint1),
            0,
            255
          );
          rgb.b = toRange(
            Math.round(rgb.b + (255 - rgb.b) * opt2.tint1),
            0,
            255
          );
          scheme.push(rgb2hsv(rgb));
          rgb = hsv2rgb(hsv);
          rgb.r = toRange(
            Math.round(rgb.r + (255 - rgb.r) * opt2.tint2),
            0,
            255
          );
          rgb.g = toRange(
            Math.round(rgb.g + (255 - rgb.g) * opt2.tint2),
            0,
            255
          );
          rgb.b = toRange(
            Math.round(rgb.b + (255 - rgb.b) * opt2.tint2),
            0,
            255
          );
          scheme.push(rgb2hsv(rgb));
          scheme.push(hsv);
          rgb = hsv2rgb(hsv);
          rgb.r = toRange(Math.round(rgb.r * opt2.shade1), 0, 255);
          rgb.g = toRange(Math.round(rgb.g * opt2.shade1), 0, 255);
          rgb.b = toRange(Math.round(rgb.b * opt2.shade1), 0, 255);
          scheme.push(rgb2hsv(rgb));
          rgb = hsv2rgb(hsv);
          rgb.r = toRange(Math.round(rgb.r * opt2.shade2), 0, 255);
          rgb.g = toRange(Math.round(rgb.g * opt2.shade2), 0, 255);
          rgb.b = toRange(Math.round(rgb.b * opt2.shade2), 0, 255);
          scheme.push(rgb2hsv(rgb));
        } else if (opt2.algorithm === 2) {
          scheme.push(hsv);
          for (i3 = 1; i3 <= opt2.distance; i3++) {
            v4 = clamp(v4 - opt2.step, 0, 1);
            s3 = clamp(s3 - opt2.step, 0, 1);
            scheme.push({ h: h3, s: s3, v: v4 });
          }
        } else if (opt2.algorithm === 3) {
          scheme.push(hsv);
          for (i3 = 1; i3 <= opt2.distance; i3++) {
            v4 = clamp(v4 - opt2.step, 0, 1);
            scheme.push({ h: h3, s: s3, v: v4 });
          }
        } else {
          v4 = clamp(hsv.v + opt2.step * 2, 0, 1);
          scheme.push({ h: h3, s: s3, v: v4 });
          v4 = clamp(hsv.v + opt2.step, 0, 1);
          scheme.push({ h: h3, s: s3, v: v4 });
          scheme.push(hsv);
          s3 = hsv.s;
          v4 = hsv.v;
          v4 = clamp(hsv.v - opt2.step, 0, 1);
          scheme.push({ h: h3, s: s3, v: v4 });
          v4 = clamp(hsv.v - opt2.step * 2, 0, 1);
          scheme.push({ h: h3, s: s3, v: v4 });
        }
        break;
      }
      case "complementary":
      case "complement":
      case "comp": {
        scheme.push(hsv);
        h3 = shift(hsv.h, 180);
        scheme.push(new HSV(h3, s3, v4));
        break;
      }
      case "double-complementary":
      case "double-complement":
      case "double": {
        scheme.push(hsv);
        h3 = shift(h3, 180);
        scheme.push(new HSV(h3, s3, v4));
        h3 = shift(h3, opt2.angle);
        scheme.push(new HSV(h3, s3, v4));
        h3 = shift(h3, 180);
        scheme.push(new HSV(h3, s3, v4));
        break;
      }
      case "analogous":
      case "analog": {
        h3 = shift(h3, opt2.angle);
        scheme.push(new HSV(h3, s3, v4));
        scheme.push(hsv);
        h3 = shift(hsv.h, 0 - opt2.angle);
        scheme.push(new HSV(h3, s3, v4));
        break;
      }
      case "triadic":
      case "triad": {
        scheme.push(hsv);
        for (i3 = 1; i3 < 3; i3++) {
          h3 = shift(h3, 120);
          scheme.push(new HSV(h3, s3, v4));
        }
        break;
      }
      case "tetradic":
      case "tetra": {
        scheme.push(hsv);
        h3 = shift(hsv.h, 180);
        scheme.push(new HSV(h3, s3, v4));
        h3 = shift(hsv.h, -1 * opt2.angle);
        scheme.push(new HSV(h3, s3, v4));
        h3 = shift(h3, 180);
        scheme.push(new HSV(h3, s3, v4));
        break;
      }
      case "square": {
        scheme.push(hsv);
        for (i3 = 1; i3 < 4; i3++) {
          h3 = shift(h3, 90);
          scheme.push(new HSV(h3, s3, v4));
        }
        break;
      }
      case "split-complementary":
      case "split-complement":
      case "split": {
        h3 = shift(h3, 180 - opt2.angle);
        scheme.push(new HSV(h3, s3, v4));
        scheme.push(hsv);
        h3 = shift(hsv.h, 180 + opt2.angle);
        scheme.push(new HSV(h3, s3, v4));
        break;
      }
      case "material": {
        var baseLight = opt2.baseLight;
        var baseDark = opt2.baseDark === "self" || !opt2.baseDark ? multiply(color, color) : opt2.baseDark;
        scheme.push({
          "50": mix(baseLight, color, 10),
          "100": mix(baseLight, color, 30),
          "200": mix(baseLight, color, 50),
          "300": mix(baseLight, color, 70),
          "400": mix(baseLight, color, 85),
          "500": mix(baseLight, color, 100),
          "600": mix(baseDark, color, 92),
          "700": mix(baseDark, color, 83),
          "800": mix(baseDark, color, 74),
          "900": mix(baseDark, color, 65),
          "A100": lighten(saturate(mix(baseDark, color, 15), 80), 65),
          "A200": lighten(saturate(mix(baseDark, color, 15), 80), 55),
          "A400": lighten(saturate(mix(baseLight, color, 100), 55), 10),
          "A700": lighten(saturate(mix(baseDark, color, 83), 65), 10)
        });
        break;
      }
      default:
        console.error("Unknown scheme name");
    }
    return name2 === "material" ? scheme[0] : convert(scheme, format);
  };
  var parseColor = function(color) {
    let _color = ("" + color).toLowerCase();
    if (typeof StandardColorPalette[_color] !== "undefined") {
      _color = StandardColorPalette[_color];
    }
    if (typeof MetroColorPalette[_color] !== "undefined") {
      _color = MetroColorPalette[_color];
    }
    let a3 = _color.replace(/[^\d.,%]/g, "").split(",").map((v4) => isNaN(v4) ? v4 : +v4);
    if (_color[0] === "#") {
      return expandHexColor(_color);
    }
    if (_color.includes("rgba")) {
      return new RGBA(a3[0], a3[1], a3[2], a3[3]);
    }
    if (_color.includes("rgb")) {
      return new RGB(a3[0], a3[1], a3[2]);
    }
    if (_color.includes("cmyk")) {
      return new CMYK(a3[0], a3[1], a3[2], a3[3]);
    }
    if (_color.includes("hsv")) {
      return new HSV(a3[0], a3[1], a3[2]);
    }
    if (_color.includes("hsla")) {
      return new HSLA(a3[0], a3[1], a3[2], a3[3]);
    }
    if (_color.includes("hsl")) {
      return new HSL(a3[0], a3[1], a3[2]);
    }
    return _color;
  };
  var parse = parseColor;
  var randomColor = (colorType2 = "hex", alpha = 1) => {
    const rnd = (min, max) => Math.floor(min + Math.random() * (max + 1 - min));
    let hex, r2, g4, b4;
    r2 = rnd(0, 255);
    g4 = rnd(0, 255);
    b4 = rnd(0, 255);
    hex = "#" + ((1 << 24) + (r2 << 16) + (g4 << 8) + b4).toString(16).slice(1);
    return colorType2 === "hex" ? hex : toColor(hex, colorType2, alpha);
  };
  var random = randomColor;
  var routines = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Primitives: Primitives$1,
    colorTypes,
    colorDefaultProps,
    test,
    createColor,
    create,
    expandHexColor,
    expand,
    isDark,
    isLight,
    isHSV,
    isHSL,
    isHSLA,
    isRGB,
    isRGBA,
    isCMYK,
    isHEX,
    isColor,
    colorType,
    equal,
    colorToString,
    hex2rgb,
    rgb2hex,
    rgb2hsv,
    hsv2rgb,
    hsv2hex,
    hex2hsv,
    rgb2cmyk,
    cmyk2rgb,
    hsv2hsl,
    hsl2hsv,
    rgb2websafe,
    rgba2websafe,
    hex2websafe,
    hsv2websafe,
    hsl2websafe,
    cmyk2websafe,
    websafe,
    toColor,
    toHEX,
    toRGB,
    toRGBA,
    toHSV,
    toHSL,
    toHSLA,
    toCMYK,
    grayscale,
    darken,
    lighten,
    hueShift,
    mix,
    multiply,
    shade,
    saturate,
    desaturate,
    spin,
    brighten,
    add,
    createColorScheme,
    parseColor,
    parse,
    randomColor,
    random
  });
  var Farbe2 = class {
    /**
     * Private method for setting value. Do not use outside
     * @param {*} color
     * @private
     */
    _setValue(color) {
      if (!color) {
        color = "#000000";
      }
      if (typeof color === "string") {
        color = parseColor(color);
      }
      if (color && isColor(color)) {
        this._value = color;
      } else {
        this._value = void 0;
      }
    }
    /**
     * Private method for setting options
     * @param options
     * @private
     */
    _setOptions(options) {
      this._options = Object.assign({}, colorDefaultProps, options);
    }
    /**
     * Constructor
     * @param {*} color. Set color value. Value must one of: hex, RGB, RGBA, HSL, HSLA, HSV, CMYK.
     * @param {Object} options
     */
    constructor(color = "#000000", options = null) {
      this._setValue(color);
      this._setOptions(options);
    }
    /**
     * Getter. Get options
     * @returns {{shade1: number, shade2: number, tint1: number, tint2: number, distance: number, alpha: number, angle: number, step: number, algorithm: number}}
     */
    get options() {
      return this._options;
    }
    /**
     * Setter. Set options. Will override default options
     * @param options
     */
    set options(options) {
      this._setOptions(options);
    }
    /**
     * Getter. Return current color value.
     * @returns {*}
     */
    get value() {
      return this._value ? this._value : void 0;
    }
    /**
     * Setter. Set color value. Value must one of: hex, RGB, RGBA, HSL, HSLA, HSV, CMYK.
     * @param {*} color
     */
    set value(color) {
      this._setValue(color);
    }
    /**
     * Convert current color to RGB
     * @returns {this | undefined}
     */
    toRGB() {
      if (!this._value) {
        return;
      }
      this._value = toRGB(this._value);
      return this;
    }
    /**
     * Getter.  Get color in RGB format
     * @returns {RGB | undefined}
     */
    get rgb() {
      return this._value ? toRGB(this._value) : void 0;
    }
    /**
     * Convert current value to RGBA
     * @param alpha - Alpha chanel value.
     * @returns {this | undefined}
     */
    toRGBA(alpha) {
      if (!this._value) {
        return;
      }
      if (isRGBA(this._value)) {
        if (alpha) {
          this._value = toRGBA(this._value, alpha);
        }
      } else {
        this._value = toRGBA(
          this._value,
          alpha || colorDefaultProps.alpha
        );
      }
      return this;
    }
    /**
     * Getter. Get value in RGBA format. For alpha chanel value used options.alpha
     * @returns {RGBA | undefined}
     */
    get rgba() {
      return this._value ? isRGBA(this._value) ? this._value : toRGBA(this._value, this._options.alpha) : void 0;
    }
    /**
     * Convert current value to HEX
     * @returns {this | undefined}
     */
    toHEX() {
      if (!this._value) {
        return;
      }
      this._value = toHEX(this._value);
      return this;
    }
    /**
     * Getter. Get value as HEX
     * @returns {string | undefined}
     */
    get hex() {
      return this._value ? toHEX(this._value) : void 0;
    }
    /**
     * Convert current value to HSV
     * @returns {this | undefined}
     */
    toHSV() {
      if (!this._value) {
        return;
      }
      this._value = toHSV(this._value);
      return this;
    }
    /**
     * Getter. Get value as HSV
     * @returns {HSV | undefined}
     */
    get hsv() {
      return this._value ? toHSV(this._value) : void 0;
    }
    /**
     * Convert current value to HSL
     * @returns {this | undefined}
     */
    toHSL() {
      if (!this._value) {
        return;
      }
      this._value = toHSL(this._value);
      return this;
    }
    /**
     * Getter. Get value as HSL
     * @returns {HSL | undefined}
     */
    get hsl() {
      return this._value ? toHSL(this._value) : void 0;
    }
    /**
     * Convert current value to HSV
     * @param alpha
     * @returns {this | undefined}
     */
    toHSLA(alpha) {
      if (!this._value) {
        return;
      }
      if (isHSLA(this._value)) {
        if (alpha) {
          this._value = toHSLA(this._value, alpha);
        }
      } else {
        this._value = toHSLA(this._value, alpha);
      }
      return this;
    }
    /**
     * Getter. Get value as HSLA. For alpha used options.alpha
     * @returns {HSLA | undefined}
     */
    get hsla() {
      return this._value ? isHSLA(this._value) ? this._value : toHSLA(this._value, this._options.alpha) : void 0;
    }
    /**
     * Convert current value to CMYK
     * @returns {this | undefined}
     */
    toCMYK() {
      if (!this._value) {
        return;
      }
      this._value = toCMYK(this._value);
      return this;
    }
    /**
     * Getter. Get value as CMYK
     * @returns {CMYK | undefined}
     */
    get cmyk() {
      return this._value ? toCMYK(this._value) : void 0;
    }
    /**
     * Convert color value to websafe value
     * @returns {this | undefined}
     */
    toWebsafe() {
      if (!this._value) {
        return;
      }
      this._value = websafe(this._value);
      return this;
    }
    /**
     * Getter. Get value as websafe.
     * @returns {HSLA | undefined}
     */
    get websafe() {
      return this._value ? websafe(this._value) : void 0;
    }
    /**
     * Get stringify color value
     * @returns {string} This function return string presentation of color. Example: for RGB will return rgb(x, y, z)
     */
    toString() {
      return this._value ? colorToString(this._value) : void 0;
    }
    /**
     * Darken color for requested percent value
     * @param {int} amount - Value must between 0 and 100. Default value is 10
     * @returns {this | undefined}
     */
    darken(amount = 10) {
      if (!this._value) {
        return;
      }
      this._value = darken(this._value, amount);
      return this;
    }
    /**
     * Darken color for requested percent value
     * @param {int} amount - Value must between 0 and 100. Default value is 10
     * @returns {this | undefined}
     */
    lighten(amount = 10) {
      if (!this._value) {
        return;
      }
      this._value = lighten(this._value, amount);
      return this;
    }
    /**
     * Return true, if current color id dark
     * @returns {boolean|undefined}
     */
    isDark() {
      return this._value ? isDark(this._value) : void 0;
    }
    /**
     * Return true, if current color id light
     * @returns {boolean|undefined}
     */
    isLight() {
      return this._value ? isLight(this._value) : void 0;
    }
    /**
     * Change value on wheel with specified angle
     * @param {int} angle - Value between -360 and 360
     */
    hueShift(angle) {
      if (!this._value) {
        return;
      }
      this._value = hueShift(this._value, angle);
      return this;
    }
    /**
     * Convert color value to grayscale value
     * @returns {this | undefined}
     */
    grayscale() {
      if (!this._value || this.type === colorTypes.UNKNOWN) {
        return;
      }
      this._value = grayscale(
        this._value,
        ("" + this.type).toLowerCase()
      );
      return this;
    }
    /**
     * Getter. Get color type
     * @returns {string}
     */
    get type() {
      return colorType(this._value);
    }
    /**
     * Create specified  color scheme for current color value
     * @param {string} name - Scheme name
     * @param {string} format - Format for returned values
     * @param {Object} options - Options for generated schema, will override default options
     * @returns {Array | undefined}
     */
    getScheme(name2, format, options) {
      return this._value ? createColorScheme(this._value, name2, format, options) : void 0;
    }
    /**
     * Check if color is equal to comparison color
     * @param {*} color
     * @returns {boolean}
     */
    equal(color) {
      return equal(this._value, color);
    }
    random(colorType2, alpha) {
      this._value = randomColor(colorType2, alpha);
    }
    channel(ch, val) {
      const currentType = this.type;
      if (["red", "green", "blue"].includes(ch)) {
        this.toRGB();
        this._value[["red", "green", "blue"].indexOf(ch)] = val;
        this["to" + currentType]();
      }
      if (ch === "alpha" && this._value.a) {
        this._value.a = val;
      }
      if (["hue", "saturation", "value"].includes(ch)) {
        this.toHSV();
        this._value[["hue", "saturation", "value"].indexOf(ch)] = val;
        this["to" + currentType]();
      }
      if (["lightness"].includes(ch)) {
        this.toHSL();
        this._value[2] = val;
        this["to" + currentType]();
      }
      if (["cyan", "magenta", "yellow", "black"].includes(ch)) {
        this.toCMYK();
        this._value[["cyan", "magenta", "yellow", "black"].indexOf(ch)] = val;
        this["to" + currentType]();
      }
      return this;
    }
    add(color) {
      this._setValue(add(this._value, color));
    }
    mix(color, amount) {
      this._setValue(mix(this._value, color, amount));
    }
    multiply(color) {
      this._setValue(multiply(this._value, color));
    }
    shade(amount) {
      this._setValue(shade(this._value, amount));
    }
    saturate(amount) {
      this._setValue(saturate(this._value, amount));
    }
    desaturate(amount) {
      this._setValue(desaturate(this._value, amount));
    }
    spin(amount) {
      this._setValue(spin(this._value, amount));
    }
    brighten(amount) {
      this._setValue(brighten(this._value, amount));
    }
  };
  var Primitives = {
    ...Primitives$1
  };
  var version3 = "1.0.4";
  var build_time3 = "11.08.2024, 23:47:03";
  var info3 = () => {
    console.info(`%c Farbe %c v${version3} %c ${build_time3} `, "color: #ffffff; font-weight: bold; background: #ff00ff", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };

  // source/farbe/index.js
  globalThis.Farbe = Farbe2;
  globalThis.farbe = (c3) => new Farbe2(c3);
  globalThis.Farbe.Routines = routines;
  globalThis.Farbe.Palette = Palette;
  globalThis.Farbe.StandardColors = StandardColorPalette;
  globalThis.Farbe.MetroColors = MetroColorPalette;
  globalThis.Farbe.Primitives = Primitives;
  globalThis.Farbe.info = info3;

  // node_modules/@olton/html/dist/html.js
  var wr2 = Object.defineProperty;
  var Tr = (t, o2) => {
    for (var r2 in o2) wr2(t, r2, { get: o2[r2], enumerable: true });
  };
  function oe(t) {
    return t.replace(/([A-Z])/g, function(o2) {
      return "-" + o2.toLowerCase();
    });
  }
  function ae(t = []) {
    return Array.isArray(t) ? t.join(" ") : t.toString();
  }
  var ie = ["opacity", "zIndex", "order", "zoom"];
  function re(t = {}) {
    return typeof t == "string" ? t : Object.keys(t).map((o2) => {
      let r2 = oe(o2), n2 = t[o2];
      return !ie.includes(r2) && !isNaN(n2) && (n2 += "px"), `${r2}: ${n2}`;
    }).join(";");
  }
  var pe = ["accesskey", "autocapitalize", "autofocus", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"];
  var me = (t) => {
    let o2, r2, n2 = [], s3, p3, c3 = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    if (typeof t == "string") {
      if (t = t.trim(), s3 = document.implementation.createHTMLDocument(""), o2 = s3.createElement("base"), o2.href = document.location.href, s3.head.appendChild(o2), p3 = s3.body, r2 = c3.exec(t), r2) return document.createElement(r2[1]);
      p3.innerHTML = t;
      for (let ee2 = 0; ee2 < p3.childNodes.length; ee2++) n2.push(p3.childNodes[ee2]);
      return n2[0];
    }
  };
  var le = ["onauxclick", "onbeforeinput", "onbeforematch", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onformdata", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "onvolumechange", "onwaiting", "onwheel"];
  var m2 = class {
    constructor(o2 = {}) {
      this.options = o2, this.tag = "div";
    }
    selfAttributes() {
      return [];
    }
    get attributes() {
      return this.getAttributes().join(" ");
    }
    getAttributes() {
      let o2 = [], r2 = ["hidden", "disabled", "required", "readonly", "selected", "open", "multiply", "default"], n2 = ["className", "style", "data", "tag", "events"];
      for (let s3 in this.options) if (!n2.includes(s3)) {
        if (r2.includes(s3) && this.options[s3] === true) {
          o2.push(s3);
          continue;
        }
        (this.selfAttributes().includes(s3) && !o2.includes(s3) || pe.includes(s3)) && o2.push(`${s3}="${this.options[s3]}"`);
      }
      return this.classes && o2.push(`class="${this.classes}"`), this.styles && o2.push(`style="${this.styles}"`), this.dataSet && o2.push(this.dataSet), this.aria && o2.push(this.aria), o2;
    }
    draw() {
      return this.template();
    }
    get dataSet() {
      let { data: o2 = {} } = this.options, r2 = [];
      for (let n2 in o2) r2.push(`data-${oe(n2)}="${o2[n2]}"`);
      return r2.join(" ");
    }
    get aria() {
      let { aria: o2 = {} } = this.options, r2 = [];
      for (let n2 in o2) r2.push(`aria-${n2.toLowerCase()}="${o2[n2]}"`);
      return r2.join(" ");
    }
    get events() {
      let { events: o2 = {}, control: r2 = true } = this.options, n2 = [];
      for (let s3 in o2) r2 && !le.includes(s3) && console.info(`Event ${s3} for element ${this.tag} not specified in HTML specification`), n2.push(`${s3.toLowerCase()}="${o2[s3]}"`);
      return n2.join(" ");
    }
    get classes() {
      return ae(this.options.class);
    }
    get styles() {
      return re(this.options.style);
    }
    template() {
      return "";
    }
    toString() {
      return this.draw();
    }
    toElement() {
      return me(this.draw());
    }
  };
  var w2 = (t) => {
    if (Array.isArray(t)) return t.map(w2).join(`
`);
    if (typeof t == "string" || typeof t == "number" || typeof t == "boolean") return t;
    if (t.draw) return t.draw();
    throw new Error("Unknown element! " + t);
  };
  var e = class extends m2 {
    constructor(...o2) {
      let r2 = {}, n2 = [];
      for (let s3 of o2) typeof s3 == "object" && !(s3 instanceof m2) ? r2 = s3 : n2.push(s3);
      super(r2), this.children = n2;
    }
    template(o2) {
      let r2 = this.options.tag ? this.options.tag : this.tag;
      return `
            <${r2} ${this.attributes} ${this.events}>${o2}</${r2}>
        `;
    }
    draw() {
      return this.template(this.children.map(w2).join(""));
    }
  };
  var a2 = class extends m2 {
    constructor(o2 = {}) {
      super(o2), this.options = o2;
    }
    template() {
      return `
            <${this.options.tag ? this.options.tag : this.tag} ${this.attributes} ${this.events}/>
        `;
    }
  };
  var yr2 = (t = [], o2 = document.body, r2 = {}) => {
    let n2, s3, { clear: p3 = true, where: c3 = "beforeend" } = r2;
    s3 = typeof o2 == "string" ? document.querySelector(o2) : o2, s3 instanceof HTMLElement || (s3 = document.body), p3 && (s3.innerHTML = ""), Array.isArray(t) || (t = [t]), n2 = t.map(w2).join(""), s3.insertAdjacentHTML(c3, n2);
  };
  var se = (t = "", o2) => {
    let r2 = document.createElement("style");
    return o2 !== void 0 && r2.setAttribute("media", o2), r2.appendChild(document.createTextNode(t)), document.head.appendChild(r2), r2;
  };
  var ce = (t) => se(t).sheet;
  var fe = (t, o2, r2) => {
    t.insertRule(o2 + "{" + r2 + "}");
  };
  var Ar2 = (t, o2) => {
    if (typeof t == "string") {
      se(t, o2);
      return;
    }
    let r2 = ce(o2);
    for (let n2 in t) fe(r2, n2, re(t[n2]));
  };
  var de = async (t, o2) => {
    let r2 = await fetch(t, o2), n2, s3;
    if (!r2.ok) throw new Error("HTTP error: " + r2.status);
    n2 = await r2.text(), s3 = document.createElement("style"), s3.appendChild(document.createTextNode(n2)), document.body.appendChild(s3);
  };
  var ge = async (t, o2) => {
    let r2 = await fetch(t, o2), n2, s3;
    if (!r2.ok) throw new Error("HTTP error: " + r2.status);
    n2 = await r2.text(), s3 = document.createElement("script"), s3.appendChild(document.createTextNode(n2)), document.body.appendChild(s3);
  };
  var xe = async (t, o2 = {}, r2 = false) => {
    let n2, s3, p3 = () => {
    }, c3;
    if (r2 !== false && (c3 = `html::key::${t}`, s3 = localStorage.getItem(c3)), !s3) {
      if (n2 = await fetch(t, o2), !n2.ok) throw new Error("HTTP error: " + n2.status);
      s3 = await n2.text(), r2 !== false && localStorage.setItem(c3, s3);
    }
    return (0, eval)(`result = ${s3}`), typeof p3 == "function" ? p3() : p3;
  };
  var ue = (t) => localStorage.removeItem(`html::key::${t}`);
  var te = {};
  Tr(te, { Abbr: () => H2, Address: () => I2, Anchor: () => d, Area: () => B2, Article: () => q2, Aside: () => P, AudioTag: () => R2, Base: () => A2, Bdi: () => K2, Bdo: () => O2, Blockquote: () => U2, Body: () => k2, Bold: () => D2, Br: () => E2, Button: () => Z2, Canvas: () => F2, Caption: () => J2, Cite: () => Y2, Code: () => tt2, Col: () => Q2, Colgroup: () => W2, Data: () => Qt2, Dd: () => rt2, Details: () => st2, Dfn: () => at2, Dialog: () => Xt2, Div: () => it2, Dl: () => et2, Dt: () => ot2, Em: () => pt2, Embed: () => lt2, Fieldset: () => ft2, FigCaption: () => xt2, Figure: () => gt2, Footer: () => _2, Form: () => ut2, Frame: () => bt2, Frameset: () => ht2, Head: () => y, Header: () => M3, Heading: () => N2, Hr: () => j2, Html: () => T2, IFrame: () => Tt2, Img: () => $3, Input: () => L2, Ins: () => yt2, Ital: () => x2, Kbd: () => At2, Label: () => vt2, Legend: () => dt2, Link: () => v2, List: () => l, ListItem: () => u2, Main: () => Kt2, Map: () => V2, Mark: () => kt2, Meta: () => Ot2, Nav: () => z2, NoEmbed: () => ct2, NoFrames: () => wt2, NoScript: () => St2, Option: () => Et2, OptionGroup: () => Lt2, Output: () => jt2, Paragraph: () => Nt, Picture: () => Wt2, Pre: () => Ct2, Quoted: () => h, Rp: () => Jt2, Rt: () => Gt2, Ruby: () => Ft2, Script: () => Ht2, Section: () => C2, Select: () => $t2, Slot: () => Yt2, Small: () => qt2, Source: () => zt2, Span: () => S2, Strike: () => b2, Strong: () => mt2, Sub: () => Pt2, Summary: () => nt2, Sup: () => Mt2, Table: () => G3, TableCell: () => g2, TableRow: () => X2, TableSection: () => f2, Template: () => Zt2, Textarea: () => _t2, Time: () => It2, Title: () => Ut2, Track: () => Vt2, Var: () => Bt2, VideoTag: () => Rt2, Wbr: () => Dt2, a: () => Pe, abbr: () => Me, address: () => De, anchor: () => ze, area: () => Oe, article: () => _e, aside: () => Ve, audio: () => Ue, b: () => Ze, base: () => we, bdi: () => Fe, bdo: () => Ge, blockquote: () => Je, body: () => ye, br: () => Se, button: () => Qe, canvas: () => We, caption: () => Ye, cite: () => po, code: () => mo, col: () => to, colgroup: () => eo, data: () => xr2, dd: () => fo, details: () => go, dfn: () => uo, dialog: () => hr2, div: () => ho, dl: () => lo, dt: () => co, em: () => bo, embed: () => Ao, fieldset: () => ko, figcaption: () => Lo, figure: () => $o, footer: () => Re, form: () => Eo, frame: () => No, frameset: () => jo, h1: () => Le, h2: () => Ee, h3: () => je, h4: () => Ne, h5: () => Ce, h6: () => He, head: () => be, header: () => Be, hr: () => $e, html: () => he, i: () => To, iframe: () => Ho, img: () => ve, input: () => ke, ins: () => qo, ital: () => wo, kbd: () => zo, label: () => Po, legend: () => So, li: () => Io, link: () => Te, main: () => pr2, map: () => Ke, mark: () => Vo, meta: () => mr2, nav: () => Ie, noembed: () => vo, noframes: () => Co, noscript: () => Bo, ol: () => _o, optgroup: () => Do, option: () => Ko, output: () => Oo, p: () => Uo, picture: () => ur2, pre: () => Zo, q: () => Fo, quoted: () => Go, rp: () => gr2, rt: () => dr2, ruby: () => fr2, s: () => Qo, script: () => Wo, section: () => qe, select: () => Ro, slot: () => br, small: () => Xo, source: () => Yo, span: () => Ae, strike: () => Jo, strong: () => yo, sub: () => tr2, summary: () => xo, sup: () => er2, table: () => Xe, tbody: () => oo, td: () => io, template: () => cr2, textarea: () => or2, tfoot: () => so, th: () => ao, thead: () => ro, time: () => rr2, title: () => lr2, tr: () => no, track: () => sr2, ul: () => Mo, variable: () => nr2, video: () => ar2, wbr: () => ir2 });
  var T2 = class extends e {
    tag = "html";
    selfAttributes() {
      return ["lang"];
    }
  };
  var he = (...t) => new T2(...t);
  var y = class extends e {
    tag = "head";
  };
  var be = (...t) => new y(...t);
  var A2 = class extends a2 {
    tag = "base";
    selfAttributes() {
      return ["href", "target"];
    }
  };
  var we = (t) => new A2(t);
  var v2 = class extends a2 {
    tag = "link";
    selfAttributes() {
      return ["href", "crossorigin", "rel", "media", "integrity", "hreflang", "type", "referrerpolicy", "sizes", "imagesrcset", "imagesizes", "as", "blocking", "color", "disabled", "fetchpriority"];
    }
  };
  var Te = (t) => new v2(t);
  var k2 = class extends e {
    tag = "body";
  };
  var ye = (...t) => new k2(...t);
  var S2 = class extends e {
    tag = "span";
  };
  var Ae = (...t) => new S2(...t);
  var $3 = class extends a2 {
    tag = "img";
    selfAttributes() {
      return ["align", "alt", "border", "height", "hspace", "ismap", "longdesc", "lowsrc", "src", "vspace", "width", "usemap"];
    }
  };
  var ve = (t = "", o2 = "", r2 = {}) => new $3({ ...r2, src: t, alt: o2 });
  var L2 = class extends a2 {
    tag = "input";
    selfAttributes() {
      return ["accept", "align", "alt", "autocomplete", "autofocus", "border", "checked", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "list", "max", "maxlength", "min", "multiple", "name", "pattern", "placeholder", "size", "src", "step", "type", "value"];
    }
  };
  var ke = (t = {}) => new L2(t);
  var E2 = class extends a2 {
    tag = "br";
    selfAttributes() {
      return ["clear"];
    }
  };
  var Se = (t) => new E2(t);
  var j2 = class extends a2 {
    tag = "hr";
  };
  var $e = (t) => new j2(t);
  var N2 = class extends e {
    constructor(o2 = "h1", ...r2) {
      super(...r2), this.tag = o2;
    }
  };
  var i = (t = "h1", ...o2) => new N2(t, ...o2);
  var Le = (...t) => i("h1", ...t);
  var Ee = (...t) => i("h2", ...t);
  var je = (...t) => i("h3", ...t);
  var Ne = (...t) => i("h4", ...t);
  var Ce = (...t) => i("h5", ...t);
  var He = (...t) => i("h6", ...t);
  var C2 = class extends e {
    tag = "section";
  };
  var qe = (...t) => new C2(...t);
  var d = class extends e {
    tag = "a";
    selfAttributes() {
      return ["coords", "download", "hreflang", "name", "rel", "rev", "shape", "target", "type", "href"];
    }
  };
  var ze = (...t) => new d(...t);
  var Pe = (...t) => new d(...t);
  var H2 = class extends e {
    tag = "abbr";
  };
  var Me = (...t) => new H2(...t);
  var q2 = class extends e {
    tag = "article";
  };
  var _e = (...t) => new q2(...t);
  var z2 = class extends e {
    tag = "nav";
  };
  var Ie = (...t) => new z2(...t);
  var P = class extends e {
    tag = "aside";
  };
  var Ve = (...t) => new P(...t);
  var M3 = class extends e {
    tag = "header";
  };
  var Be = (...t) => new M3(...t);
  var _2 = class extends e {
    tag = "footer";
  };
  var Re = (...t) => new _2(...t);
  var I2 = class extends e {
    tag = "address";
  };
  var De = (...t) => new I2(...t);
  var V2 = class extends e {
    tag = "map";
    selfAttributes() {
      return ["name"];
    }
  };
  var Ke = (...t) => new V2(...t);
  var B2 = class extends a2 {
    tag = "area";
    selfAttributes() {
      return ["alt", "coords", "hreflang", "nohref", "shape", "target", "type", "href"];
    }
  };
  var Oe = (t = {}) => new B2(t);
  var R2 = class extends e {
    tag = "audio";
    selfAttributes() {
      return ["autoplay", "controls", "loop", "preload", "src"];
    }
  };
  var Ue = (...t) => new R2(...t);
  var D2 = class extends e {
    tag = "b";
  };
  var Ze = (...t) => new D2(...t);
  var K2 = class extends e {
    tag = "bdi";
  };
  var Fe = (...t) => new K2(...t);
  var O2 = class extends e {
    tag = "bdo";
  };
  var Ge = (...t) => new O2(...t);
  var U2 = class extends e {
    tag = "blockquote";
    selfAttributes() {
      return ["cite"];
    }
  };
  var Je = (...t) => new U2(...t);
  var Z2 = class extends e {
    tag = "button";
    selfAttributes() {
      return ["autofocus", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "type", "value"];
    }
  };
  var Qe = (...t) => new Z2(...t);
  var F2 = class extends e {
    tag = "canvas";
    selfAttributes() {
      return ["width", "height"];
    }
  };
  var We = (...t) => new F2(...t);
  var G3 = class extends e {
    tag = "table";
    selfAttributes() {
      return ["align", "background", "bgcolor", "border", "bordercolor", "cellpadding", "cellspacing", "cols", "frame", "height", "rules", "summary", "width"];
    }
  };
  var Xe = (...t) => new G3(...t);
  var J2 = class extends e {
    tag = "caption";
    selfAttributes() {
      return ["align", "valign"];
    }
  };
  var Ye = (...t) => new J2(...t);
  var Q2 = class extends a2 {
    tag = "col";
    selfAttributes() {
      return ["align", "valign", "char", "charoff", "span", "width"];
    }
  };
  var to = (t) => new Q2(t);
  var W2 = class extends a2 {
    tag = "colgroup";
    selfAttributes() {
      return ["align", "valign", "char", "charoff", "span", "width"];
    }
  };
  var eo = (t) => new W2(t);
  var f2 = class extends e {
    constructor(o2 = "tbody", ...r2) {
      super(...r2), this.tag = o2;
    }
    selfAttributes() {
      return ["align", "valign", "char", "charoff", "bgcolor"];
    }
  };
  var oo = (...t) => new f2("tbody", ...t);
  var ro = (...t) => new f2("thead", ...t);
  var so = (...t) => new f2("tfoot", ...t);
  var X2 = class extends e {
    tag = "tr";
    selfAttributes() {
      return ["align", "bgcolor", "bordercolor", "char", "charoff", "valign"];
    }
  };
  var no = (...t) => new X2(...t);
  var g2 = class extends e {
    constructor(o2 = "td", ...r2) {
      super(...r2), this.tag = o2;
    }
    selfAttributes() {
      return ["abbr", "align", "axis", "background", "bgcolor", "bordercolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"];
    }
  };
  var ao = (...t) => new g2("th", ...t);
  var io = (...t) => new g2("td", ...t);
  var Y2 = class extends e {
    tag = "cite";
  };
  var po = (...t) => new Y2(...t);
  var tt2 = class extends e {
    tag = "code";
  };
  var mo = (...t) => new tt2(...t);
  var et2 = class extends e {
    tag = "dl";
  };
  var ot2 = class extends e {
    tag = "dt";
  };
  var rt2 = class extends e {
    tag = "dd";
  };
  var lo = (...t) => new et2(...t);
  var co = (...t) => new ot2(...t);
  var fo = (...t) => new rt2(...t);
  var st2 = class extends e {
    tag = "details";
  };
  var go = (...t) => new st2(...t);
  var nt2 = class extends e {
    tag = "summary";
  };
  var xo = (...t) => new nt2(...t);
  var at2 = class extends e {
    tag = "dfn";
  };
  var uo = (...t) => new at2(...t);
  var it2 = class extends e {
    tag = "div";
    selfAttributes() {
      return ["align", "title"];
    }
  };
  var ho = (...t) => new it2(...t);
  var pt2 = class extends e {
    tag = "em";
  };
  var bo = (...t) => new pt2(...t);
  var x2 = class extends e {
    tag = "i";
  };
  var wo = (...t) => new x2(...t);
  var To = (...t) => new x2(...t);
  var mt2 = class extends e {
    tag = "strong";
  };
  var yo = (...t) => new mt2(...t);
  var lt2 = class extends e {
    tag = "embed";
    selfAttributes() {
      return ["align", "height", "hspace", "pluginspace", "src", "type", "vspace", "width"];
    }
  };
  var Ao = (...t) => new lt2(...t);
  var ct2 = class extends e {
    tag = "noembed";
  };
  var vo = (...t) => new ct2(...t);
  var ft2 = class extends e {
    tag = "fieldset";
    selfAttributes() {
      return ["form", "title"];
    }
  };
  var ko = (...t) => new ft2(...t);
  var dt2 = class extends e {
    tag = "legend";
    selfAttributes() {
      return ["align", "title"];
    }
  };
  var So = (...t) => new dt2(...t);
  var gt2 = class extends e {
    tag = "figure";
  };
  var $o = (...t) => new gt2(...t);
  var xt2 = class extends e {
    tag = "figcaption";
  };
  var Lo = (...t) => new xt2(...t);
  var ut2 = class extends e {
    tag = "form";
    selfAttributes() {
      return ["accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"];
    }
  };
  var Eo = (...t) => new ut2(...t);
  var ht2 = class extends e {
    tag = "frameset";
    selfAttributes() {
      return ["border", "bordercolor", "cols", "frameborder", "framespacing", "rows"];
    }
  };
  var jo = (...t) => new ht2(...t);
  var bt2 = class extends a2 {
    tag = "frame";
    selfAttributes() {
      return ["bordercolor", "frameborder", "noresize", "name", "src", "scrolling"];
    }
  };
  var No = (t = {}) => new bt2(t);
  var wt2 = class extends e {
    tag = "noframes";
  };
  var Co = (...t) => new wt2(...t);
  var Tt2 = class extends e {
    tag = "iframe";
    selfAttributes() {
      return ["align", "allowtransparency", "frameborder", "height", "hspace", "marginheight", "marginwidth", "name", "sandbox", "scrolling", "seamless", "src", "srcdoc", "vspace", "width"];
    }
  };
  var Ho = (...t) => new Tt2(...t);
  var yt2 = class extends e {
    tag = "ins";
    selfAttributes() {
      return ["cite", "datetime"];
    }
  };
  var qo = (...t) => new yt2(...t);
  var At2 = class extends e {
    tag = "kbd";
  };
  var zo = (...t) => new At2(...t);
  var vt2 = class extends e {
    tag = "label";
    selfAttributes() {
      return ["for"];
    }
  };
  var Po = (...t) => new vt2(...t);
  var l = class extends e {
    constructor(o2 = "ul", ...r2) {
      super(...r2), this.tag = o2;
    }
    selfAttributes() {
      return this.tag === "ul" ? ["type"] : ["type", "reserved", "start"];
    }
  };
  var u2 = class extends e {
    tag = "li";
    selfAttributes() {
      return ["type", "value"];
    }
  };
  var Mo = (...t) => new l("ul", ...t);
  var _o = (...t) => new l("ol", ...t);
  var Io = (...t) => new u2(...t);
  var kt2 = class extends e {
    tag = "mark";
  };
  var Vo = (...t) => new kt2(...t);
  var St2 = class extends e {
    tag = "noscript";
  };
  var Bo = (...t) => new St2(...t);
  var $t2 = class extends e {
    tag = "select";
    selfAttributes() {
      return ["autofocus", "form", "name", "size"];
    }
  };
  var Ro = (...t) => new $t2(...t);
  var Lt2 = class extends e {
    tag = "optgroup";
    selfAttributes() {
      return ["label"];
    }
  };
  var Do = (...t) => new Lt2(...t);
  var Et2 = class extends e {
    tag = "option";
    selfAttributes() {
      return ["label", "value"];
    }
  };
  var Ko = (...t) => new Et2(...t);
  var jt2 = class extends e {
    tag = "output";
    selfAttributes() {
      return ["for", "form", "name"];
    }
  };
  var Oo = (...t) => new jt2(...t);
  var Nt = class extends e {
    tag = "p";
    selfAttributes() {
      return ["align"];
    }
  };
  var Uo = (...t) => new Nt(...t);
  var Ct2 = class extends e {
    tag = "pre";
  };
  var Zo = (...t) => new Ct2(...t);
  var h = class extends e {
    tag = "q";
    selfAttributes() {
      return ["cite"];
    }
  };
  var Fo = (...t) => new h(...t);
  var Go = (...t) => new h(...t);
  var b2 = class extends e {
    tag = "strike";
  };
  var Jo = (...t) => new b2(...t);
  var Qo = (...t) => new b2(...t);
  var Ht2 = class extends e {
    tag = "script";
    selfAttributes() {
      return ["async", "defer", "language", "src", "type"];
    }
  };
  var Wo = (...t) => new Ht2(...t);
  var qt2 = class extends e {
    tag = "small";
  };
  var Xo = (...t) => new qt2(...t);
  var zt2 = class extends a2 {
    tag = "source";
    selfAttributes() {
      return ["media", "src", "type"];
    }
  };
  var Yo = (t = {}) => new zt2(t);
  var Pt2 = class extends e {
    tag = "sub";
  };
  var tr2 = (...t) => new Pt2(...t);
  var Mt2 = class extends e {
    tag = "sup";
  };
  var er2 = (...t) => new Mt2(...t);
  var _t2 = class extends e {
    tag = "textarea";
    selfAttributes() {
      return ["autofocus", "cols", "form", "maxlength", "name", "placeholder", "rows", "wrap"];
    }
  };
  var or2 = (...t) => new _t2(...t);
  var It2 = class extends e {
    tag = "time";
    selfAttributes() {
      return ["datetime", "pubdate"];
    }
  };
  var rr2 = (...t) => new It2(...t);
  var Vt2 = class extends a2 {
    tag = "track";
    selfAttributes() {
      return ["kind", "src", "srclang", "label"];
    }
  };
  var sr2 = (t = {}) => new Vt2(t);
  var Bt2 = class extends e {
    tag = "var";
  };
  var nr2 = (...t) => new Bt2(...t);
  var Rt2 = class extends e {
    tag = "video";
    selfAttributes() {
      return ["autoplay", "controls", "height", "loop", "loop", "poster", "preload", "src", "width"];
    }
  };
  var ar2 = (...t) => new Rt2(...t);
  var Dt2 = class extends a2 {
    tag = "wbr";
  };
  var ir2 = (t) => new Dt2(t);
  var Kt2 = class extends e {
    tag = "main";
  };
  var pr2 = (...t) => new Kt2(...t);
  var Ot2 = class extends a2 {
    tag = "meta";
    selfAttributes() {
      return ["content", "name", "http-equiv", "charset"];
    }
  };
  var mr2 = (t) => new Ot2(t);
  var Ut2 = class extends e {
    tag = "title";
  };
  var lr2 = (t) => new Ut2(t);
  var Zt2 = class extends e {
    tag = "template";
    selfAttributes() {
      return ["shadowrootmode", "shadowrootdelegatesfocus", "shadowrootclonable", "shadowrootserializable"];
    }
  };
  var cr2 = (...t) => new Zt2(...t);
  var Ft2 = class extends e {
    tag = "ruby";
  };
  var Gt2 = class extends a2 {
    tag = "rt";
  };
  var Jt2 = class extends a2 {
    tag = "rp";
  };
  var fr2 = (...t) => new Ft2(...t);
  var dr2 = (t) => new Gt2(t);
  var gr2 = (t) => new Jt2(t);
  var Qt2 = class extends e {
    tag = "data";
  };
  var xr2 = (...t) => new Qt2(...t);
  var Wt2 = class extends e {
    tag = "picture";
  };
  var ur2 = (...t) => new Wt2(...t);
  var Xt2 = class extends e {
    tag = "dialog";
    selfAttributes() {
      return ["open"];
    }
  };
  var hr2 = (...t) => new Xt2(...t);
  var Yt2 = class extends e {
    tag = "slot";
    selfAttributes() {
      return ["name"];
    }
  };
  var br = (...t) => new Yt2(...t);
  var ne = {};
  var vr2 = "0.14.0";
  var kr = "18.03.2025, 23:11:45";
  var lm = () => {
    console.info(`%c Html.js %c v${vr2} %c ${kr} `, "color: #ffffff; font-weight: bold; background: #708238", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  var Sr2 = (t = globalThis) => {
    for (let o2 in te) globalThis[o2] && (ne[o2] = globalThis[o2]), t[o2] = te[o2];
  };
  var $r = (t = globalThis) => {
    for (let o2 in ne) t[o2] = ne[o2];
  };
  var cm = { ...te, extract: Sr2, restore: $r };

  // source/html/index.js
  globalThis.HTML = {
    addStyle: Ar2,
    addCssRule: fe,
    cssLoader: de,
    jsLoader: ge,
    viewLoader: xe,
    clearViewStorageHolder: ue,
    createStyleElement: se,
    createStyleSheet: ce,
    render: yr2,
    ...cm,
    info: lm
  };

  // node_modules/@olton/guardian/dist/guardian.js
  var guardian_exports = {};
  __export(guardian_exports, {
    americanExpress: () => fe2,
    array: () => pr3,
    base64: () => gr3,
    between: () => ur3,
    bigint: () => j3,
    boolean: () => _r2,
    bytes: () => Ee2,
    color: () => Wr,
    compose: () => I3,
    contains: () => be2,
    creditCard: () => ce2,
    date: () => H3,
    digits: () => _e2,
    diners: () => ie2,
    discover: () => me2,
    domain: () => Tr2,
    email: () => nr3,
    endsWith: () => O3,
    equal: () => Ue2,
    finite: () => Er2,
    float: () => Se2,
    func: () => W3,
    great: () => Ne2,
    greatOrEqual: () => Ce2,
    hexColor: () => Yr,
    hslColor: () => Zr,
    imei: () => br2,
    info: () => qe2,
    integer: () => J3,
    ip: () => Mr,
    ipv4: () => yr3,
    ipv6: () => Nr,
    jcb: () => Ae2,
    length: () => Rr,
    less: () => ve2,
    lessOrEqual: () => Oe2,
    mastercard: () => ae2,
    max: () => tr3,
    maxLength: () => xr3,
    min: () => rr3,
    minLength: () => kr2,
    notNull: () => ge2,
    notNumber: () => hr3,
    number: () => fr3,
    object: () => ir3,
    parse: () => A3,
    pattern: () => he2,
    pipe: () => y2,
    required: () => sr3,
    rgbColor: () => Jr,
    safeInteger: () => Q3,
    safeParse: () => D3,
    similar: () => Me2,
    startsWith: () => C3,
    string: () => i2,
    symbol: () => q3,
    type: () => xe2,
    unionPay: () => ue2,
    unknown: () => B3,
    url: () => Or,
    visa: () => se2
  });
  var x3 = Object.defineProperty;
  var l2 = Object.getOwnPropertySymbols;
  var w3 = Object.prototype.hasOwnProperty;
  var U3 = Object.prototype.propertyIsEnumerable;
  var E3 = (t, r2, e2) => r2 in t ? x3(t, r2, { enumerable: true, configurable: true, writable: true, value: e2 }) : t[r2] = e2;
  var d2 = (t, r2) => {
    for (var e2 in r2 || (r2 = {})) w3.call(r2, e2) && E3(t, e2, r2[e2]);
    if (l2) for (var e2 of l2(r2)) U3.call(r2, e2) && E3(t, e2, r2[e2]);
    return t;
  };
  var o = class extends Error {
    constructor(r2 = "", e2 = null, c3) {
      super(r2), this.message = r2, this.name = e2, this.value = c3;
    }
  };
  var A3 = (t, r2) => {
    let e2;
    if (!t) throw new Error("Schema object required for parse data!");
    if (typeof t == "function") {
      if (e2 = t.apply(null, [r2]), e2 instanceof o) throw e2;
    } else for (let c3 in t) {
      let s3 = r2[c3], a3 = t[c3];
      if (!a3) throw new o(`Guard not defined for field ${c3} in input data!`, "general", r2);
      if (!r2.hasOwnProperty(c3)) throw new o(`Field ${c3} doesn't exists in input data!`, "general", r2);
      if (typeof a3 == "function") {
        if (console.log(a3.name), e2 = a3.apply(null, [s3]), e2 instanceof o) throw e2;
      } else A3(a3, s3);
    }
    return r2;
  };
  var D3 = (t, r2) => {
    let e2;
    if (!t) throw new Error("Schema object required for parse data!");
    if (typeof t == "function") {
      if (e2 = t.apply(null, [r2]), e2 instanceof o) return { ok: false, error: e2 };
    } else for (let c3 in t) {
      let s3 = r2[c3], a3 = t[c3];
      if (a3) if (typeof a3 == "function") {
        if (e2 = a3.apply(null, [r2]), e2 instanceof o) return { ok: false, error: e2 };
      } else A3(a3, s3);
    }
    return { ok: true, output: r2 };
  };
  var M4 = (...t) => (r2) => t.reduce((e2, c3) => c3(e2), r2);
  var y2 = M4;
  var N3 = (...t) => (r2) => t.reduceRight((e2, c3) => c3(e2), r2);
  var I3 = N3;
  var v3 = "VAL must be a string";
  var i2 = (t = v3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" ? r2 : new o(e2, "string", r2);
  };
  var f3 = (t) => typeof t != "undefined" && t !== null;
  var T3 = "VAL must starts with START_VAL";
  var C3 = (t, r2 = T3) => {
    if (!f3(t)) throw new Error("START_VALUE not defined!");
    return function(e2) {
      let c3 = r2.replace(/VAL/g, e2).replace(/START_VAL/g, t);
      return typeof e2 == "string" && e2.startsWith(t) ? e2 : new o(c3, "startsWith", e2);
    };
  };
  var $4 = "VAL must end with END_VAL";
  var O3 = (t, r2 = $4) => {
    if (!f3(t)) throw new Error("END_VALUE not defined!");
    return function(e2) {
      let c3 = r2.replace(/VAL/g, e2).replace(/END_VAL/g, t);
      return typeof e2 == "string" && e2.endsWith(t) ? e2 : new o(c3, "endsWith", e2);
    };
  };
  var B3 = () => function(t) {
    return t;
  };
  var F3 = "A symbol is required";
  var q3 = (t = F3) => function(r2) {
    return typeof r2 == "symbol" ? r2 : new o(t, "symbol", r2);
  };
  var P2 = "VAL must be a bigint";
  var j3 = (t = P2) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "bigint" ? r2 : new o(e2, "bigint", r2);
  };
  var z3 = "VAL must be valid date object or date string";
  var H3 = (t = z3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "object" && r2.getTime || typeof r2 == "string" && !isNaN(Date.parse(r2)) ? r2 : new o(e2, "date", r2);
  };
  var X3 = "The value must be a function";
  var W3 = (t = X3) => function(r2) {
    return typeof r2 == "function" ? r2 : new o(t, "function", r2);
  };
  var Y3 = "VAL must be an integer";
  var J3 = (t = Y3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return Number.isInteger(r2) ? r2 : new o(e2, "integer", r2);
  };
  var Z3 = "VAL must be an safe integer";
  var Q3 = (t = Z3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return Number.isSafeInteger(r2) ? r2 : new o(e2, "safeInteger", r2);
  };
  var K3 = "VAL must be a great then MIN_VALUE";
  var rr3 = (t, r2 = K3) => {
    if (!f3(t)) throw new Error("MIN_VALUE not defined!");
    return function(e2) {
      let c3 = r2.replace(/VAL/g, e2).replace(/MIN_VALUE/g, t), s3 = +e2;
      return !isNaN(s3) && s3 >= +t ? e2 : new o(c3, "minValue", e2);
    };
  };
  var er3 = "VAL must be a less then MAX_VALUE";
  var tr3 = (t, r2 = er3) => {
    if (!f3(t)) throw new Error("MAX_VALUE not defined!");
    return function(e2) {
      let c3 = r2.replace(/VAL/g, e2).replace(/MAX_VALUE/g, t), s3 = +e2;
      return !isNaN(s3) && s3 <= +t ? e2 : new o(c3, "maxValue", e2);
    };
  };
  var or3 = "VAL must be a string in valid email format";
  var nr3 = (t = or3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(r2) ? r2 : new o(e2, "email", r2);
  };
  var cr3 = "Any value required";
  var sr3 = (t = cr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 != "undefined" && r2 !== null && r2 !== "" ? r2 : new o(e2, "required", r2);
  };
  var ar3 = "VAL must be a number";
  var fr3 = (t = ar3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "number" && !isNaN(+r2) ? r2 : new o(e2, "number", r2);
  };
  var mr3 = "VAL must be an object";
  var ir3 = (t, r2 = mr3) => {
    if (!(typeof t == "object")) throw new o(r2.replace(/VAL/g, t), "object", t);
    return d2({}, t);
  };
  var Ar3 = "VAL must be between MIN_VAL and MAX_VAL";
  var ur3 = (t, r2, e2 = Ar3) => {
    if (!f3(t)) throw new Error("MIN_VALUE not defined!");
    if (!f3(r2)) throw new Error("MAX_VALUE not defined!");
    return function(c3) {
      let s3 = e2.replace(/VAL/g, c3).replace(/MIN_VAL/g, t).replace(/MAX_VAL/g, r2), a3 = +c3;
      return !isNaN(a3) && c3 >= +t && c3 <= +r2 ? c3 : new o(s3, "between", c3);
    };
  };
  var lr3 = "VAL must be a finite number";
  var Er2 = (t = lr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return Number.isFinite(r2) ? r2 : new o(e2, "finite", r2);
  };
  var dr3 = "VAL must be a string in valid base 64 format";
  var gr3 = (t = dr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/.test(r2) ? r2 : new o(e2, "base64", r2);
  };
  var Gr = "VAL can`t be a number";
  var hr3 = (t = Gr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return isNaN(r2) ? r2 : new o(e2, "notNumber", r2);
  };
  var Lr = "VAL must be a boolean";
  var _r2 = (t = Lr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "boolean" ? r2 : new o(e2, "boolean", r2);
  };
  var g3 = "VAL must be an array of TYPE";
  var pr3 = (t, r2 = g3) => (!t && !r2 && (t = i2(), r2 = g3), typeof t == "string" && (r2 = t, t = i2()), function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/TYPE/g, t.name);
    if (!Array.isArray(e2)) return new o(c3, "array", e2);
    for (let s3 of e2) if (t(s3) instanceof o) return new o(c3, "array", e2);
    return e2;
  });
  var Sr3 = "VAL must be a valid EMEI";
  var Vr = (t) => {
    let r2 = (s3) => {
      let a3 = 0;
      for (; s3 > 0; ) a3 = a3 + s3 % 10, s3 = parseInt("" + s3 / 10, 10);
      return a3;
    }, e2 = ("" + t).length;
    if (e2 !== 15) return false;
    let c3 = 0;
    for (let s3 = e2; s3 >= 1; s3--) {
      let a3 = t % 10;
      s3 % 2 === 0 && (a3 = 2 * a3), c3 += r2(a3), t = parseInt("" + t / 10, 10);
    }
    return c3 % 10 === 0;
  };
  var br2 = (t = Sr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return Vr(r2) ? r2 : new o(e2, "emei", r2);
  };
  var u3 = "VAL must be a string or array with length N";
  var Rr = (t, r2 = u3) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/N/g, t);
    return (typeof e2 == "string" || Array.isArray(e2)) && e2.length === +t ? e2 : new o(c3, "length", e2);
  };
  var kr2 = (t, r2 = u3) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/N/g, t);
    return (typeof e2 == "string" || Array.isArray(e2)) && e2.length >= +t ? e2 : new o(c3, "minLength", e2);
  };
  var xr3 = (t, r2 = u3) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/N/g, t);
    return (typeof e2 == "string" || Array.isArray(e2)) && e2.length <= +t ? e2 : new o(c3, "maxLength", e2);
  };
  var wr3 = "VAL must be a valid ip address ipv4 or ipv6";
  var Ur = "VAL must be a valid ipv4 address";
  var Dr = "VAL must be a valid ipv6 address";
  var G4 = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  var h2 = /^[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}$/;
  var Mr = (t = wr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && (G4.test(r2) || h2.test(r2)) ? r2 : new o(e2, "ip", r2);
  };
  var yr3 = (t = Ur) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && G4.test(r2) ? r2 : new o(e2, "ipv4", r2);
  };
  var Nr = (t = Dr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && h2.test(r2) ? r2 : new o(e2, "ipv6", r2);
  };
  var Ir = "VAL must be a valid domain name, xn--* for internationalized names";
  var vr3 = /^((xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/;
  var Tr2 = (t = Ir) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && vr3.test(r2) ? r2 : new o(e2, "domain", r2);
  };
  var Cr2 = "VAL must be a valid url";
  var $r2 = /^(?:(?:(?:https?|ftp|wss?):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i;
  var Or = (t = Cr2) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && $r2.test(r2) ? r2 : new o(e2, "url", r2);
  };
  var Br = "VAL must be a valid color in HEX, RGB(A), or HSL(A) format";
  var Fr = "VAL must be a valid HEX color";
  var qr = "VAL must be a valid RGB(a) color";
  var Pr = "VAL must be a valid HSL(A) color";
  var jr = /^#(?:[\da-f]{3}){1,2}$|^#(?:[\da-f]{4}){1,2}$|^(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*)\)$|^(rgb|hsl)a?\((\s*-?\d+%?\s*,){3}\s*(0|(0?\.\d+)|1)\)$/gmi;
  var zr = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
  var Hr = /^rgba?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*)\)$|^rgba?\((\s*-?\d+%?\s*,){3}\s*(0|(0?\.\d+)|1)\)$/gmi;
  var Xr = /^hsla?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*)\)$|^hsla?\((\s*-?\d+%?\s*,){3}\s*(0|(0?\.\d+)|1)\)$/gmi;
  var Wr = (t = Br) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && jr.test(r2) ? r2 : new o(e2, "color", r2);
  };
  var Yr = (t = Fr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && zr.test(r2) ? r2 : new o(e2, "hexColor", r2);
  };
  var Jr = (t = qr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && Hr.test(r2) ? r2 : new o(e2, "rgbColor", r2);
  };
  var Zr = (t = Pr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && Xr.test(r2) ? r2 : new o(e2, "hslColor", r2);
  };
  var L3 = /^4\d{12}(?:\d{3,6})?$/u;
  var _3 = /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u;
  var p = /^3[47]\d{13}$/u;
  var S3 = /^6(?:011|5\d{2})\d{12,15}$/u;
  var V3 = /^3(?:0[0-5]|[68]\d)\d{11,13}$/u;
  var b3 = /^(?:2131|1800|35\d{3})\d{11}$/u;
  var R3 = /^(?:6[27]\d{14,17}|81\d{14,17})$/u;
  var k3 = "VAL must be a valid CC number (visa, mastercard, american express, discover, diners club, jcb, or union pay)";
  var Qr = "VAL must be a valid Visa card number";
  var Kr = "VAL must be a valid Mastercard card number";
  var re2 = "VAL must be a valid American Express card number";
  var ee = "VAL must be a valid DISCOVER card number";
  var te2 = "VAL must be a valid DINERS CLUB card number";
  var oe2 = "VAL must be a valid JCB card number";
  var ne2 = "VAL must be a valid Union Pay card number";
  var ce2 = (t = k3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && (L3.test(r2) || _3.test(r2) || p.test(r2) || S3.test(r2) || V3.test(r2) || b3.test(r2) || R3.test(r2)) ? r2 : new o(e2, "creditCard", r2);
  };
  var m3 = (t, r2, e2 = k3) => function(c3) {
    let s3 = e2.replace(/VAL/g, c3);
    return typeof c3 == "string" && r2.test(c3) ? c3 : new o(s3, t, c3);
  };
  var se2 = (t = Qr) => m3("visa", L3, t);
  var ae2 = (t = Kr) => m3("mastercard", _3, t);
  var fe2 = (t = re2) => m3("american express", p, t);
  var me2 = (t = ee) => m3("discover", S3, t);
  var ie2 = (t = te2) => m3("diners club", V3, t);
  var Ae2 = (t = oe2) => m3("jcb card", b3, t);
  var ue2 = (t = ne2) => m3("union pay", R3, t);
  var le2 = "The length of string must be VAL bytes";
  var Ee2 = (t, r2 = le2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2);
    return typeof e2 == "string" && new TextEncoder().encode(e2).length === t ? e2 : new o(c3, "bytes", e2);
  };
  var de2 = "VAL can`t be null or undefined.";
  var ge2 = (t = de2) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return f3(r2) ? r2 : new o(e2, "notNull", r2);
  };
  var Ge2 = "The value must match the pattern";
  var he2 = (t, r2 = Ge2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2);
    return (typeof t == "string" ? new RegExp(t, "g") : t).test("" + e2) ? e2 : new o(c3, "pattern", e2);
  };
  var Le2 = "VAL must contains only digits";
  var _e2 = (t = Le2) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return /^\d+$/g.test("" + r2) ? r2 : new o(e2, "digits", r2);
  };
  var pe2 = "VAL must be a float";
  var Se2 = (t = pe2) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return !isNaN(r2) && +n % 1 !== 0 || /^\d*\.\d+$/.test(r2) ? r2 : new o(e2, "float", r2);
  };
  var Ve2 = "VAL must must contains OBJ";
  var be2 = (t, r2 = Ve2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/OBJ/g, t);
    return e2.includes(t) ? e2 : new o(c3, "contains", e2);
  };
  var Re2 = "A VAL must have type TYPE";
  function ke2(t) {
    return Object.prototype.toString.call(t).replace(/^\[object (.+)]$/, "$1").toLowerCase();
  }
  var xe2 = (t = "string", r2 = Re2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/TYPE/g, t);
    return t === ke2(e2) ? e2 : new o(c3, "type", e2);
  };
  var we2 = "VAL must be an equal to VALUE";
  var Ue2 = (t, r2 = we2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 === t ? e2 : new o(c3, "equal", e2);
  };
  var De2 = "VAL must be a similar to VALUE";
  var Me2 = (t, r2 = De2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 == t ? e2 : new o(c3, "similar", e2);
  };
  var ye2 = "VAL must be a great then VALUE";
  var Ne2 = (t, r2 = ye2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 > t ? e2 : new o(c3, "great", e2);
  };
  var Ie2 = "VAL must be a less then VALUE";
  var ve2 = (t, r2 = Ie2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 < t ? e2 : new o(c3, "less", e2);
  };
  var Te2 = "VAL must be a great or equal to VALUE";
  var Ce2 = (t, r2 = Te2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 >= t ? e2 : new o(c3, "greatOrEqual", e2);
  };
  var $e2 = "VAL must be a less or equal to VALUE";
  var Oe2 = (t, r2 = $e2) => function(e2) {
    let c3 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 <= t ? e2 : new o(c3, "lessOrEqual", e2);
  };
  var Be2 = "0.7.1";
  var Fe2 = "07.02.2025, 03:04:31";
  var qe2 = () => {
    console.info(`%c Guardian %c v${Be2} %c ${Fe2} `, "color: pink; font-weight: bold; background: #2b1700", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };

  // source/guardian/index.js
  globalThis.G = guardian_exports;

  // node_modules/@olton/router/dist/router.js
  var r = class s2 {
    static DEBUG_LEVELS = { NONE: 0, ERROR: 1, WARN: 2, INFO: 3, DEBUG: 4, TRACE: 5 };
    static DEBUG_LEVEL = s2.DEBUG_LEVELS.NONE;
    static log(e2, t, i3) {
      if (e2 > s2.DEBUG_LEVEL) return;
      let o2 = { error: "color: #ff5555; font-weight: bold", warn: "color: #ffaa00; font-weight: bold", info: "color: #0080fe; font-weight: bold", debug: "color: #00aa00; font-weight: bold", trace: "color: #888888", data: "color: #555; font-style: italic" }, a3, n2;
      switch (e2) {
        case s2.DEBUG_LEVELS.ERROR:
          a3 = "error", n2 = console.error;
          break;
        case s2.DEBUG_LEVELS.WARN:
          a3 = "warn", n2 = console.warn;
          break;
        case s2.DEBUG_LEVELS.INFO:
          a3 = "info", n2 = console.info;
          break;
        case s2.DEBUG_LEVELS.DEBUG:
          a3 = "debug", n2 = console.debug;
          break;
        case s2.DEBUG_LEVELS.TRACE:
          a3 = "trace", n2 = console.log;
          break;
        default:
          return;
      }
      console.group(`%c Model: ${t}`, o2[a3]), i3 !== void 0 && console.log("%c Data:", o2.data, i3), console.groupEnd();
    }
    static error(e2, t) {
      s2.log(s2.DEBUG_LEVELS.ERROR, e2, t);
    }
    static warn(e2, t) {
      s2.log(s2.DEBUG_LEVELS.WARN, e2, t);
    }
    static info(e2, t) {
      s2.log(s2.DEBUG_LEVELS.INFO, e2, t);
    }
    static debug(e2, t) {
      s2.log(s2.DEBUG_LEVELS.DEBUG, e2, t);
    }
    static trace(e2, t) {
      s2.log(s2.DEBUG_LEVELS.TRACE, e2, t);
    }
  };
  var E4 = "0.4.0";
  var w4 = "08.03.2025, 01:01:34";
  var c2 = class {
    constructor(e2 = {}) {
      if (r.DEBUG_LEVEL = e2.debug ? 4 : 0, r.debug("[Router] Init Router"), this.routes = {}, this.fallbackRoute = e2.fallback || "/", this.maxRedirects = e2.maxRedirects || 5, this.redirectCount = 0, this.basePath = e2.base || "", this.middleware = [], this.beforeEachHooks = [], this.afterEachHooks = [], this.cache = /* @__PURE__ */ new Map(), this.cacheLimit = e2.cacheLimit ?? 50, this.touchStartX = 0, this.enableSwipeNavigation = e2.enableSwipeNavigation || false, this.current = null, this.redirects = {}, this.useHash = e2.useHash || false, this.events = { beforeNavigate: [], afterNavigate: [], routeNotFound: [], error: [] }, this.plugins = [], this.enableSwipeNavigation && this.initSwipeNavigation(), e2.routes) {
        r.debug("[Router] Registering routes");
        for (let [t, i3] of Object.entries(e2.routes)) this.addRoute(t, i3);
      }
      e2.plugins && Array.isArray(e2.plugins) && (r.debug("[Router] Registering plugins"), e2.plugins.forEach((t) => {
        Array.isArray(t) ? this.usePlugin(t[0], t[1] || {}) : this.usePlugin(t);
      })), r.debug("[Router] Subscribing to unhandledrejection event"), window.addEventListener("unhandledrejection", this.handleError.bind(this)), r.debug("[Router] Router Initialized");
    }
    on(e2, t) {
      return r.debug(`[Router] Subscribing to event ${e2}`), this.events[e2] && this.events[e2].push(t), this;
    }
    emit(e2, ...t) {
      if (r.debug(`[Router] Emitting event ${e2}`), this.events[e2]) for (let i3 of this.events[e2]) {
        let o2 = i3(...t);
        if (e2 === "beforeNavigate" && o2 === false) return false;
      }
      return true;
    }
    initSwipeNavigation() {
      r.debug("[Router] Initializing swipe navigation"), r.debug("[Router] Adding touchstart event listener"), document.addEventListener("touchstart", (e2) => {
        this.touchStartX = e2.touches[0].clientX;
      }, { passive: true }), r.debug("[Router] Adding touchend event listener"), document.addEventListener("touchend", (e2) => {
        let t = e2.changedTouches[0].clientX, i3 = this.touchStartX - t;
        Math.abs(i3) > 100 && (i3 > 0 ? (r.debug("[Router] Swiping right (forward)"), window.history.forward()) : (r.debug("[Router] Swiping left (backward)"), window.history.back()));
      }, { passive: true });
    }
    handleError(e2) {
      r.error("[Router] Error during navigation:", e2), this.emit("error", e2), this.routes["/error"] ? this.navigateTo("/error", true) : this.navigateTo(this.fallbackRoute, true);
    }
    sanitizePath(e2) {
      r.debug("[Router] Sanitizing path:", e2);
      try {
        if (!e2) return "/";
        let t = new URL(e2, window.location.origin), i3 = decodeURIComponent(t.pathname);
        return i3 = i3.replace(/[<>'"`;(){}]/g, "").replace(/[\u0000-\u001F\u007F-\u009F]/g, "").replace(/([^/])\/{2,}/g, "$1/").replace(/\/+/g, "/").replace(/(.+)\/$/, "$1").replace(/\.+/g, ".").split("/").filter((o2) => o2 !== ".." && o2 !== ".").join("/"), i3.startsWith("/") || (i3 = "/" + i3), this.isBlockedPath(i3) ? "/" : (r.debug("[Router] Sanitized path:", i3), i3);
      } catch (t) {
        return r.error("[Router] Error sanitizing path:", t), "/";
      }
    }
    isBlockedPath(e2) {
      return r.debug("[Router] Checking if path is blocked:", e2), [/^\/(api|admin|wp-admin|wp-content|wp-includes)/i, /\.(php|asp|aspx|jsp|cgi|config|env|git|sql|htaccess)$/i, /\/(.+\/)*\.{2,}\//, /javascript:/i, /data:/i, /vbscript:/i, /file:/i].some((i3) => i3.test(e2));
    }
    test(e2) {
      r.debug("[Router] Testing path:", e2);
      let t = e2, i3 = this.sanitizePath(e2), o2 = { original: t, sanitized: i3, isBlocked: this.isBlockedPath(i3), isModified: t !== i3 };
      return r.debug(`[Router] test result for path ${e2}:`, o2), o2;
    }
    beforeEach(e2) {
      return r.debug("[Router] Adding beforeEach hook"), this.beforeEachHooks.push(e2), this;
    }
    afterEach(e2) {
      return r.debug("[Router] Adding afterEach hook"), this.afterEachHooks.push(e2), this;
    }
    use(e2) {
      return r.debug("[Router] Adding middleware"), this.middleware.push(e2), this;
    }
    addRedirect(e2, t) {
      return r.debug("[Router] Adding redirect from", e2, "to", t), this.redirects[e2] ? false : (this.redirects[e2] = t, this);
    }
    addRoute(e2, t) {
      return r.debug("[Router] Adding route", e2), this.routes[e2] = t, this;
    }
    addNestedRoute(e2, t, i3) {
      r.debug(`[Router] Adding nested route ${t} to ${e2}`);
      let o2 = `${e2}${t}`.replace(/\/\//g, "/");
      return this.addRoute(o2, i3), this;
    }
    addLazyRoute(e2, t) {
      return r.debug("[Router] Adding lazy-loaded route", e2), this.addRoute(e2, async (i3) => {
        try {
          let o2 = await t();
          return (o2.default || o2)(i3);
        } catch (o2) {
          throw o2;
        }
      }), this;
    }
    addLazyNestedRoute(e2, t, i3) {
      r.debug("[Router] Adding lazy-loaded nested route", t, "to", e2);
      let o2 = `${e2}${t}`.replace(/\/\//g, "/");
      return this.addLazyRoute(o2, i3), this;
    }
    addFallbackRoute(e2) {
      return r.debug("[Router] Adding fallback route", e2), this.fallbackRoute = e2, this;
    }
    add404Route(e2) {
      return r.debug("[Router] Adding 404 route", e2), this.routes["/404"] = e2, this;
    }
    addErrorRoute(e2) {
      return r.debug("[Router] Adding error route", e2), this.routes["/error"] = e2, this;
    }
    addProtectedRoute(e2, t, i3, o2 = "/login") {
      return r.debug("[Router] Adding protected route", e2), this.addRoute(e2, async (a3) => {
        if (await i3(a3)) return r.debug("[Router] Guard function passed, executing callback"), t(a3);
        r.debug("[Router] Guard function failed, redirecting to", o2), await this.navigateTo(o2, true);
      }), this;
    }
    removeRoute(e2) {
      return r.debug("[Router] Removing route", e2), this.routes[e2] && delete this.routes[e2], this;
    }
    updateRoute(e2, t) {
      return r.debug("[Router] Updating route", e2), this.routes[e2] && (this.routes[e2] = t), this;
    }
    getRoutes() {
      return r.debug("[Router] Getting registered routes"), this.routes;
    }
    async navigate(e2) {
      if (r.debug("[Router] Navigating to", e2), this.redirectCount > this.maxRedirects) {
        r.error("[Router] Maximum redirect limit reached, redirecting to", this.fallbackRoute), console.error("Maximum redirect limit reached"), this.redirectCount = 0, this.emit("error", new Error("Maximum redirect limit reached")), await this.navigateTo("/error", true);
        return;
      }
      this.redirectCount++;
      let t = this.matchRoute(this.sanitizePath(e2));
      if (t) try {
        if (r.debug("[Router] Route matched:", t), this.emit("beforeNavigate", t) === false) {
          r.debug("[Router] Navigation cancelled by beforeNavigate hook");
          return;
        }
        if (this.redirects[t.path]) {
          r.debug("[Router] Redirecting to", this.redirects[t.path]), await this.navigateTo(this.redirects[t.path], true);
          return;
        }
        this.redirectCount++;
        for (let o2 of this.middleware) r.debug("[Router] Executing middleware"), await o2(t);
        for (let o2 of this.beforeEachHooks) r.debug("[Router] Executing beforeEach hook"), await o2(t);
        r.debug("[Router] Executing route callback"), await t.callback(t.params);
        for (let o2 of this.afterEachHooks) r.debug("[Router] Executing afterEach hook"), await o2(t);
        this.current = t, this.emit("afterNavigate", t), r.debug("[Router] Navigation completed");
      } catch (i3) {
        r.error("[Router] Error during navigation:", i3), console.error("Navigation error:", i3), this.emit("error", i3), this.routes["/error"] && this.routes["/error"](i3);
      }
      else r.warn("[Router] Route not found:", e2), this.redirectCount = 0, this.emit("routeNotFound", e2), this.routes["/404"] && this.routes["/404"]();
    }
    async navigateTo(e2, t = false) {
      r.debug(`[Router] Navigating to ${e2} ${t ? "with replace state" : ""}`), this.redirectCount = 0;
      let i3 = new URL(e2, window.location.origin);
      t ? (r.debug("[Router] Replacing state with", i3), window.history.replaceState({}, "", i3)) : (r.debug("[Router] Pushing state with", i3), window.history.pushState({}, "", i3)), r.debug("[Router] Navigating to", i3), await this.navigate(i3.pathname);
    }
    matchRoute(e2) {
      if (r.debug("[Router] Matching route for", e2), this.cache.has(e2)) return this.cache.get(e2);
      r.debug("[Router] Route not found in cache, performing match");
      let t = this._performMatch(e2);
      if (this.cache.size >= this.cacheLimit) {
        r.debug("[Router] Cache limit reached, removing oldest entry");
        let i3 = this.cache.keys().next().value;
        this.cache.delete(i3);
      }
      return r.debug("[Router] Caching result for", e2), this.cache.set(e2, t), t;
    }
    _performMatch(e2) {
      let [t, i3] = e2.split("?"), o2 = new URLSearchParams(i3), a3 = Object.fromEntries(o2);
      for (let n2 in this.routes) {
        let d3 = [], h3 = n2.replace(/:([^\/]+)/g, (l3, u4) => (d3.push(u4), "([^/]+)")), g4 = e2.match(new RegExp(`^${h3}$`));
        if (g4) {
          let l3 = g4.slice(1).reduce((u4, b4, R4) => (u4[d3[R4]] = b4, u4), {});
          return { path: e2, pattern: h3, callback: this.routes[n2], params: l3, query: a3 };
        }
      }
      return null;
    }
    clearCache() {
      r.debug("[Router] Clearing cache"), this.cache.clear();
    }
    resetRedirectCount() {
      r.debug("[Router] Resetting redirect count"), this.redirectCount = 0;
    }
    getFullPath(e2) {
      return r.debug("[Router] Getting full path for", e2), this.useHash ? `#${e2}` : e2;
    }
    getPathFromLocation() {
      return r.debug("[Router] Getting path from location"), this.useHash ? window.location.hash.slice(1) || "/" : window.location.pathname;
    }
    listen() {
      return r.debug("[Router] Starting to listen for navigation events"), this._handleNavigation = () => {
        this.redirectCount = 0, this.navigate(this.getPathFromLocation()).then((e2) => {
        });
      }, this._handleLinkClick = (e2) => {
        if (e2.target.tagName === "A") {
          let t = e2.target.getAttribute("href");
          if (t && (this.useHash && t.startsWith("#") || !this.useHash && e2.target.href.startsWith(window.location.origin))) {
            e2.preventDefault();
            let i3 = this.useHash ? t.slice(1) : e2.target.pathname;
            this.redirectCount = 0, this.navigateTo(i3).then((o2) => {
            });
          }
        }
      }, r.debug("[Router] Listening for navigation events"), window.addEventListener(this.useHash ? "hashchange" : "popstate", this._handleNavigation), r.debug("[Router] Listening for link clicks"), document.addEventListener("click", this._handleLinkClick), this._initPlugins(), this.redirectCount = 0, this.navigate(this.getPathFromLocation()).then((e2) => {
      }), this;
    }
    _initPlugins() {
      r.debug("[Router] Init plugins"), this.plugins.forEach(({ plugin: e2, options: t }) => {
        typeof e2.onInit == "function" && e2.onInit(this, t);
      });
    }
    usePlugin(e2, t = {}) {
      if (!e2) return this;
      if (r.debug("[Router] Using plugin", e2), typeof e2 == "object" && typeof e2.install == "function") r.debug("[Router] Installing plugin", e2), e2.install(this, t);
      else if (typeof e2 == "function") r.debug("[Router] Executing plugin", e2), e2(this, t);
      else return r.warn("Invalid plugin format. Plugin must be an object with install method or a function."), this;
      return r.debug("[Router] Add plugin to store", e2), this.plugins.push({ plugin: e2, options: t }), r.debug("[Router] Plugin initialized"), this;
    }
    destroy() {
      r.debug("[Router] Destroying router"), this.plugins.forEach(({ plugin: e2, options: t }) => {
        r.debug("[Router] Destroying plugin", e2), typeof e2.onDestroy == "function" && e2.onDestroy(this, t);
      }), r.debug("[Router] Removing event listeners"), window.removeEventListener(this.useHash ? "hashchange" : "popstate", this._handleNavigation), document.removeEventListener("click", this._handleLinkClick), window.removeEventListener("unhandledrejection", this.handleError), this._handleNavigation = null, this._handleLinkClick = null, this.routes = {}, this.plugins = [], this.cache.clear(), r.debug("[Router] Router destroyed");
    }
  };
  c2.info = () => {
    console.info(`%c Router %c v${E4} %c ${w4} `, "color: #ffffff; font-weight: bold; background: #ed1cab", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  var f4 = c2;
  var p2 = f4;

  // source/router/index.js
  globalThis.Router = p2;

  // node_modules/@olton/model/dist/model.js
  var EventEmitter = class {
    /**
     * Initializes a new EventEmitter instance.
     * Creates an empty Map where:
     * - Keys are event names (strings)
     * - Values are Sets of callback functions
     */
    constructor() {
      this.events = /* @__PURE__ */ new Map();
    }
    /**
     * Registers a new event listener for the specified event.
     * - Creates new Set for event if it doesn't exist
     * - Adds callback to the Set of listeners
     * - Returns unsubscribe function for cleanup
     *
     * @param {string} eventName - Event identifier
     * @param {Function} callback - Event handler function
     * @returns {Function} Unsubscribe function
     */
    on(eventName, callback) {
      if (!this.events.has(eventName)) {
        this.events.set(eventName, /* @__PURE__ */ new Set());
      }
      this.events.get(eventName).add(callback);
      return () => this.off(eventName, callback);
    }
    /**
     * Removes a specific event listener.
     * - Safely handles non-existent events
     * - Removes only the specified callback
     * - Keeps other listeners for the same event intact
     *
     * @param {string} eventName - Event to unsubscribe from
     * @param {Function} callback - Listener to remove
     */
    off(eventName, callback) {
      if (this.events.has(eventName)) {
        this.events.get(eventName).delete(callback);
      }
    }
    /**
     * Triggers all listeners for the specified event.
     * - Safely handles non-existent events
     * - Executes each listener in try-catch block
     * - Continues execution even if one listener fails
     * - Logs errors without breaking execution
     *
     * @param {string} eventName - Event to trigger
     * @param {*} [data] - Optional data for listeners
     */
    emit(eventName, data) {
      if (this.events.has(eventName)) {
        this.events.get(eventName).forEach((callback) => {
          try {
            callback(data);
          } catch (e2) {
            console.error(`Error when performing an event handler ${eventName}:`, e2);
          }
        });
      }
    }
  };
  var event_emitter_default = EventEmitter;
  var DevToolsStyle = `
    <style>
        #model-devtools-panel  { 
            position: fixed;
            bottom: 0;
            right: 0;
            width: 300px;
            height: 400px;
            background: #242424;
            color: #fff;
            border: 1px solid #333;
            z-index: 9999;
            font-family: monospace;
            
            *::-webkit-scrollbar {
              width: 10px;
            }
            
            * {
              scrollbar-width: thin;
            }
            
            .devtools-section {
                padding: 8px;
                margin: 4px;
                border: 1px solid #444;
                cursor: pointer;
                hover: background-color: #333;
                font-size: 12px;
            }
            
            h3 {
                margin: 0;
                font-size: 14px;
                border-bottom: 1px solid #333;
                padding-bottom: 4px;
            }
        }
        
        #model-dev-tools-toggle-button {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 9998;
            height: 36px;
            width: 36px;
            background: #444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }        

        #model-devtools-time-travel-dialog {
            position: fixed;
            bottom: 0;
            right: 304px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            height: 400px;
            width: 300px;
            z-index: 10000;
            color: #fff;
            font-family: monospace;
            
            *::-webkit-scrollbar {
              width: 10px;
            }
            
            * {
              scrollbar-width: thin;
            }
            
            .time-travel-items {
                padding: 4px; 
                height: calc(100% - 35px); 
                overflow: auto;
                position: relative;
            }
            
            .time-travel-item {
                padding: 8px;
                margin: 4px;
                border: 1px solid #444;
                cursor: pointer;
                hover: background-color: #333;
                font-size: 12px;
                
                button {
                    margin-top: 8px;
                    background: dodgerblue;
                }
            }
        }
        
        #model-devtools-panel, #model-devtools-time-travel-dialog {
            button {
                height: 20px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                border-radius: 4px;
                border: 1px solid #444;
                background: #333;
                color: #fff;
                cursor: pointer;
                
                @media (hover: hover) {
                    &:hover {
                        background: #444;
                    }
                }

                @media (hover: none) {
                    &:hover {
                        background: #444;
                    }
                }
            }        
        }
        
        .dev-tools-header {
            padding: 8px; 
            border-bottom: 1px solid #333; 
            display: flex; 
            justify-content: space-between;
        }
    </style>
`;
  var dev_tools_style_default = DevToolsStyle;
  var ModelDevTools = class {
    constructor(model, options = {}) {
      this.model = model;
      this.options = {
        enabled: true,
        timeTravel: true,
        maxSnapshots: 50,
        ...options
      };
      this.history = [];
      this.currentIndex = -1;
      this.initializeDevTools();
    }
    /**
     * Initializes the model development tools by:
     * - Creating a global reference at window.__MODEL_DEVTOOLS__
     * - Creating the dev tools panel in the DOM
     * - Setting up model event listeners for debugging
     */
    initializeDevTools() {
      window.__MODEL_DEVTOOLS__ = this;
      this.createDevToolsPanel();
      this.setupModelListeners();
    }
    /**
     * Creates the development tools panel in the DOM with:
     * - A header with title and control buttons
     * - Content area for debugging information
     * - Styling from DevToolsWindowStyle
     * - Close and Time Travel buttons with event handlers
     * - Toggle button for panel visibility
     */
    createDevToolsPanel() {
      const panel = document.createElement("div");
      panel.id = "model-devtools-panel";
      panel.style.cssText = `display: none;`;
      const header = document.createElement("div");
      header.innerHTML = `
            ${dev_tools_style_default}
            <div class="dev-tools-header">
                <span>\u{1F6E0} Model DevTools</span>
                <div>
                    <button id="devtools-time-travel" title="Time Travel">\u23F1</button>
                    <button id="devtools-close" title="Close">\xD7</button>
                </div>
            </div>
        `;
      const content = document.createElement("div");
      content.style.cssText = `
            padding: 8px;
            height: calc(100% - 35px);
            overflow: auto;
        `;
      content.id = "model-devtools-content";
      panel.appendChild(header);
      panel.appendChild(content);
      document.body.appendChild(panel);
      this.createToggleButton();
      document.getElementById("devtools-close").onclick = () => this.togglePanel();
      document.getElementById("devtools-time-travel").onclick = () => this.showTimeTravelDialog();
    }
    /**
     * Displays the Time Travel dialog by:
     * - Creating or reusing existing dialog container
     * - Generating a reversed chronological list of snapshots
     * - Formatting snapshot data (timestamp, type, property, old/new values)
     * - Displaying changes in computed properties and value transitions
     */
    showTimeTravelDialog() {
      let dialog = document.getElementById("model-devtools-time-travel-dialog");
      if (!dialog) {
        dialog = document.createElement("div");
        dialog.id = "model-devtools-time-travel-dialog";
      }
      const statesList = [...this.history].reverse().map((snapshot, index) => `
            <div class="time-travel-item">
                <div>Time: ${new Date(snapshot.timestamp).toLocaleTimeString()}</div>
                <div>Type: ${snapshot.type}</div>
                <div>Property: ${snapshot.property || snapshot.event || snapshot.path || ""}</div>
                <div>Value: ${snapshot.type === "computed-update" ? snapshot.newValue : typeof snapshot.oldValue !== "undefined" && typeof snapshot.newValue !== "undefined" ? `${JSON.stringify(snapshot.oldValue)} -> ${JSON.stringify(snapshot.newValue)}` : JSON.stringify(snapshot.newValue || snapshot.value || "")}</div>
                <button style="display: none" onclick="window.__MODEL_DEVTOOLS__.timeTravel(${this.history.length - 1 - index})">Apply this state</button>
            </div>
        `).join("");
      dialog.innerHTML = `
            <div class="dev-tools-header">
                <span>\u23F1 Time Travel</span>
                <div>
                    <button style="margin-left: auto;" onclick="window.__MODEL_DEVTOOLS__.clearTimeTravel()">CLear</button>
                    <button onclick="this.parentElement.parentElement.parentElement.remove()">\xD7</button>                
                </div>
            </div>
            <div class="time-travel-items">${statesList || "Nothing to show!"}</div>
        `;
      document.body.appendChild(dialog);
    }
    /**
     * Creates a toggle button for the Model DevTools panel.
     * The button is appended to the page and provides
     * functionality to show or hide the dev tools panel.
     */
    createToggleButton() {
      const button = document.createElement("button");
      button.id = "model-dev-tools-toggle-button";
      button.textContent = "\u{1F6E0}";
      button.title = "Model DevTools";
      button.onclick = () => this.togglePanel();
      document.body.appendChild(button);
    }
    /**
     * Sets up listeners for the model and its store to track and log changes,
     * events, computed property updates, and array operations. This enables
     * the Model DevTools to record snapshot history, provide time travel
     * functionality, and update the display with relevant data changes.
     */
    setupModelListeners() {
      this.model.store.on("change", (data) => {
        this.logChange({
          type: "data-change",
          path: data.path,
          oldValue: data.oldValue,
          newValue: data.newValue,
          timestamp: Date.now()
        });
      });
      this.model.store.on("*", (eventName, data) => {
        if (eventName !== "change" && eventName !== "compute" && eventName !== "arrayChange") {
          this.logChange({
            type: "store-event",
            event: eventName,
            data,
            timestamp: Date.now()
          });
        }
      });
      this.model.on("*", (eventName, data) => {
        if (eventName !== "change" && eventName !== "compute") {
          this.logChange({
            type: "model-event",
            event: eventName,
            data,
            timestamp: Date.now()
          });
        }
      });
      this.model.store.on("compute", (data) => {
        this.logChange({
          type: "computed-update",
          property: data.key,
          dependencies: Array.from(data.dependencies),
          newValue: data.value,
          timestamp: Date.now()
        });
      });
      this.model.store.on("arrayChange", (data) => {
        this.logChange({
          type: "array-operation",
          path: data.path,
          method: data.method,
          args: data.args,
          oldValue: data.oldValue,
          newValue: data.newValue,
          timestamp: Date.now()
        });
      });
    }
    /**
     * Logs a change entry and updates the Model DevTools display if enabled.
     *
     * - If the `timeTravel` option is enabled, the method saves a snapshot of the current state.
     * - Updates the DevTools display to reflect the new changes.
     *
     * @param {Object} entry - The change entry to log.
     * @param {string} entry.type - The type of change (for example, 'data-change', 'model-event', etc.).
     * @param {string} [entry.path] - Path of the property being changed (if applicable).
     * @param {any} [entry.oldValue] - The previous value of the changed property (if applicable).
     * @param {any} [entry.newValue] - The new value of the changed property (if applicable).
     * @param {string} [entry.event] - The event name associated with the change (if applicable).
     * @param {number} entry.timestamp - A timestamp indicating when the change occurred.
     */
    logChange(entry) {
      if (!this.options.enabled) return;
      if (this.options.timeTravel) {
        this.saveSnapshot(entry);
      }
      this.updateDisplay();
    }
    /**
     * Saves a snapshot of the current model state, including computed properties and relevant metadata.
     *
     * - Trims the history to ensure the size does not exceed `maxSnapshots`.
     * - Updates the snapshot history and current snapshot index.
     *
     * @param {Object} entry - The change entry that triggered the snapshot.
     * @param {string} entry.type - The type of change (for example, 'data-change', 'model-event', etc.).
     * @param {string} [entry.path] - Path of the property being changed (if applicable).
     * @param {any} [entry.oldValue] - The previous value before the change (if applicable).
     * @param {any} [entry.newValue] - The new value after the change (if applicable).
     * @param {number} entry.timestamp - A timestamp indicating when the change occurred.
     */
    saveSnapshot(entry) {
      const snapshot = {
        ...entry,
        state: JSON.parse(JSON.stringify(this.model.data)),
        computed: this.getComputedValues()
      };
      this.history = this.history.slice(0, this.currentIndex + 1);
      this.history.push(snapshot);
      this.currentIndex++;
      if (this.history.length > this.options.maxSnapshots) {
        this.history.shift();
        this.currentIndex--;
      }
    }
    /**
     * Updates the display of the Model DevTools.
     *
     * - Retrieves and formats the current state, computed values, DOM dependencies, and
     *   recent changes in the model.
     * - Creates and dynamically sets the innerHTML content of the Model DevTools panel.
     * - Triggers the time travel dialog if the corresponding element is present.
     *
     * This method ensures that the visual representation of the model remains up-to-date
     * for debugging and monitoring purposes.
     */
    updateDisplay() {
      const content = document.getElementById("model-devtools-content");
      if (!content) return;
      const formatValue = (value) => {
        if (value === void 0) return "undefined";
        if (value === null) return "null";
        try {
          if (Array.isArray(value)) {
            return `Array(${value.length}) ${JSON.stringify(value, null, 2)}`;
          }
          return JSON.stringify(value, null, 2);
        } catch (e2) {
          return String(value);
        }
      };
      const recentChanges = this.getRecentChanges();
      let changes = ``;
      for (const change of recentChanges) {
        let changeContent;
        try {
          const formattedChange = {
            ...change,
            timestamp: new Date(change.timestamp).toLocaleTimeString()
          };
          changeContent = JSON.stringify(formattedChange, null, 2);
        } catch (e2) {
          changeContent = `Error formatting change: ${e2.message}`;
        }
        changes += `
            <div style="border-bottom: 1px solid #444; padding-bottom: 8px; overflow-x: auto">
                <pre>${changeContent}</pre>
            </div>
`;
      }
      const computedValues = this.getComputedValues();
      content.innerHTML = `
        <div class="devtools-section">
            <h3>Current State:</h3>
            <pre>${formatValue(this.model.data)}</pre>
        </div>
        <div class="devtools-section">
            <h3>Computed Values:</h3>
            <pre>${formatValue(computedValues)}</pre>
        </div>
        <div class="devtools-section">
            <h3>DOM Dependencies:</h3>
            <pre>${this.formatDOMDependencies()}</pre>
        </div>
        <div class="devtools-section">
            <h3>Recent Changes:</h3>
            ${changes}
        </div>
    `;
      const timeTravelDialog = document.getElementById("model-devtools-time-travel-dialog");
      if (timeTravelDialog) {
        this.showTimeTravelDialog();
      }
    }
    /**
     * Formats and returns a structured representation of model's DOM dependencies.
     *
     * - Loops through the DOM dependencies managed in the model.
     * - Converts the `Map` structure into a plain object for easier inspection.
     * - Each dependency entry includes the type of dependency and the tag name of the associated element.
     *
     * @returns {string} A JSON string representing the formatted DOM dependencies.
     */
    formatDOMDependencies() {
      try {
        const dependencies = {};
        this.model.dom.domDependencies.forEach((value, key) => {
          dependencies[key] = Array.from(value).map((dep) => ({
            type: dep.type,
            element: dep.element.tagName
          }));
        });
        return JSON.stringify(dependencies, null, 2);
      } catch (e2) {
        return `Error formatting DOM dependencies: ${e2.message}`;
      }
    }
    /**
     * Retrieves computed values from the model and returns them in a structured format.
     *
     * - If the model's `computed.all` function is available, all computed values are fetched at once.
     * - If the model has a list of computed keys, their values are retrieved individually.
     * - Falls back to iterating over model data keys and extracting computed values if present.
     *
     * @returns {Object} An object containing the computed values from the model.
     */
    getComputedValues() {
      if (!this.model.computed) return {};
      if (typeof this.model.computed.all === "function") {
        return this.model.computed.all();
      }
      if (this.model.computed.keys && Array.isArray(this.model.computed.keys)) {
        const result = {};
        for (const key of this.model.computed.keys) {
          result[key] = this.model.computed.getValue(key);
        }
        return result;
      }
      const computedValues = {};
      for (const key in this.model.data) {
        if (this.model.computed && typeof this.model.computed[key] !== "undefined") {
          computedValues[key] = this.model.data[key];
        }
      }
      return computedValues;
    }
    /**
     * Retrieves the most recent changes from the history.
     *
     * - This method fetches the last 5 changes from the `history` array.
     * - The returned changes are reversed to display the most recent change first.
     *
     * @returns {Array} An array of recent changes from the history.
     */
    getRecentChanges() {
      return this.history.slice(-5).reverse();
    }
    /**
     * Toggles the visibility of the development tools panel.
     *
     * - If the panel is currently hidden (`display: none`), it will be made visible.
     * - If the panel is currently visible, it will be hidden.
     */
    togglePanel() {
      const panel = document.getElementById("model-devtools-panel");
      if (panel) {
        panel.style.display = panel.style.display === "none" ? "block" : "none";
      }
      if (panel.style.display === "none") {
        document.getElementById("model-devtools-time-travel-dialog").remove();
      }
    }
    /**
     * Retrieves the data stored at the specified path in the model's store.
     *
     * - The `path` parameter is used to access specific data within the store.
     * - The method returns the value found at the given path.
     *
     * @param {string} path - The dot-notated path to retrieve the value from the store.
     * @returns {*} The data stored at the specified path.
     */
    inspect(path) {
      return this.model.store.get(path);
    }
    /**
     * Toggles the visibility of the development tools panel in the UI.
     *
     * - The method checks the current display state of the panel element.
     * - If the panel is hidden (`display: none`), it becomes visible (`block`).
     * - If the panel is visible, it gets hidden.
     *
     * @example
     * // Assuming an element with ID 'model-devtools-panel' exists:
     * devTools.togglePanel();
     *
     * // This will toggle the panel's visibility between shown and hidden.
     */
    timeTravel(index) {
      if (!this.options.timeTravel || true) return;
      if (index < 0 || index >= this.history.length) return;
      const snapshot = this.history[index];
      try {
        const origEnabled = this.options.enabled;
        this.options.enabled = false;
        this.model.store.setState(snapshot.state);
        if (this.model.computed) {
          if (typeof this.model.computed.recomputeAll === "function") {
            this.model.computed.recomputeAll();
          } else {
            for (const key in snapshot.computed) {
              if (typeof this.model.computed.evaluate === "function") {
                this.model.computed.evaluate(key, true);
              } else if (typeof this.model.computed.recompute === "function") {
                this.model.computed.recompute(key);
              }
            }
          }
        }
        this.model.dom.updateAllDOM();
        this.currentIndex = index;
        this.options.enabled = origEnabled;
      } catch (e2) {
        console.error("Error during time travel:", e2);
      }
    }
    clearTimeTravel() {
      this.history = [];
      this.currentIndex = -1;
      this.showTimeTravelDialog();
    }
    /**
     * Starts performance monitoring for the model's store.
     *
     * - Sets up initial metrics counters for updates, computations, and DOM updates.
     * - Begins tracking the performance of the model store.
     * - Records changes and computations triggered on the store.
     *
     * @example
     * const devTools = new ModelDevTools(model);
     * devTools.startPerfMonitoring();
     *
     * // After some operations on the model:
     * console.log(devTools.getPerfReport());
     * // Outputs the performance metrics report.
     */
    startPerfMonitoring() {
      this.perfMetrics = {
        updates: 0,
        computations: 0,
        domUpdates: 0,
        startTime: Date.now()
      };
      this.model.store.on("change", () => {
        this.perfMetrics.updates++;
      });
      this.model.store.on("compute", () => {
        this.perfMetrics.computations++;
      });
    }
    getPerfReport() {
      const duration = (Date.now() - this.perfMetrics.startTime) / 1e3;
      return {
        totalUpdates: this.perfMetrics.updates,
        updatesPerSecond: this.perfMetrics.updates / duration,
        computationsPerSecond: this.perfMetrics.computations / duration,
        domUpdatesPerSecond: this.perfMetrics.domUpdates / duration
      };
    }
  };
  var dev_tools_default = ModelDevTools;
  var MiddlewareManager = class {
    /**
     * Creates a new MiddlewareManager instance.
     * Initializes empty array for middleware functions.
     */
    constructor() {
      this.middlewares = [];
    }
    /**
     * Registers a new middleware function.
     * - Validates that middleware is a function
     * - Logs error if invalid middleware provided
     * - Adds valid middleware to execution chain
     *
     * @param {Function} middleware - Function(context, next)
     * @returns {void}
     * @throws {Error} Logs error for non-function middleware
     */
    use(middleware) {
      if (typeof middleware !== "function") {
        console.error("MIDDLEWARE should be a function!");
        return;
      }
      this.middlewares.push(middleware);
    }
    /**
     * Executes middleware chain sequentially.
     * - Maintains execution order using index counter
     * - Creates and passes next() function to each middleware
     * - Supports async middleware execution
     * - Preserves and returns modified context
     * - Stops chain when no more middleware exists
     *
     * @param {Object} context - Data passed through middleware chain
     * @returns {Promise<Object>} Modified context after chain completion
     */
    async process(context) {
      let index = -1;
      const next = async () => {
        index++;
        if (index < this.middlewares.length) {
          await this.middlewares[index](context, next);
        }
      };
      await next();
      return context;
    }
  };
  var middleware_default = MiddlewareManager;
  var Logger = class _Logger {
    /**
     * Enumeration of available debug levels from lowest (NONE) to highest (TRACE).
     * Used to control the verbosity of logging output.
     */
    static DEBUG_LEVELS = {
      NONE: 0,
      ERROR: 1,
      WARN: 2,
      INFO: 3,
      DEBUG: 4,
      TRACE: 5
    };
    /**
     * The current debug level for the Logger class. Determines the types of logs
     * that will be displayed. To adjust the logging behavior, set this property
     * to one of the predefined levels in `Logger.DEBUG_LEVELS`.
     *
     * @type {number}
     * @default Logger.DEBUG_LEVELS.NONE
     */
    static DEBUG_LEVEL = _Logger.DEBUG_LEVELS.NONE;
    /**
     * Core logging method that handles message formatting and output.
     * @param {number} level - Debug level from Logger.DEBUG_LEVELS
     * @param {string} message - Message to log
     * @param {any} [data] - Optional data to display
     * @private
     */
    static log(level, message, data) {
      if (level > _Logger.DEBUG_LEVEL) return;
      const styles = {
        error: "color: #ff5555; font-weight: bold",
        warn: "color: #ffaa00; font-weight: bold",
        info: "color: #0080fe; font-weight: bold",
        debug: "color: #00aa00; font-weight: bold",
        trace: "color: #888888",
        data: "color: #555; font-style: italic"
      };
      let styleType;
      let method;
      switch (level) {
        case _Logger.DEBUG_LEVELS.ERROR:
          styleType = "error";
          method = console.error;
          break;
        case _Logger.DEBUG_LEVELS.WARN:
          styleType = "warn";
          method = console.warn;
          break;
        case _Logger.DEBUG_LEVELS.INFO:
          styleType = "info";
          method = console.info;
          break;
        case _Logger.DEBUG_LEVELS.DEBUG:
          styleType = "debug";
          method = console.debug;
          break;
        case _Logger.DEBUG_LEVELS.TRACE:
          styleType = "trace";
          method = console.log;
          break;
        default:
          return;
      }
      console.group(`%c Model: ${message}`, styles[styleType]);
      if (data !== void 0) {
        console.log("%c Data:", styles.data, data);
      }
      console.groupEnd();
    }
    /**
     * Logs an error message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.ERROR` level.
     *
     * @param {string} message - The error message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static error(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.ERROR, message, data);
    }
    /**
     * Logs a warning message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.WARN` level.
     *
     * @param {string} message - The warning message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static warn(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.WARN, message, data);
    }
    /**
     * Logs an informational message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.INFO` level.
     *
     * @param {string} message - The informational message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static info(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.INFO, message, data);
    }
    /**
     * Logs a debug message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.DEBUG` level.
     *
     * @param {string} message - The debug message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static debug(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.DEBUG, message, data);
    }
    /**
     * Logs a trace message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.TRACE` level.
     *
     * @param {string} message - The trace message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static trace(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.TRACE, message, data);
    }
  };
  var ReactiveStore = class extends event_emitter_default {
    /**
     * Initializes a new ReactiveStore.
     * - Creates reactive proxy for state management
     * - Sets up watchers for property observation
     * - Stores previous state for change detection
     * - Initializes middleware system for state updates
     *
     * @param {Object} [initialState={}] - Initial store state
     * @param model
     * @property {Proxy} state - Reactive state object
     * @property {Map} watchers - Property change observers
     * @property {Object} previousState - Last known state
     * @property {MiddlewareManager} middleware - State update pipeline
     */
    constructor(initialState = {}, model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("Model: Init ReactiveStore");
      super();
      this.model = model;
      Logger.DEBUG_LEVEL = this.model.options.debug ? 4 : 0;
      Logger.debug("Model: Init ReactiveStore");
      this.state = this.createReactiveProxy(initialState);
      this.watchers = /* @__PURE__ */ new Map();
      this.previousState = JSON.parse(JSON.stringify(initialState));
      Logger.debug("Model: Init MiddlewareManager");
      this.middleware = new middleware_default();
      Logger.debug("Model: MiddlewareManager initialized");
      Logger.debug("Model: ReactiveStore initialized");
    }
    /**
     * Registers state change middleware.
     * Middleware receives context object with:
     * - prop: Changed property name
     * - oldValue: Previous value
     * - newValue: New value
     * - preventDefault: Control flag
     *
     * @param {Function} middleware - Handler(context, next)
     */
    use(middleware) {
      Logger.debug("Model: Registering middleware:", middleware);
      this.middleware.use(middleware);
    }
    /**
     * Creates reactive proxy for state objects.
     * Features:
     * - Special handling for arrays via separate proxy
     * - Deep reactivity for nested objects
     * - Property path tracking
     * - Value validation support
     * - Value formatting support
     * - Middleware integration
     * - Change prevention capability
     *
     * @param {Object|Array} obj - Target object
     * @param {string} [path=''] - Property path
     * @returns {Proxy} Reactive proxy
     */
    createReactiveProxy(obj, path = "") {
      Logger.debug(`Model: Creating reactive object with path ${path} for`, obj);
      if (Array.isArray(obj)) {
        return this.createArrayProxy(obj, path);
      }
      return new Proxy(obj, {
        get: (target, prop) => {
          if (typeof prop === "symbol") {
            return target[prop];
          }
          const value = target[prop];
          const fullPath = path ? `${path}.${prop}` : prop;
          if (value && typeof value === "object") {
            return this.createReactiveProxy(value, fullPath);
          }
          return value;
        },
        set: async (target, prop, value) => {
          if (typeof prop === "symbol") {
            target[prop] = value;
            return true;
          }
          const fullPath = path ? `${path}.${prop}` : prop;
          const oldValue = target[prop];
          if (oldValue === value) {
            return true;
          }
          if (this.validators?.has(`${fullPath}`)) {
            const isValid = this.validators.get(`${fullPath}`)(value);
            if (!isValid) return false;
          }
          if (this.formatters?.has(`${fullPath}`)) {
            value = this.formatters.get(`${fullPath}`)(value);
          }
          if (value && typeof value === "object") {
            value = this.createReactiveProxy(value, fullPath);
          }
          const context = {
            prop,
            oldValue,
            newValue: value,
            preventDefault: false
          };
          await this.middleware.process(context);
          if (context.preventDefault) {
            return true;
          }
          target[prop] = value;
          this.emit("change", {
            path: fullPath,
            oldValue,
            newValue: value
          });
          if (this.watchers.has(fullPath)) {
            this.watchers.get(fullPath).forEach((callback) => {
              callback(value, oldValue);
            });
          }
          return true;
        },
        deleteProperty: (target, prop) => {
          if (typeof prop === "symbol") {
            return delete target[prop];
          }
          const fullPath = path ? `${path}.${prop}` : prop;
          const oldValue = target[prop];
          const result = delete target[prop];
          if (result) {
            this.emit("delete", {
              path: fullPath,
              oldValue
            });
            if (this.watchers.has(fullPath)) {
              this.watchers.get(fullPath).forEach((callback) => {
                callback(void 0, oldValue);
              });
            }
          }
          return result;
        }
      });
    }
    /**
     * Creates a reactive proxy for an array.
     * The proxy intercepts standard array methods (for example, push, pop, shift, etc.)
     * to enable detection and reaction to structural changes in the array.
     * It also ensures that array elements are made reactive.
     *
     * @param {Array} array - The array to be proxied.
     * @param {string} path - The path to the current property in the state tree.
     *
     * @returns {Proxy} A proxy that wraps the given array to make it reactive.
     */
    createArrayProxy(array, path) {
      Logger.debug(`Model: Creating reactive array with path ${path} for`, array);
      return new Proxy(array, {
        get: (target, prop) => {
          if (typeof prop === "symbol") {
            return target[prop];
          }
          const value = target[prop];
          if (typeof value === "function" && ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].includes(prop)) {
            return (...args) => {
              const oldValue = [...target];
              const result = target[prop].apply(target, args);
              const context = {
                prop: path,
                oldValue,
                newValue: target,
                method: prop,
                args,
                preventDefault: false
              };
              this.middleware.process(context).then(() => {
                if (!context.preventDefault) {
                  this.emit("arrayChange", {
                    path,
                    method: prop,
                    args,
                    oldValue,
                    newValue: target
                  });
                  this.emit("change", {
                    path,
                    oldValue,
                    newValue: target,
                    method: prop,
                    args
                  });
                  if (this.watchers.has(path)) {
                    this.watchers.get(path).forEach((callback) => {
                      callback(target, oldValue);
                    });
                  }
                }
              });
              return result;
            };
          }
          if (typeof prop !== "symbol" && !isNaN(Number(prop))) {
            if (value && typeof value === "object") {
              return this.createReactiveProxy(value, `${path}[${prop}]`);
            }
          }
          return value;
        },
        set: async (target, prop, value) => {
          if (typeof prop === "symbol") {
            target[prop] = value;
            return true;
          }
          const fullPath = path ? `${path}.${prop}` : prop;
          const oldValue = target[prop];
          if (oldValue === value) {
            return true;
          }
          if (this.validators?.has(fullPath)) {
            const isValid = this.validators.get(fullPath)(value);
            if (!isValid) return false;
          }
          if (this.formatters?.has(fullPath)) {
            value = this.formatters.get(fullPath)(value);
          }
          target[prop] = value;
          if (value && typeof value === "object") {
            value = this.createReactiveProxy(value, `${path}[${prop}]`);
          }
          const context = {
            prop,
            oldValue,
            newValue: value,
            preventDefault: false
          };
          await this.middleware.process(context);
          if (context.preventDefault) {
            return true;
          }
          target[prop] = value;
          this.middleware.process(context).then(() => {
            if (!context.preventDefault) {
              this.emit("arrayChange", {
                path: fullPath,
                method: null,
                args: null,
                oldValue,
                newValue: value
              });
              this.emit("change", {
                path: fullPath,
                oldValue,
                newValue: value,
                arrayIndex: Number(prop)
              });
              if (this.watchers.has(fullPath)) {
                this.watchers.get(fullPath).forEach((callback) => {
                  callback(value, oldValue);
                });
              }
            }
          });
          return true;
        }
      });
    }
    /**
     * Applies the specified array method (for example, push, pop, splice) on the array
     * located at the given path in the state tree. The function ensures
     * that the changes are reactive by emitting appropriate events and invoking watchers.
     *
     * @param {string} path - The path to the array in the state tree.
     * @param {string} method - The name of the array method to apply (for example, 'push', 'pop').
     * @param {...any} args - Arguments to pass to the array method.
     *
     * @returns {any} The result of applying the array method to the array.
     */
    applyArrayMethod(path, method, ...args) {
      Logger.debug(`Model: Applying array method ${method} to path ${path} with args`, args);
      const array = this.get(path);
      if (!Array.isArray(array)) {
        console.error(`\u041F\u0443\u0442\u044C ${path} \u043D\u0435 \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u043C!`);
        return false;
      }
      const oldArray = [...array];
      const result = array[method].apply(array, args);
      this.emit("arrayChange", {
        path,
        method,
        args,
        oldValue: oldArray,
        newValue: [...array]
      });
      this.emit("change", {
        path,
        oldValue: oldArray,
        newValue: [...array]
      });
      if (this.watchers.has(path)) {
        this.watchers.get(path).forEach((callback) => {
          callback([...array], oldArray);
        });
      }
      return result;
    }
    /**
     * Watches for changes to an array located at the specified path in the state tree
     * and applies the provided callback to make modifications.
     * Emitted events ensure that watchers are notified and reactivity is maintained.
     *
     * @param {string} path - The path to the array in the state tree.
     * @param {Function} callback - A function to modify the array.
     *                               Receives the array as an argument and applies changes to it.
     *
     * @returns {any} The result of the callback function applied to the array.
     */
    applyArrayChanges(path, callback) {
      Logger.debug(`Model: Applying custom array changes to path ${path} with callback`, callback);
      const array = this.get(path);
      if (!Array.isArray(array)) {
        console.error(`The path ${path} is not an array!`);
        return false;
      }
      const oldArray = [...array];
      const result = callback(array);
      this.emit("arrayChange", {
        path,
        method: "custom",
        args: null,
        oldValue: oldArray,
        newValue: [...array]
      });
      this.emit("change", {
        path,
        oldValue: oldArray,
        newValue: [...array]
      });
      if (this.watchers.has(path)) {
        this.watchers.get(path).forEach((callback2) => {
          callback2([...array], oldArray);
        });
      }
      return result;
    }
    /**
     * Detects changes between two arrays, identifying items that were added, removed,
     * or moved. This function compares items by their JSON stringified values.
     *
     * @param {Array} newArray - The new array to compare.
     * @param {Array} [oldArray=[]] - The old array to compare against. Defaults to an empty array.
     *
     * @returns {Object} An object containing the changes between the arrays.
     */
    detectArrayChanges(newArray, oldArray = []) {
      Logger.debug(`Model: Detecting changes between arrays`);
      const changes = {
        added: [],
        removed: [],
        moved: []
      };
      for (let i3 = 0; i3 < newArray.length; i3++) {
        const item = newArray[i3];
        const oldIndex = oldArray.findIndex(
          (oldItem) => JSON.stringify(oldItem) === JSON.stringify(item)
        );
        if (oldIndex === -1) {
          changes.added.push({ index: i3, item });
        } else if (oldIndex !== i3) {
          changes.moved.push({ oldIndex, newIndex: i3, item });
        }
      }
      for (let i3 = 0; i3 < oldArray.length; i3++) {
        const item = oldArray[i3];
        const newIndex = newArray.findIndex(
          (newItem) => JSON.stringify(newItem) === JSON.stringify(item)
        );
        if (newIndex === -1) {
          changes.removed.push({ index: i3, item });
        }
      }
      Logger.debug(`Model: Detected changes:`, changes);
      return changes;
    }
    /**
     * Watches for changes to the specified path in the state tree
     * and allows the addition of callbacks that execute when changes occur.
     *
     * @param {string} path - The path in the state tree to watch for changes.
     * @param {Function} callback - A function to execute when the value at the path changes.
     *                                The callback receives the new and old values as parameters.
     *
     * @returns {Function} A function to unsubscribe the callback from the watcher.
     */
    watch(path, callback) {
      Logger.debug(`Model: Watching path ${path} with callback`, callback);
      if (!this.watchers.has(path)) {
        this.watchers.set(path, /* @__PURE__ */ new Set());
      }
      this.watchers.get(path).add(callback);
      return () => {
        if (this.watchers.has(path)) {
          this.watchers.get(path).delete(callback);
        }
      };
    }
    /**
     * Retrieves the value at the specified path in the state tree.
     * @param {string} [path] - The dot-delimited path to the desired value within the state tree.
     * @returns {any} - The value at the specified path or `undefined` if the path does not exist.
     */
    get(path) {
      Logger.debug(`Model: Getting value at path ${path}`);
      if (!path) return this.state;
      const parts = path.split(".");
      let value = this.state;
      for (const part of parts) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        value = value[part];
      }
      return value;
    }
    /**
     * Sets a new value at the specified path in the state tree.
     * @param {String} path - The dot-delimited path to the desired value within the state tree.
     * @param {any} value - The new value to set at the specified path.
     */
    set(path, value) {
      Logger.debug(`Model: Setting value at path ${path} to`, value);
      const parts = path.split(".");
      let current = this.state;
      for (let i3 = 0; i3 < parts.length - 1; i3++) {
        if (current[parts[i3]] === void 0) {
          current[parts[i3]] = {};
        }
        current = current[parts[i3]];
      }
      current[parts[parts.length - 1]] = value;
      return value;
    }
    /**
     * Executes the given updater as a batch operation on the state.
     *
     * If the `updater` is a function, it will be invoked with the state as an argument,
     * allowing for multiple updates within a single call. If the `updater` is an object,
     * its key-value pairs will be used to update specific paths in the state.
     *
     * After the batch operation completes, an event (`batchUpdate`) is emitted containing
     * both the previous state (before changes) and the current state (after changes).
     *
     * @param {Function|Object} updater - Either a function to modify the state or an object where keys represent
     *                                    paths (dot-delimited) and values are the new values to set for those paths.
     */
    batch(updater) {
      Logger.debug(`Model: Batch updating state with`, updater);
      this.previousState = JSON.parse(JSON.stringify(this.state));
      if (typeof updater === "function") {
        updater(this.state);
      } else if (typeof updater === "object") {
        Object.entries(updater).forEach(([path, value]) => {
          this.set(path, value);
        });
      }
      this.emit("batchComplete", {
        previousState: this.previousState,
        currentState: this.state
      });
    }
    /**
     * Retrieves the current state tree.
     * @returns {Object} The entire state object.
     */
    getState() {
      Logger.debug(`Model: Getting entire state`);
      return this.state;
    }
    /**
     * Retrieves the previous state of the state tree.
     *
     * This method returns the state as it was prior to the last update,
     * enabling comparison or rollback operations if needed.
     *
     * @returns {Object} The previous state object.
     */
    getPreviousState() {
      Logger.debug(`Model: Getting previous state`);
      return this.previousState;
    }
    /**
     * Converts the current state tree to a JSON string.
     *
     * This method serializes the entire state tree into a JSON-formatted string,
     * which can be used for storage, transmission, or debugging purposes.
     *
     * @returns {string} A JSON string representation of the current state.
     */
    toJSON() {
      Logger.debug(`Model: Converting state to JSON`);
      return JSON.stringify(this.state);
    }
    /**
     * Reconstructs the state tree from a JSON string.
     *
     * This method accepts a JSON-formatted string representing the state,
     * replaces the current state with the contents of the JSON, and emits a `restore` event
     * to notify listeners about the restoration operation. The previous state is preserved
     * for potential comparisons or rollback operations.
     *
     * @param {string} json - A JSON-formatted string representing the new state.
     */
    fromJSON(json) {
      Logger.debug(`Model: Restoring state from JSON`, json);
      const newState = JSON.parse(json);
      this.previousState = JSON.parse(JSON.stringify(this.state));
      Object.keys(this.state).forEach((key) => {
        delete this.state[key];
      });
      Object.entries(newState).forEach(([key, value]) => {
        this.state[key] = value;
      });
      this.emit("restore", {
        previousState: this.previousState,
        currentState: this.state
      });
    }
    /**
     * Adds a validator function for a specific property in the state tree.
     *
     * The validator function should accept the new value as a parameter
     * and return `true` if the value is valid, or `false` if it is invalid.
     *
     * @param {string} propertyPath - The dot-delimited path to the property in the state tree to validate.
     * @param {Function} validator - A function that checks the validity of the property value.
     */
    addValidator(propertyPath, validator) {
      Logger.debug(`Model: Adding validator for path ${propertyPath}`);
      if (!this.validators) {
        this.validators = /* @__PURE__ */ new Map();
      }
      this.validators.set(propertyPath, validator);
    }
    /**
     * Adds a formatter function for a specific property in the state tree.
     *
     * The formatter function modifies the value of a property before it is returned.
     * This can be helpful when the stored value needs to be presented in a specific format.
     *
     * @param {string} propertyPath - The dot-delimited path to the property in the state tree to format.
     * @param {Function} formatter - A function that transforms the value of the property.
     *                                The function receives the current value as a parameter
     *                                and returns the formatted value.
     */
    addFormatter(propertyPath, formatter) {
      Logger.debug(`Model: Adding formatter for path ${propertyPath}`);
      if (!this.formatters) {
        this.formatters = /* @__PURE__ */ new Map();
      }
      this.formatters.set(propertyPath, formatter);
    }
    /**
     * Validates if the provided path exists in the state tree.
     *
     * This method checks whether the specified dot-delimited path
     * in the state tree resolves to a defined value.
     *
     * @param {string} path - The dot-delimited path to validate.
     * @returns {boolean} - `true` if the path exists and has a defined value, `false` otherwise.
     */
    isValidPath(path) {
      Logger.debug(`Model: Validating path ${path}`);
      try {
        const value = this.get(path);
        return value !== void 0;
      } catch (e2) {
        Logger.error(`Model: Error validating path ${path}:`, e2);
        return false;
      }
    }
    /**
     * Destroys the current state object and clears all associated watchers and previous states.
     *
     * This method is useful for cleanup operations, ensuring no residual state,
     * watchers, or references are left in memory.
     */
    destroy() {
      this.state = null;
      this.watchers.clear();
      this.previousState = null;
      Logger.debug("Model: ReactiveStore destroyed");
    }
  };
  var LoopManager = class {
    /**
     * Creates a new instance of LoopManager.
     *
     * @param {Object} domManager - Manages DOM operations and template bindings
     * @param {Object} model - Contains the data store and bindings
     * @property {Map} loops - Stores array loop templates and configurations
     * @property {Array} loopsIn - Stores object loop configurations and elements
     */
    constructor(domManager, model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("Model: Init LoopManager");
      this.domManager = domManager;
      this.model = model;
      this.loops = /* @__PURE__ */ new Map();
      this.loopsIn = [];
      Logger.debug("Model: LoopManager initialized");
    }
    /**
     * Parses and initializes both array and object loops in the DOM.
     *
     * For data-for loops:
     * - Validates loop expression syntax (item[, index] in array)
     * - Creates template clones for future updates
     * - Registers array dependencies for reactive updates
     * - Performs initial loop rendering
     *
     * For data-in loops:
     * - Validates loop expression (key in object)
     * - Stores original templates
     * - Creates placeholder comments for loop position
     * - Hides original elements
     * - Performs initial object iteration rendering
     *
     * @param {HTMLElement} rootElement - Root element to scan for loop directives
     * @throws {Error} Logs error for invalid loop expressions
     */
    parseLoops(rootElement) {
      Logger.debug("Parsing loops with data-for...");
      const loopElements = rootElement.querySelectorAll("[data-for]");
      Logger.debug("Found elements with data-for:", loopElements.length);
      loopElements.forEach((element2) => {
        const expression = element2.getAttribute("data-for").trim();
        const matches2 = expression.match(/^\s*(\w+)(?:\s*,\s*(\w+))?\s+in\s+(\w+(?:\.\w+)*)\s*$/);
        if (!matches2) {
          console.error("Invalid expression format data-for:", expression);
          return;
        }
        const [_4, itemName, indexName, arrayPath] = matches2;
        const array = this.model.store.get(arrayPath);
        if (!Array.isArray(array)) {
          console.error(`The value in the ${arrayPath} path is not an array:`, array);
          return;
        }
        const template = element2.cloneNode(true);
        this.loops.set(element2, {
          template,
          itemName,
          indexName,
          arrayPath,
          parentNode: element2.parentNode
        });
        this.domManager.registerDomDependency(arrayPath, element2, {
          type: "loop",
          arrayPath
        });
        this.updateLoop(element2);
      });
      Logger.debug("Parsing loops with data-in...");
      const inLoops = rootElement.querySelectorAll("[data-in]");
      Logger.debug("Found elements with data-in:", inLoops.length);
      inLoops.forEach((element2) => {
        const attributeValue = element2.getAttribute("data-in");
        const match = attributeValue.match(/^\s*(\w+)\s+in\s+(\S+)\s*$/);
        if (!match) {
          console.error(`Invalid data-in syntax: ${attributeValue}`);
          return;
        }
        const [_4, keyVar, objectPath] = match;
        const template = element2.innerHTML;
        const parent2 = element2.parentNode;
        const placeholder = document.createComment(`data-in: ${attributeValue}`);
        element2.style.display = "none";
        parent2.insertBefore(placeholder, element2);
        this.loopsIn.push({
          type: "in",
          originalElement: element2,
          template,
          placeholder,
          objectPath,
          keyVar,
          elements: []
        });
        const objectData = this.model.store.get(objectPath);
        if (objectData && typeof objectData === "object" && !Array.isArray(objectData)) {
          this.updateInLoop(this.loopsIn[this.loopsIn.length - 1], objectData);
        }
      });
    }
    /**
     * Updates the content of object-based loops (`data-in`) when the associated object data changes.
     *
     * This method clears the current DOM elements generated for the loop, then iterates through
     * the provided `objectData` to render new elements based on the loop's template. It uses the
     * `keyVar` for the object's keys and binds the DOM elements for further updates.
     *
     * @param {Object} loop - The loop configuration containing details such as the template,
     *                        placeholder, and object path.
     * @param {Object} objectData - The new object data used to generate loop elements.
     */
    updateInLoop(loop, objectData) {
      loop.elements.forEach((el) => el.remove());
      loop.elements = [];
      if (!objectData || typeof objectData !== "object" || Array.isArray(objectData)) {
        return;
      }
      Object.keys(objectData).forEach((key) => {
        Logger.debug(`Updating loop for key: ${key}`);
        const newElement = loop.originalElement.cloneNode(true);
        newElement.removeAttribute("data-in");
        newElement.style.display = "";
        const itemContext = {
          [loop.keyVar]: key
        };
        newElement.innerHTML = this.processTemplate(loop.template, objectData, key, itemContext);
        loop.placeholder.parentNode.insertBefore(newElement, loop.placeholder.nextSibling);
        loop.elements.push(newElement);
        this.domManager.bindDOM(newElement);
      });
    }
    /**
     * Processes a template string by replacing placeholders with computed values
     * based on the given object data, key, and context.
     *
     * Placeholder syntax: `{{ path }}`, where `path` can refer to variable keys,
     * object properties, or dynamic expressions.
     *
     * @param {string} template - The template string containing placeholders.
     * @param {Object} objectData - The object data used for resolving placeholders.
     * @param {string} key - The current key in the object data.
     * @param {Object} itemContext - The context containing additional data such as the key variable.
     * @returns {string} - The processed template string with placeholders replaced by their respective values.
     */
    processTemplate(template, objectData, key, itemContext) {
      Logger.debug("Processing template:", template);
      Logger.debug("	 With data:", objectData);
      Logger.debug(`	 For key: ${key}`);
      Logger.debug(`	 With context:`, itemContext);
      return template.replace(/\{\{\s*([^}]+)\s*\}\}/g, (match, path) => {
        path = path.trim();
        const keyVar = Object.keys(itemContext)[0];
        if (path === keyVar) {
          return key;
        }
        Logger.debug(`Template: Processing path: ${path}`);
        const bracketRegex = new RegExp(`(\\w+)\\[${keyVar}\\]`);
        const bracketMatch = path.match(bracketRegex);
        if (bracketMatch) {
          const objName = bracketMatch[1];
          const obj = objectData;
          if (obj && typeof obj === "object") {
            return obj[key] !== void 0 ? obj[key] : "";
          }
        }
        const value = this.model.store.get(path);
        if (value !== void 0) {
          return value;
        }
        return "";
      });
    }
    /**
     * Updates all the loops (`data-for` and `data-in`) when the data in the store changes.
     *
     * Specifically:
     * - Updates array-based loops (`data-for`) if the associated array data changes.
     * - Updates object-based loops (`data-in`) if the associated object or its child properties change.
     *
     * @param {string} path - The path of the data in the store that has changed.
     * @param {*} value - The new value at the given path.
     */
    updateLoops(path, value) {
      Logger.debug("Updating data-for loops for ${path}", this.loops);
      this.loops.forEach((loopInfo, element2) => {
        if (loopInfo.arrayPath === path) {
          this.updateLoop(element2);
        }
      });
      Logger.debug(`Updating data-in loops for ${path}`, this.loopsIn);
      this.loopsIn.forEach((loop) => {
        if (loop.type === "in" && (loop.objectPath === path || path.startsWith(loop.objectPath + "."))) {
          const objectData = this.model.store.get(loop.objectPath);
          if (objectData && typeof objectData === "object") {
            this.updateInLoop(loop, objectData);
          }
        }
      });
    }
    /**
     * Updates the entire loop for a given element.
     * @param element
     */
    updateLoop(element2) {
      Logger.debug("Updating loop for element:", element2);
      const loopInfo = this.loops.get(element2) || this.loopsIn.find((loop) => loop.originalElement === element2)[0];
      if (!loopInfo) {
        console.error("\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0446\u0438\u043A\u043B\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430 \u0434\u043B\u044F \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430");
        return;
      }
      const { template, itemName, indexName, arrayPath, parentNode } = loopInfo;
      const array = this.model.store.get(arrayPath);
      if (!Array.isArray(array)) {
        console.error("\u0417\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043D\u0435 \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u043C:", array);
        return;
      }
      const generated = parentNode.querySelectorAll(`[data-generated-for="${arrayPath}"]`);
      generated.forEach((el) => el.remove());
      array.forEach((item, index) => {
        const newNode = template.cloneNode(true);
        newNode.style.display = "";
        newNode.removeAttribute("data-for");
        newNode.setAttribute("data-generated-for", arrayPath);
        newNode.setAttribute("data-item-index", "" + index);
        Logger.debug(`Creating new loop element for ${arrayPath} at index ${index}`);
        this.domManager.processTemplateNode(newNode, {
          [itemName]: item,
          [indexName || "index"]: index
        });
        Logger.debug(`Insert new node`, newNode);
        parentNode.insertBefore(newNode, element2);
      });
      element2.style.display = "none";
    }
    /**
     * Partially updates a single DOM element within a loop based on changes in
     * the associated array. Specifically:
     * - If the changed index is provided, updates only the element at that index.
     * - If no changed index is provided or if the array length does not match
     *   the number of generated elements, falls back to a full loop update.
     *
     * @param {HTMLElement} element - The loop's original template element.
     * @param {string} arrayPath - The path to the array in the data store associated with this loop.
     * @param {*} changedValue - The updated value in the array (optional).
     * @param {number} changedIndex - The index of the updated value in the array (optional).
     */
    updateLoopPart(element2, arrayPath, changedValue, changedIndex) {
      const loopInfo = this.loops.get(element2);
      if (!loopInfo) return;
      const { template, itemName, indexName, parentNode } = loopInfo;
      const array = this.model.store.get(arrayPath);
      if (!Array.isArray(array)) return;
      const generated = Array.from(
        parentNode.querySelectorAll(`[data-generated-for="${arrayPath}"]`)
      );
      if (changedIndex === void 0 || generated.length !== array.length) {
        return this.updateLoop(element2);
      }
      const elementToUpdate = generated[changedIndex];
      if (elementToUpdate) {
        const newNode = template.cloneNode(true);
        this.domManager.processTemplateNode(newNode, {
          [itemName]: array[changedIndex],
          [indexName || "index"]: changedIndex
        });
        while (elementToUpdate.firstChild) {
          elementToUpdate.removeChild(elementToUpdate.firstChild);
        }
        while (newNode.firstChild) {
          elementToUpdate.appendChild(newNode.firstChild);
        }
        Array.from(newNode.attributes).forEach((attr) => {
          elementToUpdate.setAttribute(attr.name, attr.value);
        });
      }
    }
    /**
     * Returns an object containing the tracked loops in the current instance.
     *
     * @returns {Object} An object with two properties:
     * - `for`: A Map of loops associated with array-based (`data-for`) rendering.
     * - `in`: An array of loops associated with object-based (`data-in`) rendering.
     */
    getLoops() {
      return {
        "for": this.loops,
        "in": this.loopsIn
      };
    }
    /**
     * Destroys all tracked loops by clearing the internal Map of `data-for` loops.
     *
     * This method should be called when the instance is no longer needed
     * to release memory and cleanup loop references.
     */
    destroy() {
      this.loops.clear();
      this.loopsIn = [];
      Logger.debug("Model: LoopManager destroyed");
    }
  };
  var ExpressionManager = class {
    /**
     * Evaluates a given expression within a specific context.
     *
     * This method can handle three types of input:
     * 1. Expressions wrapped in double curly braces (`{{ }}`) are treated as
     *    context paths and their values are retrieved using the `getValueFromContext` method.
     * 2. Ternary, logical, and comparison operations within the expression
     *    are parsed and evaluated using the `parseExpression` method.
     * 3. Literal or primitive values (for example, numbers, strings, booleans) are directly returned.
     *
     * Any parsing or evaluation errors are caught and logged.
     *
     * @param {string} expression - The expression to evaluate.
     * @param {Object} context - The object representing the evaluation context.
     * @returns {*} The result of evaluating the expression. Returns `false` if an error occurs.
     */
    static evaluateExpression(expression, context) {
      try {
        if (expression.startsWith("{{") && expression.endsWith("}}")) {
          const path = expression.substring(2, expression.length - 2).trim();
          return this.getValueFromContext(context, path);
        }
        return this.parseExpression(expression, context);
      } catch (error) {
        console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u044B\u0447\u0438\u0441\u043B\u0435\u043D\u0438\u0438 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u044F:", error);
        return false;
      }
    }
    /**
     * Retrieves a value from a given context object based on a dot-separated path.
     *
     * This method allows accessing nested properties or array elements from an object
     * using a path string. If a part of the path references an array, you can include
     * an array index (for example, 'path.toArray[0]'). If the path is invalid or the property
     * doesn't exist, the method will return undefined.
     *
     * @param {Object} obj - The context object to retrieve values from.
     * @param {string} path - The dot-separated string representing the path to the value.
     * @returns {*} The value located at the specified path, or undefined if not found.
     */
    static getValueFromContext(obj, path) {
      if (!path) return obj;
      return path.split(".").reduce((acc, part) => {
        const arrayMatch = part.match(/^([^\[]+)(?:\[(\d+)\])?$/);
        if (arrayMatch) {
          const [_4, propName, arrayIndex] = arrayMatch;
          const propValue = acc?.[propName];
          return arrayIndex !== void 0 && Array.isArray(propValue) ? propValue[parseInt(arrayIndex, 10)] : propValue;
        }
        return acc?.[part];
      }, obj);
    }
    /**
     * Parses and evaluates a given expression within a provided context.
     *
     * This method handles several types of expressions, including:
     * 1. Ternary expressions (`condition ? trueValue : falseValue`).
     * 2. Logical expressions with `&&` (AND) and `||` (OR).
     * 3. Comparison expressions (for example, `===`, `!==`, `>`, `<`, `>=`, `<=`).
     * 4. String literals inside single or double quotes.
     * 5. Numeric literals (integers and floats).
     * 6. Boolean literals (`true`, `false`), and `null`, `undefined`.
     * 7. Context-based values, retrieved using the `getValueFromContext` method if the expression
     *    is not a primitive value or an operation.
     *
     * The method uses recursion to parse and evaluate nested expressions.
     *
     * @param {string} expression - The expression to parse and evaluate.
     * @param {Object} context - The object providing the evaluation context.
     * @returns {*} The evaluated result of the expression, or `undefined` if the path does not exist in the context.
     */
    static parseExpression(expression, context) {
      expression = expression.trim();
      const ternaryMatch = expression.match(/(.+?)\s*\?\s*(.+?)\s*:\s*(.+)/);
      if (ternaryMatch) {
        const [_4, condition, trueExpr, falseExpr] = ternaryMatch;
        return this.parseExpression(condition, context) ? this.parseExpression(trueExpr, context) : this.parseExpression(falseExpr, context);
      }
      if (expression.includes("&&")) {
        const parts = expression.split("&&");
        return parts.every((part) => this.parseExpression(part.trim(), context));
      }
      if (expression.includes("||")) {
        const parts = expression.split("||");
        return parts.some((part) => this.parseExpression(part.trim(), context));
      }
      const comparisonMatch = expression.match(/(.+?)\s*(===|==|!==|!=|>=|<=|>|<)\s*(.+)/);
      if (comparisonMatch) {
        const [_4, left, operator, right] = comparisonMatch;
        const leftValue = this.parseExpression(left.trim(), context);
        const rightValue = this.parseExpression(right.trim(), context);
        switch (operator) {
          case "==":
            return leftValue == rightValue;
          case "===":
            return leftValue === rightValue;
          case "!=":
            return leftValue != rightValue;
          case "!==":
            return leftValue !== rightValue;
          case ">":
            return leftValue > rightValue;
          case "<":
            return leftValue < rightValue;
          case ">=":
            return leftValue >= rightValue;
          case "<=":
            return leftValue <= rightValue;
        }
      }
      if (expression.startsWith("'") && expression.endsWith("'") || expression.startsWith('"') && expression.endsWith('"')) {
        return expression.substring(1, expression.length - 1);
      }
      if (/^-?\d+(\.\d+)?$/.test(expression)) {
        return parseFloat(expression);
      }
      if (expression === "true") return true;
      if (expression === "false") return false;
      if (expression === "null") return null;
      if (expression === "undefined") return void 0;
      return this.getValueFromContext(context, expression);
    }
    /**
     * Extracts variables from a given expression string.
     *
     * This method parses the expression and returns a list of variable names that are used
     * in the expression. The variables are determined based on alphanumeric and underscore
     * naming conventions, excluding JavaScript reserved keywords and primitive constants.
     *
     * @param {string} expression - The expression string to extract variables from.
     * @returns {Array<string>} An array of unique variable names found in the expression.
     * Variables are returned in their base form (in other words, the part before any dot notation or brackets).
     */
    static extractVariables(expression) {
      const variables = [];
      const cleanExpr = expression.replace(/'[^']*'/g, "''").replace(/"[^"]*"/g, '""');
      const matches2 = cleanExpr.match(/[a-zA-Z_][a-zA-Z0-9_]*(\.([a-zA-Z_][a-zA-Z0-9_]*))*(\[\d+\])*/g);
      if (matches2) {
        matches2.forEach((match) => {
          const baseName = match.split(".")[0].split("[")[0].trim();
          if (!["true", "false", "null", "undefined"].includes(baseName)) {
            if (!variables.includes(baseName)) {
              variables.push(baseName);
            }
          }
        });
      }
      return variables;
    }
  };
  var ConditionalManager = class {
    /**
     * Initializes a new instance of the ConditionalManager class.
     *
     * @constructor
     * @param {Object} dom - The root DOM element or DOM-related utilities.
     * @param {Object} model - The data model containing state (for example, `store` or `data`).
     */
    constructor(dom, model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("ConditionalManager: Init ConditionalManager");
      this.dom = dom;
      this.model = model;
      this.dependencies = /* @__PURE__ */ new Map();
      this.conditionalGroups = [];
      this.subscribe();
      Logger.debug("ConditionalManager: ConditionalManager initialized");
    }
    /**
     * Subscribes to the model's store 'change' event to automatically update
     * affected conditional groups when data changes.
     * - Listens for store changes
     * - Identifies affected groups using getGroupsByPath
     * - Triggers updates for affected conditional groups
     *
     * @method subscribe
     * @private
     */
    subscribe() {
      Logger.debug("ConditionalManager: Subscribe to store changes");
      this.model.store.on("change", (data) => {
        const dependentGroups = this.getGroupsByPath(data.path);
        dependentGroups.forEach((group) => {
          this.updateConditionalGroup(group);
        });
      });
    }
    /**
     * Finds all conditional groups that depend on a specific model path.
     * - Uses Set to avoid duplicate groups
     * - Checks direct path matches and path prefix matches
     * - Filters groups based on their expressions
     *
     * @param {string} path - The model path to check dependencies against
     * @returns {Array} Array of unique conditional groups dependent on the path
     * @private
     */
    getGroupsByPath(path) {
      if (!path) {
        return [];
      }
      const result = /* @__PURE__ */ new Set();
      this.conditionalGroups.forEach((group) => {
        const hasDependency = group.some((item) => {
          if (!item.expression) return false;
          return item.expression.includes(path) || path.startsWith(this.extractBasePath(item.expression));
        });
        if (hasDependency) {
          result.add(group);
        }
      });
      return Array.from(result);
    }
    /**
     * Extracts the base path from an expression using regex pattern matching.
     * - Matches valid JavaScript variable names
     * - Returns the first match or empty string
     * - Valid names start with letter/underscore followed by alphanumeric/underscore
     *
     * @param {string} expression - Expression to analyze
     * @returns {string} First valid variable name or empty string
     * @private
     */
    extractBasePath(expression) {
      const matches2 = expression.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);
      return matches2 ? matches2[0] : "";
    }
    /**
     * Parses and creates a map of conditional elements (`data-if`, `data-else-if`, and `data-else`)
     * within the given `rootElement`. Groups related conditional elements and attach 
     * them to the `conditionalGroups` property for dynamic evaluation.
     *
     * This method identifies `data-if`, `data-else-if`, and `data-else` attributes in the DOM and
     * ensures their relationships are correctly established (for example, ensuring `data-else` elements have
     * preceding `data-if` or `data-else-if` elements). It also handles invalid sequences of attributes
     * and logs warnings for cases where a `data-else` doesn't follow valid prerequisites.
     *
     * After parsing and grouping, conditional groups are evaluated, and their dependencies
     * are registered for reactive re-evaluation when relevant model paths change.
     *
     * @method parseConditionals
     * @param {Element} rootElement - The root DOM element to scan for conditional attributes.
     * @public
     */
    parseConditionals(rootElement) {
      Logger.debug("ConditionalManager: Parse conditionals (data-if, data-else-if, data-else)...");
      const nodes = rootElement.querySelectorAll("[data-if],[data-else-if],[data-else]");
      let currentGroup = [];
      const groups = [];
      nodes.forEach((node) => {
        if (node.hasAttribute("data-if")) {
          Logger.debug(`ConditionalManager: Found data-if in element:`, node);
          if (currentGroup.length) {
            groups.push(currentGroup);
          }
          currentGroup = [{
            element: node,
            type: "if",
            expression: node.getAttribute("data-if")
          }];
        } else if (node.hasAttribute("data-else-if")) {
          Logger.debug(`ConditionalManager: Found data-else-if in element:`, node);
          if (currentGroup.length && this.isAdjacentNode(currentGroup[currentGroup.length - 1].element, node)) {
            currentGroup.push({
              element: node,
              type: "else-if",
              expression: node.getAttribute("data-else-if")
            });
          } else {
            if (currentGroup.length) {
              groups.push(currentGroup);
            }
            currentGroup = [{
              element: node,
              type: "if",
              expression: node.getAttribute("data-else-if")
            }];
          }
        } else if (node.hasAttribute("data-else")) {
          Logger.debug(`ConditionalManager: Found data-else in element:`, node);
          if (currentGroup.length && this.isAdjacentNode(currentGroup[currentGroup.length - 1].element, node)) {
            currentGroup.push({
              element: node,
              type: "else",
              expression: null
            });
            groups.push(currentGroup);
            currentGroup = [];
          } else {
            Logger.warn("data-else without previous data-if or data-else-if", node);
          }
        }
      });
      if (currentGroup.length) {
        groups.push(currentGroup);
      }
      this.conditionalGroups = groups;
      groups.forEach((group) => this.updateConditionalGroup(group));
      this.setupDependencies(nodes);
    }
    /**
     * Checks if two DOM nodes are adjacent siblings, ignoring whitespace nodes.
     *
     * This method iterates over the sibling nodes of `node1` until it encounters
     * either `node2` (indicating adjacency) or another element node that is not
     * a whitespace text node (indicating they are not adjacent).
     *
     * @param {Node} node1 - The first DOM node.
     * @param {Node} node2 - The second DOM node to check adjacency with.
     * @returns {boolean} `true` if `node2` is an adjacent sibling of `node1`, ignoring whitespace; otherwise `false`.
     * @private
     */
    isAdjacentNode(node1, node2) {
      let current = node1.nextSibling;
      while (current) {
        if (current === node2) return true;
        if (current.nodeType === 1 && !this.isWhitespaceNode(current)) return false;
        current = current.nextSibling;
      }
      return false;
    }
    /**
     * Determines if a given DOM node is a whitespace text node.
     *
     * A whitespace text node is a text node (nodeType === 3)
     * whose content consists only of whitespace characters (spaces, tabs, newlines).
     *
     * @param {Node} node - The DOM node to check.
     * @returns {boolean} `true` if the node is a whitespace text node; otherwise `false`.
     * @private
     */
    isWhitespaceNode(node) {
      return node.nodeType === 3 && node.textContent.trim() === "";
    }
    /**
     * Evaluates and updates the visibility of elements within a group of conditionals.
     *
     * A group represents a logical chain of `data-if`, `data-else-if`, and `data-else` elements.
     * This method determines the first condition in the group that evaluates to `true`
     * and sets the corresponding element to be displayed while hiding others.
     *
     * @param {Array<Object>} group - An array representing a logical group of conditionals.
     * Each object in the array contains:
     *    - {HTMLElement} element: The DOM element.
     *    - {string} type: The type of conditional ('if', 'else-if', 'else').
     *    - {string|null} expression: The conditional expression, null for 'else'.
     */
    updateConditionalGroup(group) {
      const context = this.model && this.model.store ? { ...this.model.store.getState() } : this.model && this.model.data ? this.model.data : {};
      let conditionMet = false;
      for (const item of group) {
        if (item.type === "if" || item.type === "else-if") {
          const result = !conditionMet && ExpressionManager.evaluateExpression(item.expression, context);
          if (result) {
            item.element.style.display = "";
            conditionMet = true;
          } else {
            item.element.style.display = "none";
          }
        } else if (item.type === "else") {
          item.element.style.display = conditionMet ? "none" : "";
        }
      }
    }
    /**
     * Updates the visibility of DOM elements based on conditional expressions.
     *
     * This method processes groups of elements with `data-if`, `data-else-if`, and `data-else` attributes,
     * updating their visibility based on the evaluation of corresponding expressions.
     *
     * It also sets up dependencies between variables used in the expressions and their corresponding DOM elements,
     * allowing for dynamic updates when the context or variables change.
     *
     * This functionality is used to implement conditional rendering in the DOM.
     *
     * @param {HTMLElement} element - The DOM element to update.
     * @param {string} expression - The conditional expression to evaluate.
     * Nodes are expected to contain attributes like `data-if`, `data-else-if`, or `data-else`.
     */
    updateConditional(element2, expression) {
      const group = this.findGroupForElement(element2);
      if (group) {
        this.updateConditionalGroup(group);
      } else {
        const context = this.model && this.model.store ? { ...this.model.store.getState() } : this.model && this.model.data ? this.model.data : {};
        const result = ExpressionManager.evaluateExpression(expression, context);
        element2.style.display = result ? "" : "none";
      }
    }
    /**
     * Finds and returns the group of conditional elements that contains the specified element.
     *
     * This method searches through the existing groups of conditional elements to determine
     * the group where the given element belongs. Each group represents a logical chain of
     * `data-if`, `data-else-if`, and `data-else` elements.
     *
     * @param {Element} element - The DOM element to find the group for.
     * @returns {Array<Object>|null} The group containing the specified element, or `null` if not found.
     * Each group object comprises:
     *    - {Element} element: The DOM element.
     *    - {string} type: The type of conditional ('if', 'else-if', 'else').
     *    - {string|null} expression: The conditional expression, null for 'else'.
     */
    findGroupForElement(element2) {
      for (const group of this.conditionalGroups || []) {
        if (group.some((item) => item.element === element2)) {
          return group;
        }
      }
      return null;
    }
    /**
     * Sets up and configures the dependencies for the provided DOM nodes.
     *
     * This method scans through the given list of nodes and determines
     * which variables are referenced in their conditional expressions (`data-if`, `data-else-if`).
     * It maps these variables to the corresponding DOM elements, building a dependency tree
     * that allows tracking of changes and their impact on the visibility of elements.
     *
     * @param {NodeList|Array<Element>} nodes - The list of DOM elements to process.
     */
    setupDependencies(nodes) {
      this.dependencies = /* @__PURE__ */ new Map();
      nodes.forEach((element2) => {
        let expression;
        if (element2.hasAttribute("data-if")) {
          expression = element2.getAttribute("data-if");
        } else if (element2.hasAttribute("data-else-if")) {
          expression = element2.getAttribute("data-else-if");
        } else {
          return;
        }
        const variables = ExpressionManager.extractVariables(expression);
        variables.forEach((variable) => {
          if (!this.dependencies.has(variable)) {
            this.dependencies.set(variable, []);
          }
          this.dependencies.get(variable).push({
            element: element2,
            expression,
            type: element2.hasAttribute("data-if") ? "if" : "else-if"
          });
        });
      });
    }
    /**
     * Retrieves all dependencies related to a specific path.
     *
     * This method scans through the dependency map and collects all elements and their details
     * that are associated with the given path. It also includes dependencies that match the base
     * path and/or any sub-paths (for example, 'path' and 'path.sub').
     *
     * @param {string} path - The path of the dependency to look for.
     * @returns {Array<Object>} An array of dependency objects containing:
     *    - {Element} element: The DOM element associated with the dependency.
     *    - {string} expression: The original conditional expression linked to the dependency.
     *    - {string} type: The type of the conditional ('if' or 'else-if').
     */
    getDependenciesByPath(path) {
      const result = [];
      this.dependencies.forEach((deps, variable) => {
        if (variable === path || path.startsWith(variable + ".")) {
          result.push(...deps);
        }
      });
      return result;
    }
    /**
     * Cleans up the instance by clearing dependencies and resetting conditional groups.
     *
     * This method should be called to release resources and avoid memory leaks when
     * the instance of the class is no longer required.
     */
    destroy() {
      this.dependencies.clear();
      this.conditionalGroups = [];
      Logger.debug("ConditionalManager: Destroyed");
    }
  };
  var AttributeManager = class {
    constructor(dom, model) {
      this.domManager = dom;
      this.model = model;
      Logger.DEBUG_LEVEL = this.model.options.debug ? 4 : 0;
      Logger.debug("AttributeManager: Init AttributeManager");
    }
    /**
     * Parses the attributes of elements with 'data-bind' attribute within the root element.
     * - Searches for elements with data-bind attribute
     * - Parses JSON binding expressions (converts single quotes to double quotes)
     * - Extracts variables from expressions
     * - Registers DOM dependencies for each variable
     * - Initializes attribute values
     *
     * @param {HTMLElement} rootElement - The root element containing elements with data bindings.
     * @throws {Error} When binding expression parsing fails
     */
    parseAttributesBind(rootElement) {
      Logger.debug("AttributeManager: Parsing attributes bind with data-bind...");
      const elements = rootElement.querySelectorAll("[data-bind]");
      Logger.debug("AttributeManager: Found elements with data-bind:", elements.length);
      elements.forEach((element2) => {
        Logger.debug("AttributeManager: Parsing element with data-bind:", element2);
        const bindingExpression = element2.getAttribute("data-bind");
        try {
          const bindings = JSON.parse(bindingExpression.replace(/'/g, '"'));
          for (const [attributeName, expression] of Object.entries(bindings)) {
            const variables = ExpressionManager.extractVariables(expression);
            Logger.debug(`AttributeManager: Found variables for ${attributeName}:`, variables);
            variables.forEach((variable) => {
              this.domManager.registerDomDependency(variable, element2, {
                type: "attribute",
                attribute: attributeName,
                expression
              });
            });
            this.updateAttributes(element2, attributeName, expression);
          }
        } catch (error) {
          console.error("An error of analysis of attachments:", error);
        }
      });
    }
    /**
     * Updates a DOM element's attribute based on a provided expression.
     * Evaluates the expression using the current state of the application model, and
     * updates the attribute only if its value has changed.
     *
     * - If the expression represents a falsy value (false, null, undefined), the attribute is removed.
     * - If the value is `true`, the attribute is added without a value ("").
     * - Otherwise, the attribute is set to the string field value of the evaluated expression.
     *
     * @param {HTMLElement} element - The DOM element whose attribute needs to be updated.
     * @param {string} attributeName - The name of the attribute to be updated.
     * @param {string} expression - The expression to be evaluated to determine the attribute's value.
     *
     * Special cases:
     * - Handles template expressions in format {{expression}}
     * - Direct model path access for template expressions
     * - Expression evaluation for non-template strings
     * 
     */
    updateAttributes(element2, attributeName, expression) {
      const context = { ...this.model.store.getState() };
      let value;
      if (expression.startsWith("{{") && expression.endsWith("}}")) {
        const path = expression.substring(2, expression.length - 2).trim();
        value = this.model.store.get(path);
      } else {
        value = ExpressionManager.evaluateExpression(expression, context);
      }
      const previousValue = element2.getAttribute(attributeName);
      if (String(value) !== previousValue) {
        if (value === false || value === null || value === void 0) {
          element2.removeAttribute(attributeName);
        } else if (value === true) {
          element2.setAttribute(attributeName, "");
        } else {
          element2.setAttribute(attributeName, String(value));
        }
        Logger.debug(`AttributeManager: Updated attribute ${attributeName} with value:`, value);
      }
    }
    /**
     * Parses and processes attribute bindings in the provided root DOM element. 
     * Attributes prefixed with a colon (for example, `:class`) * are treated as dynamic bindings.
     *
     * For each dynamically bound attribute:
     * - Updates the attribute value on the element based on the
     *   current model store state.
     * - Registers a dependency between the element and the attribute
     *   expression in the DOM dependency tracker.
     * - Removes the colon-prefixed attribute from the DOM.
     *
     * @param {HTMLElement} rootElement - The root element to search
     *                                    for attribute bindings.
     */
    parseAttributes(rootElement) {
      Logger.debug("AttributeManager: Parsing attributes with colon...");
      const allElements = rootElement.querySelectorAll("*");
      for (const element2 of allElements) {
        const attributes = element2.attributes;
        for (let i3 = 0; i3 < attributes.length; i3++) {
          const attr = attributes[i3];
          if (attr.name.startsWith(":")) {
            Logger.debug(`AttributeManager: Found attribute:`, attr);
            const realAttrName = attr.name.substring(1);
            const expression = attr.value;
            this.updateElementAttribute(element2, realAttrName, expression);
            this.domManager.registerDomDependency(expression, element2, {
              type: "attribute",
              attribute: realAttrName,
              expression
            });
            element2.removeAttribute(attr.name);
          }
        }
      }
    }
    /**
     * Updates the value of a DOM element's attribute based on the current
     * state of the model store.
     *
     * Dynamically handles specific attributes like `class`, `disabled`,
     * `checked`, `selected`, and `readonly` to ensure they're properly assigned
     * for Boolean or string values. For other attributes, it assigns the value
     * directly.
     *
     * If the value for the given expression can't be resolved from the model store,
     * a warning is logged to the console.
     *
     * @param {HTMLElement} element - The DOM element whose attribute is being updated.
     * @param {string} attribute - The name of the attribute to update.
     * @param {string} expression - The model store expression to retrieve the value.
     */
    updateElementAttribute(element2, attribute, expression) {
      const value = "" + this.model.store.get(expression);
      if (value === void 0 || value === "undefined") {
        return;
      }
      Logger.debug(`AttributeManager: Updating attribute ${attribute} with ${value}`);
      if (attribute === "class") {
        element2.className = value;
      } else if (attribute === "disabled" || attribute === "checked" || attribute === "selected" || attribute === "readonly") {
        if (value) {
          element2.setAttribute(attribute, "");
        } else {
          element2.removeAttribute(attribute);
        }
      } else {
        element2.setAttribute(attribute, value);
      }
    }
    update(element2, attribute, expression) {
      Logger.debug(`AttributeManager: Updating element:`, element2);
      Logger.debug(`	 Attribute: ${attribute} for:`, expression);
      this.updateAttributes(element2, attribute, expression);
      this.updateElementAttribute(element2, attribute, expression);
    }
  };
  var EventManager = class {
    /**
     * Creates a copy of the event manager
     * @param {Object} domManager - DOM manager for working with DOM elements
     * @param {Object} model - Data model that will be used as a context in events
     */
    constructor(domManager, model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("EventManager: Init EventManager");
      this.domManager = domManager;
      this.model = model;
      this.eventHandlers = /* @__PURE__ */ new Map();
      Logger.debug("EventManager: EventManager initialized");
    }
    /**
     * Analyzes DOM-Vreyevo and finds all attributes starting with @,
     * Registering them as events
     * @param {HTMLElement} rootElement - Root element for searching for events
     */
    parseEvents(rootElement) {
      Logger.debug("EventManager: Parsing events with @...");
      const allElements = rootElement.querySelectorAll("*");
      const elements = [rootElement, ...Array.from(allElements)];
      elements.forEach((element2) => {
        const attributes = Array.from(element2.attributes || []);
        attributes.forEach((attr) => {
          if (attr.name.startsWith("@")) {
            Logger.debug(`EventManager: Found attribute with "@" ${attr.name} in`, element2);
            const eventName = attr.name.substring(1);
            const handler = attr.value.trim();
            this.bindEventHandler(element2, eventName, handler);
            element2.removeAttribute(attr.name);
          }
        });
      });
    }
    /**
     * Binds the event handler to the DOM element
     * @param {HTMLElement} element - DOM element
     * @param {string} eventName - Event name (without @)
     * @param {string} handlerExpression - Line with an event processor
     */
    bindEventHandler(element2, eventName, handlerExpression) {
      Logger.debug(`EventManager: Binding event handler with expression ${handlerExpression} for ${eventName} on`, element2);
      const eventHandler = (event) => {
        try {
          const context = {
            $model: this.model,
            $event: event,
            $data: this.model.data,
            $dom: this.domManager
          };
          const methodMatch = handlerExpression.match(/(\w+)\((.*)\)/);
          if (methodMatch) {
            const methodName = methodMatch[1];
            const paramsString = methodMatch[2];
            const resolveMethod = (path, context2) => {
              return path.split(".").reduce((obj, key) => obj && obj[key] !== void 0 ? obj[key] : void 0, context2);
            };
            let method = resolveMethod(methodName, this.model);
            if (!method) {
              method = resolveMethod(methodName, window);
            }
            if (typeof method === "function") {
              let params = [];
              if (paramsString.trim()) {
                params = paramsString.split(",").map((param) => {
                  param = param.trim();
                  if (param.startsWith('"') && param.endsWith('"') || param.startsWith("'") && param.endsWith("'")) {
                    return param.slice(1, -1);
                  }
                  if (!isNaN(param)) {
                    return Number(param);
                  }
                  if (param === "$event") {
                    Logger.debug(`EventManager: Requested Event`, event);
                    return event;
                  }
                  if (param === "$model") {
                    Logger.debug(`EventManager: Requested Model`, this.model);
                    return this.model;
                  }
                  if (param === "$data") {
                    Logger.debug(`EventManager: Requested Model Context`, this.model.data);
                    return this.model.data;
                  }
                  if (param === "$dom") {
                    Logger.debug(`EventManager: Requested DOMManager`, this.domManager);
                    return this.domManager;
                  }
                  return this.model.store.get(param);
                });
              }
              method.apply(context, params);
            } else {
              console.warn(`EventManager: The method '${methodName}' not found in a model or global space!`);
            }
          } else {
            if (this.model.options.useSimpleExpressions) {
              const result = new Function(`return ${handlerExpression}`);
              result.apply(this.model.data);
            } else {
              console.warn(`EventManager: Unknown format of the event handler: '${handlerExpression}'`);
            }
          }
        } catch (error) {
          console.error(`EventManager: Error when performing an event processor '${eventName}': ${error.message}`);
        }
      };
      if (!this.eventHandlers.has(element2)) {
        this.eventHandlers.set(element2, /* @__PURE__ */ new Map());
      }
      const elementHandlers = this.eventHandlers.get(element2);
      if (elementHandlers.has(eventName)) {
        element2.removeEventListener(eventName, elementHandlers.get(eventName));
      }
      elementHandlers.set(eventName, eventHandler);
      element2.addEventListener(eventName, eventHandler);
    }
    /**
     * Removes the event processor from the DOM element
     * @param {HTMLElement} element - DOM element
     * @param {string} eventName - Event name (without @)
     */
    removeEventHandler(element2, eventName) {
      Logger.debug(`EventManager: Removing event handler for ${eventName} on`, element2);
      if (this.eventHandlers.has(element2)) {
        const elementHandlers = this.eventHandlers.get(element2);
        if (elementHandlers.has(eventName)) {
          const handler = elementHandlers.get(eventName);
          element2.removeEventListener(eventName, handler);
          elementHandlers.delete(eventName);
          if (elementHandlers.size === 0) {
            this.eventHandlers.delete(element2);
          }
        }
      }
    }
    /**
     * Updates events for the element
     * @param {HTMLElement} element - DOM element for updating
     */
    updateEvents(element2) {
      Logger.debug("EventManager: Updating events for", element2);
      Array.from(element2.attributes || []).forEach((attr) => {
        if (attr.name.startsWith("@")) {
          const eventName = attr.name.substring(1);
          const handler = attr.value.trim();
          this.bindEventHandler(element2, eventName, handler);
          element2.removeAttribute(attr.name);
        }
      });
    }
    /**
     * Releases all resources and removes all events
     */
    destroy() {
      Logger.debug("EventManager: Destroying EventManager");
      this.eventHandlers.forEach((handlers, element2) => {
        handlers.forEach((handler, eventName) => {
          Logger.debug(`EventManager: Removing event handler for ${eventName} on`, element2);
          element2.removeEventListener(eventName, handler);
        });
      });
      this.eventHandlers.clear();
      Logger.debug("EventManager: Destroyed");
    }
  };
  var DOMManager = class {
    /**
     * Creates an instance of the DOMManager class, initializing necessary properties and dependencies
     * for managing the DOM in relation to the model. Sets up managers for loops, conditionals, and attributes,
     * and prepares structures for DOM dependencies and virtual DOM.
     *
     * @param {Object} model - The model that serves as the data source for the DOMManager.
     *                         It is used for data binding and template rendering in the DOM.
     */
    constructor(model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("DOMManager: Init DOMManager");
      this.model = model;
      this.elements = [];
      this.inputs = [];
      this.domDependencies = /* @__PURE__ */ new Map();
      this.virtualDom = /* @__PURE__ */ new Map();
      this.loopManager = new LoopManager(this, model);
      this.conditionalManager = new ConditionalManager(this, model);
      this.attributeManager = new AttributeManager(this, model);
      this.eventManager = new EventManager(this, model);
      Logger.debug("DOMManager: DOMManager initialized");
    }
    /**
     * Registers a dependency between a model property path and a DOM element.
     * - Creates a new Set for the property path if it doesn't exist
     * - Adds element and additional info to the dependency set
     * - Supports multiple elements depending on the same property
     *
     * @param {string} propertyPath - Model property path to watch
     * @param {HTMLElement} domElement - DOM element to update
     * @param {Object} info - Additional dependency metadata
     */
    registerDomDependency(propertyPath, domElement, info4) {
      if (!this.domDependencies.has(propertyPath)) {
        this.domDependencies.set(propertyPath, /* @__PURE__ */ new Set());
      }
      this.domDependencies.get(propertyPath).add({
        element: domElement,
        ...info4
      });
    }
    /**
     * Recursively processes template nodes and replaces placeholders with values.
     * - Handles text nodes: replaces {{expression}} with actual values
     * - For text nodes: compares original and new content to avoid unnecessary updates
     * - For element nodes: recursively processes all child nodes
     * - Supports both context values and model store values
     *
     * @param {Node} node - DOM node to process
     * @param {Object} context - Optional context data for placeholder replacement
     */
    processTemplateNode(node, context) {
      Logger.debug("DOMManager: processTemplateNode", { node, context });
      if (node.nodeType === Node.TEXT_NODE) {
        const originalText = node.textContent;
        const newText = node.textContent.replace(/\{\{\s*([^}]+)\s*\}\}/g, (match, path) => {
          path = path.trim();
          const getValueByPath = (obj, path2) => {
            return path2.split(".").reduce((value2, key) => {
              return value2 ? value2[key] : void 0;
            }, obj);
          };
          let value = context ? getValueByPath(context, path) : void 0;
          if (value === void 0) {
            value = this.model.store.get(path);
          }
          return value !== void 0 ? value : "";
        });
        if (originalText !== newText) {
          Logger.debug(`DOMManager: updated node text from ${originalText} to ${newText}`);
          node.textContent = newText;
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        Array.from(node.childNodes).forEach((child) => {
          this.processTemplateNode(child, context);
        });
      }
    }
    /**
     * Parses DOM tree for template placeholders and sets up reactive bindings.
     * - Uses TreeWalker to efficiently traverse text nodes
     * - Detects template expressions using regex pattern
     * - Registers dependencies for each found template expression
     * - Preserves original template text for future updates
     * - Handles regex state reset between matches
     *
     * @param {HTMLElement} root - Starting point for DOM traversal
     */
    parse(root) {
      Logger.debug("DOMManager: parse from", root);
      const walker = document.createTreeWalker(
        root,
        NodeFilter.SHOW_TEXT,
        null
      );
      let node;
      const regex = /\{\{\s*([^}]+)\s*\}\}/g;
      while (node = walker.nextNode()) {
        let match;
        const text = node.textContent;
        const originalText = text;
        regex.lastIndex = 0;
        while ((match = regex.exec(text)) !== null) {
          Logger.debug(`DOMManager: parse match found for ${text}`, match);
          const propPath = match[1].trim();
          this.registerDomDependency(propPath, node, {
            type: "template",
            template: originalText
          });
          this.elements.push({
            node,
            propName: propPath,
            template: originalText
          });
        }
        Logger.debug(`DOMManager: update virtual DOM set`, { node, text: node.textContent });
        this.virtualDom.set(node, node.textContent);
      }
      Logger.debug("DOMManager: Find inputs with data-model directive...");
      const inputs = root.querySelectorAll("[data-model]");
      Logger.debug("DOMManager: Found inputs with data-model:", inputs.length);
      inputs.forEach((input) => {
        const property = input.getAttribute("data-model");
        Logger.debug("DOMManager: Register handler for:", { input, property });
        const handler = (e2) => {
          const value = input.type === "checkbox" || input.type === "radio" ? e2.target.checked : e2.target.value;
          this.model.store.set(property, value);
        };
        input.__modelInputHandler = handler;
        input.addEventListener("input", handler);
        this.inputs.push({
          element: input,
          property
        });
      });
    }
    /**
     * Sets the value of the input element based on the provided value.
     * For checkboxes and radio buttons, it sets the `checked` property.
     * For other input types, it sets the `value` property.
     *
     * @param {HTMLInputElement} input - The input element to update.
     * @param {*} value - The value to set for the input. For checkboxes and radio buttons, it should be a boolean.
     */
    setInputValue(input, value) {
      if (input.type === "checkbox" || input.type === "radio") {
        input.checked = Boolean(value);
      } else {
        input.value = value;
      }
    }
    /**
     * Updates all input elements associated with the specified property with the provided value.
     * It ensures that the value in the DOM accurately reflects the value in the model.
     *
     * @param {string} propName - The name of the property whose value should be updated in the inputs.
     * @param {*} value - The value to set for the associated inputs.
     */
    updateInputs(propName, value) {
      Logger.debug("DOMManager: updateInputs", { propName, value });
      this.inputs.forEach((item) => {
        if (item.property === propName) {
          Logger.debug("DOMManager: update input", { item, value });
          this.setInputValue(item.element, value);
        }
      });
    }
    /**
     * Updates all DOM elements based on the current state of the model.
     * This includes:
     * - Text nodes containing template placeholders.
     * - Input elements bound using `data-model` attributes.
     *
     * Iterates through registered nodes and inputs, updating their content
     * or values to reflect the latest model state.
     *
     * Ensures that the UI remains synchronized with the underlying model.
     */
    updateAllDOM() {
      Logger.debug("DOMManager: updateAllDOM");
      this.elements.forEach((element2) => {
        let newContent = element2.template;
        newContent = newContent.replace(/\{\{\s*([^}]+)\s*\}\}/g, (match, path) => {
          path = path.trim();
          return this.model.store.get(path);
        });
        element2.node.textContent = newContent;
        Logger.debug(`DOMManager: updated node`, { element: element2, newContent });
      });
      Logger.debug("DOMManager: update inputs");
      this.inputs.forEach((item) => {
        Logger.debug("DOMManager: update input", { item });
        const value = this.model.store.get(item.property);
        this.setInputValue(item.element, value);
        Logger.debug("DOMManager: updated input", { item, value });
      });
    }
    /**
     * Updates the DOM elements or attributes whenever a property in the model changes.
     * It resolves what elements depending on the property should be updated,
     * including templates, conditionals, loops, and attributes.
     *
     * @param {string} propertyPath - Path of the property in the model that triggered the change.
     * @param {*} value - New value of the property (could be a primitive, object, or array).
     */
    updateDOM(propertyPath, value) {
      Logger.debug(`DOMManager: update DOM for ${propertyPath} with ${value}`);
      if (!propertyPath) {
        console.warn("Path is undefined in updateDOM");
        return;
      }
      const isArrayMethodChange = value && typeof value === "object" && "method" in value;
      if (isArrayMethodChange) {
        propertyPath = value.path || propertyPath;
      }
      const elementsToUpdate = /* @__PURE__ */ new Set();
      if (this.domDependencies.has(propertyPath)) {
        this.domDependencies.get(propertyPath).forEach(
          (dep) => elementsToUpdate.add(dep)
        );
      }
      const pathParts = propertyPath.split(".");
      let currentPath = "";
      for (let i3 = 0; i3 < pathParts.length; i3++) {
        currentPath = currentPath ? `${currentPath}.${pathParts[i3]}` : pathParts[i3];
        if (this.domDependencies.has(currentPath)) {
          this.domDependencies.get(currentPath).forEach(
            (dep) => elementsToUpdate.add(dep)
          );
        }
      }
      const conditionalElements = this.conditionalManager.getDependenciesByPath(propertyPath);
      conditionalElements.forEach((dep) => {
        if (dep.type === "if") {
          this.conditionalManager.updateConditional(dep.element, dep.expression);
        }
      });
      this.domDependencies.forEach((deps, path) => {
        if (path.startsWith(`${propertyPath}.`) || path.startsWith(`${propertyPath}[`)) {
          deps.forEach((dep) => elementsToUpdate.add(dep));
        }
      });
      if (Array.isArray(value) || isArrayMethodChange || typeof value === "object") {
        this.loopManager.updateLoops(propertyPath, value);
      }
      if (elementsToUpdate.size === 0) return;
      const updates = {
        template: [],
        conditional: [],
        loop: [],
        attribute: []
      };
      elementsToUpdate.forEach((dep) => {
        if (dep && dep.type) {
          updates[dep.type].push(dep);
        }
      });
      updates.template.forEach((dep) => this.updateTemplateNode(dep.element, dep.template));
      updates.conditional.forEach((dep) => this.conditionalManager.updateConditional(dep.element, dep.expression));
      updates.attribute.forEach((dep) => this.attributeManager.update(dep.element, dep.attribute, dep.expression));
      updates.loop.forEach((dep) => this.loopManager.updateLoopPart(dep.element, dep.arrayPath, value, dep.index));
    }
    /**
     * Updates a template-based DOM node's content with the latest values
     * from the model store.
     *
     * This method uses a Mustache-like syntax (for example, `{{propertyName}}`)
     * to replace placeholders in the template with actual values retrieved
     * from the model store. If the content changes compared to the virtual DOM,
     * the DOM node is updated, and the new content is recorded in the virtual DOM.
     *
     * @param {HTMLElement} node - The DOM node to update.
     * @param {string} template - The template string containing placeholders
     *                            for dynamic values.
     */
    updateTemplateNode(node, template) {
      const newContent = template.replace(/\{\{\s*([^}]+)\s*\}\}/g, (match, path) => {
        path = path.trim();
        return this.model.store.get(path);
      });
      if (this.virtualDom.get(node) !== newContent) {
        node.textContent = newContent;
        this.virtualDom.set(node, newContent);
      }
    }
    /**
     * Checks whether the given pathA is a dependency of pathB.
     *
     * A path is considered a dependency if:
     * - It is identical to the other path.
     * - It is a hierarchical descendent of the other path (for example, pathB starts with pathA).
     * - It is an array element of the other path (for example, pathB starts with pathA followed by an array index).
     *
     * @param {string} pathA - The base path to check against.
     * @param {string} pathB - The path to verify as a dependency.
     * @returns {boolean} - Returns `true` if pathB is a dependency of pathA, otherwise `false`.
     */
    isPathDependency(pathA, pathB) {
      return pathB === pathA || pathB.startsWith(`${pathA}.`) || pathB.startsWith(`${pathA}[`);
    }
    /**
     * Retrieves all paths from the DOM dependency tracker that are
     * dependent on the given path. A path is considered dependent if:
     * - It is hierarchically related (for example, a path starts with the given path).
     * - It matches exactly with the given path.
     *
     * This method collects and returns all such dependent paths.
     *
     * @param {string} path - The path for which to find dependent paths.
     * @returns {string[]} - An array of dependent paths.
     */
    getDependentPaths(path) {
      const dependentPaths = [];
      this.domDependencies.forEach((_4, depPath) => {
        if (this.isPathDependency(path, depPath)) {
          dependentPaths.push(depPath);
        }
      });
      return dependentPaths;
    }
    /**
     * Binds and processes the DOM for data binding, conditional rendering,
     * loops, and attribute updates. This method integrates the different
     * managers and processes involved in setting up the live DOM bindings.
     *
     * Steps performed:
     * 1. Parses loops within the DOM using the loop manager.
     * 2. Parses conditional elements using the conditional manager.
     * 3. Parses standard attributes using the attribute manager.
     * 4. Processes custom attribute bindings (colon-prefixed attributes).
     * 5. Parses any additional elements or bindings.
     * 6. Updates the DOM to reflect the current state of the model.
     *
     * @param {HTMLElement} rootElement - The root element to initiate the DOM binding process.
     */
    bindDOM(rootElement) {
      Logger.debug("DOMManager: bind DOM from", rootElement);
      this.loopManager.parseLoops(rootElement);
      this.conditionalManager.parseConditionals(rootElement);
      this.attributeManager.parseAttributesBind(rootElement);
      this.attributeManager.parseAttributes(rootElement);
      this.eventManager.parseEvents(rootElement);
      this.parse(rootElement);
      this.updateAllDOM();
      Logger.debug("DOMManager: binding completed");
    }
    /**
     * Destroys the instance by performing cleanup tasks.
     *
     * This method removes event listeners from input elements, clears out
     * internal data structures like `elements`, `inputs`, `domDependencies`,
     * and `virtualDom`, and calls the `destroy` methods of `loopManager` and
     * `conditionalManager`. It is intended to completely clean up the instance
     * and free resources to avoid memory leaks.
     */
    destroy() {
      this.inputs.forEach(({ element: element2 }) => {
        if (element2.__modelInputHandler) {
          element2.removeEventListener("input", element2.__modelInputHandler);
          delete element2.__modelInputHandler;
        }
      });
      this.elements = [];
      this.inputs = [];
      this.domDependencies.clear();
      this.virtualDom.clear();
      this.loopManager.destroy();
      this.conditionalManager.destroy();
      this.eventManager.destroy();
      Logger.debug("DOMManager: destroyed");
    }
  };
  var ComputedProps = class {
    constructor(model, computed = {}) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("Model: Init ComputedProps:", computed);
      this.model = model;
      this.computed = computed;
      this.store = model.store;
      this.asyncCache = /* @__PURE__ */ new Map();
      this.init().then(() => {
        Object.getOwnPropertyNames(this.computed).forEach((prop) => {
          if (typeof this.computed[prop]["getter"] === "function") {
            try {
              const value = this.computed[prop]["getter"].call(this.store.getState());
              Logger.debug(`Initializing computed property ${prop}:`, value);
            } catch (e2) {
              console.error(`Error initializing computed property ${prop}:`, e2);
            }
          }
        });
        Logger.debug("Model: ComputedProps initialized");
      });
    }
    /**
     * Sets up computed properties in the model.
     * - Performs initial evaluation of all computed properties
     * - Defines getter proxies on model.data
     * - Makes computed properties enumerable and configurable
     * - Ensures reactive updates through getter access
     *
     * @method init
     */
    async init() {
      const initPromises = [];
      for (const key in this.computed) {
        const valuePromise = this.evaluate(key);
        initPromises.push(valuePromise);
        Object.defineProperty(this.model.data, key, {
          get: () => {
            const computed = this.computed[key];
            return computed.isAsync ? this.asyncCache.get(key) : computed.value;
          },
          enumerable: true,
          configurable: true
        });
      }
      await Promise.all(initPromises);
      for (const key in this.computed) {
        const value = this.computed[key].isAsync ? this.asyncCache.get(key) : this.computed[key].value;
        this.model.dom.updateDOM(key, value);
        this.model.dom.updateInputs(key, value);
      }
      return true;
    }
    /**
     * Evaluates computed property and tracks its dependencies.
     * - Creates proxy for dependency tracking
     * - Handles nested object dependencies
     * - Records all accessed properties during evaluation
     * - Emits computation events with results
     * - Supports forced re-evaluation
     *
     * @method evaluate
     * @param {string} key - Computed property name
     * @param {boolean} [force=false] - Force re-evaluation flag
     * @returns {*} New computed value
     * @emits compute
     */
    async evaluate(key, force = false) {
      const computed = this.computed[key];
      const dependencies = /* @__PURE__ */ new Set();
      const dataTracker = new Proxy(this.store.getState(), {
        get: (target, prop) => {
          dependencies.add(prop);
          let value = target[prop];
          if (value && typeof value === "object") {
            return new Proxy(value, {
              get: (obj, nestedProp) => {
                dependencies.add(`${prop}.${nestedProp}`);
                return obj[nestedProp];
              }
            });
          }
          return value;
        }
      });
      const isAsync = computed.getter.constructor.name === "AsyncFunction";
      computed.isAsync = isAsync;
      try {
        const result = await computed.getter.call(dataTracker);
        computed.dependencies = [...dependencies];
        if (isAsync) {
          this.asyncCache.set(key, result);
        } else {
          computed.value = result;
        }
        this.store.emit("compute", {
          key,
          value: result,
          dependencies,
          isAsync
        });
        return result;
      } catch (error) {
        console.error(`Error evaluating computed property "${key}":`, error);
        throw error;
      }
    }
    /**
     * Updates computed properties affected by model changes.
     * Checks three types of dependencies:
     * - Direct property matches
     * - Nested property changes (parent changed)
     * - Parent property changes (child changed)
     * Re-evaluates affected computed properties
     *
     * @method update
     * @param {string} changedProp - Changed property path
     */
    async update(changedProp) {
      const updatePromises = [];
      for (const key in this.computed) {
        const updatePromise = (async () => {
          const newValue = await this.evaluate(key);
          this.model.dom.updateDOM(key, newValue);
          this.model.dom.updateInputs(key, newValue);
        })();
        updatePromises.push(updatePromise);
      }
      await Promise.all(updatePromises);
    }
    /**
     * @method all
     * @description Retrieves all computed properties and their current values.
     * Converts the `computed` object into a plain object, mapping each computed
     * property's name to its current value.
     *
     * @returns {Object} An object containing all computed property names and their values.
     */
    all() {
      return Object.fromEntries(
        Object.entries(this.computed).map(([key, comp]) => [key, comp.value])
      );
    }
  };
  var StateManager = class _StateManager extends event_emitter_default {
    /**
     * Creates a new StateManager instance.
     * @param {Object} store - The store object to manage state for.
     * @param {Object} [options={}] - Configuration options for the StateManager.
     * @param {string} [options.id="model"] - Unique identifier for the state in localStorage.
     */
    constructor(store, options = {}) {
      Logger.DEBUG_LEVEL = store.model.options.debug ? 4 : 0;
      Logger.debug("Model: Init StateManager:", options);
      super();
      this.store = store;
      this.options = Object.assign({ id: "model" }, options);
      Logger.debug("Model: StateManager initialized");
    }
    /**
     * Checks if localStorage is available.
     * @returns {boolean}
     */
    static isStorageAvailable() {
      try {
        const test2 = "__test__";
        localStorage.setItem(test2, test2);
        localStorage.removeItem(test2);
        return true;
      } catch (e2) {
        return false;
      }
    }
    /**
     * Saves the current state to localStorage.
     * @returns {{data: any, timestamp: number}|null}
     */
    saveState() {
      if (!_StateManager.isStorageAvailable()) {
        console.warn("localStorage is not available");
        return null;
      }
      const dataToSave = JSON.parse(JSON.stringify(this.store.getState()));
      const state2 = {
        data: dataToSave,
        timestamp: Date.now()
      };
      try {
        localStorage.setItem(this.options.id, JSON.stringify(state2));
        this.emit("saveState", state2);
        return state2;
      } catch (error) {
        console.error("Error saving state:", error);
        this.emit("saveStateError", error);
        return null;
      }
    }
    /**
     * Restores the state from localStorage.
     * @returns {any|null}
     */
    restoreState() {
      if (!_StateManager.isStorageAvailable()) {
        console.warn("localStorage is not available");
        return null;
      }
      try {
        const savedState = localStorage.getItem(this.options.id);
        if (savedState) {
          const parsed = JSON.parse(savedState);
          Object.assign(this.store.state, parsed.data);
          this.emit("restoreState", parsed);
          return parsed;
        }
      } catch (error) {
        this.emit("restoreStateError", error);
      }
    }
    /**
     * Creates a snapshot of the current state.
     * @returns {{data: any, timestamp: number}|null}
     */
    createSnapshot() {
      if (!_StateManager.isStorageAvailable()) {
        console.warn("localStorage is not available");
        return null;
      }
      const dataToSave = JSON.parse(JSON.stringify(this.store.getState()));
      const snapshot = {
        data: dataToSave,
        timestamp: Date.now()
      };
      this.emit("createSnapshot", snapshot);
      return snapshot;
    }
    /**
     * Restores the state from a snapshot.  
     * @param snapshot
     * @returns {*|null}
     */
    restoreSnapshot(snapshot) {
      if (!_StateManager.isStorageAvailable()) {
        console.warn("localStorage is not available");
        return null;
      }
      if (snapshot) {
        Object.assign(this.store.state, snapshot.data);
        this.emit("restoreSnapshot", snapshot);
        return snapshot;
      }
      return null;
    }
    /**
     * Enables automatic state-saving at a specified interval.
     * @param interval
     */
    enableAutoSave(interval = 5e3) {
      this.autoSaveInterval = setInterval(() => {
        this.saveState();
      }, interval);
    }
    /**
     * Disables automatic state-saving.
     */
    disableAutoSave() {
      clearInterval(this.autoSaveInterval);
    }
  };
  var ModelOptions = {
    id: "model",
    useSimpleExpressions: true,
    debug: false
  };
  var Model2 = class _Model extends event_emitter_default {
    /**
     * A map for storing registered plugins.
     * @type {Map<string, Function>}
     */
    static plugins = /* @__PURE__ */ new Map();
    /**
     * Creates a new instance of the Model class.
     * @param {Object} [data={}] - Initial data for the model.
     * @param {Object} [options={}] - Configuration options for the model.
     */
    constructor(data = {}, options = {}) {
      super();
      this.options = Object.assign({}, ModelOptions, options);
      Logger.DEBUG_LEVEL = this.options.debug ? 4 : 0;
      Logger.debug("Model: Creating a model with data:", data);
      Logger.debug("Model: Configuration options:", options);
      this.computed = {};
      for (const key in data) {
        if (typeof data[key] === "function") {
          Logger.debug(`Model: Registration calculated property "${key}"`);
          this.computed[key] = {
            getter: data[key],
            value: null,
            dependencies: []
          };
          delete data[key];
        }
      }
      this.store = new ReactiveStore(data, this);
      this.data = this.store.state;
      this.dom = new DOMManager(this);
      this.computedProps = new ComputedProps(this, this.computed);
      this.stateManager = new StateManager(this.store);
      this.subscribe();
      Logger.debug("Model: The model was created successfully!");
    }
    /**
     * Subscribes to changes from the ReactiveStore and handles DOM updates,
     * input field updates, and computed properties recalculation.
     */
    subscribe() {
      Logger.debug("Model: Subscribing to store changes");
      this.store.on("change", (data) => {
        this.dom.updateDOM(data.path, data.newValue);
        this.dom.updateInputs(data.path, data.newValue);
        this.computedProps.update(data.path).then(() => {
        });
        this.emit("change", data);
      });
      this.store.on("compute", (data) => this.emit("compute", data));
      this.store.on("arrayChange", (data) => this.emit("arrayChange", data));
      this.store.on("batchComplete", (data) => this.emit("batchComplete", data));
      Logger.debug("Model: Subscribing to state manager events");
      this.stateManager.on("saveState", (data) => this.emit("saveState", data));
      this.stateManager.on("saveStateError", (error) => this.emit("saveStateError", error));
      this.stateManager.on("restoreState", (data) => this.emit("restoreState", data));
      this.stateManager.on("restoreStateError", (error) => this.emit("restoreStateError", error));
      this.stateManager.on("createSnapshot", (data) => this.emit("createSnapshot", data));
      this.stateManager.on("restoreSnapshot", (data) => this.emit("restoreSnapshot", data));
    }
    /**
     * Adds a validator function to a specified path.
     * @param {string} path - Path within the state to attach the validator.
     * @param {Function} validator - Validation function to execute on path changes.
     */
    addValidator(path, validator) {
      this.store.addValidator(path, validator);
    }
    /**
     * Adds a formatter function to a specified path.
     * @param {string} path - Path within the state to attach the formatter.
     * @param {Function} formatter - Formatting function to execute on path changes.
     */
    addFormatter(path, formatter) {
      this.store.addFormatter(path, formatter);
    }
    /**
     * Adds middleware to the ReactiveStore for intercepting and processing state changes.
     * @param {Function} middleware - Middleware function that receives and can modify state changes before they're applied.
     */
    use(middleware) {
      this.store.use(middleware);
    }
    /**
     * Watches a specific path in the state and triggers a callback on changes.
     * @param {string} path - Path to watch.
     * @param {Function} callback - Callback function to execute when the path changes.
     */
    watch(path, callback) {
      this.store.watch(path, callback);
    }
    /**
     * Executes a batch of state changes in a single update cycle.
     * @param callback
     */
    batch(callback) {
      return this.store.batch(callback);
    }
    /**
     * Detects changes between two arrays and returns the differences.
     * @param newArray
     * @param oldArray
     * @returns {{added: [], removed: [], moved: []}}
     */
    diffArrays(newArray, oldArray) {
      return this.store.detectArrayChanges(newArray, oldArray);
    }
    diff() {
    }
    /**
     * Validates the model for potential issues, including:
     *
     * 1. Cyclic dependencies in computed properties: Ensures that no property in the `computed`
     *    object of the model depends on itself through a chain of other properties.
     * 2. Invalid paths in DOM dependencies: Ensures that all paths used in the DOM template
     *    exist within the model's store.
     *
     * @returns {{errors: Array<Object>, warnings: Array<Object>}} - Returns an object containing arrays
     *          of errors and warnings. Each error or warning is represented as an object with details
     *          about the issue.
     *
     * Errors include:
     * - `CYCLIC_DEPENDENCY`: Indicates a cyclic dependency was found in `computed` properties.
     *   - `property`: The property with the cyclic dependency.
     *   - `message`: Description of the cyclic dependency.
     *
     * Warnings include:
     * - `INVALID_PATH`: Indicates a path used in the DOM does not exist in the model.
     *   - `path`: The invalid path.
     *   - `message`: Description of the invalid path.
     */
    validate() {
      const errors = [];
      const warnings = [];
      for (const key in this.computed) {
        const visited = /* @__PURE__ */ new Set();
        const cyclePath = this._checkCyclicDependencies(key, visited);
        if (cyclePath) {
          errors.push({
            type: "CYCLIC_DEPENDENCY",
            property: key,
            message: `Cyclic dependence is found: ${cyclePath.join(" -> ")}`
          });
        }
      }
      this.dom.domDependencies.forEach((deps, path) => {
        if (!this.store.isValidPath(path)) {
          warnings.push({
            type: "INVALID_PATH",
            path,
            message: `Property ${path} used in the template, but does not exist in the model`
          });
        }
      });
      return { errors, warnings };
    }
    /**
     * Checks for cyclic dependencies in the computed properties of the model.
     *
     * This method recursively traverses the dependencies of a given property to determine
     * if a cyclic dependency exists. A cyclic dependency occurs when a property ultimately
     * depends on itself through a chain of other properties.
     *
     * @param {string} key - The key of the property to check for cyclic dependencies.
     * @param {Set<string>} visited - A set of visited properties during the traversal.
     * @param {string[]} [path=[]] - The current path of dependencies being checked.
     * @returns {string[]|null} - Returns an array representing the cyclic path if a cycle is found,
     *                            otherwise `null`.
     */
    _checkCyclicDependencies(key, visited, path = []) {
      if (visited.has(key)) {
        return [...path, key];
      }
      visited.add(key);
      path.push(key);
      const computed = this.computed[key];
      if (!computed || !computed.dependencies) {
        return null;
      }
      for (const dep of computed.dependencies) {
        if (dep in this.computed) {
          const cyclePath = this._checkCyclicDependencies(dep, new Set(visited), [...path]);
          if (cyclePath) {
            return cyclePath;
          }
        }
      }
      return null;
    }
    /**
     * Validates a given path to check if it exists in the model's store.
     * @param path
     * @returns {boolean}
     */
    validatePath(path) {
      return this.store.isValidPath(path);
    }
    /**
     * Initializes the DOM bindings for the model.
     * @param {string|HTMLElement} selector - Selector or root element to bind on.
     * @returns {Model|undefined} - Returns the model instance, or undefined if the root element is not found.
     */
    init(selector) {
      Logger.debug("Model: Initializing DOM bindings");
      let rootElement = typeof selector === "string" ? document.querySelector(selector) : selector;
      if (!rootElement) {
        rootElement = document.body;
      }
      Logger.debug(`Model: Model initialized in ${selector ?? "body"}`);
      Logger.debug("Model: Binding DOM");
      this.dom.bindDOM(rootElement);
      this.emit("init");
      Logger.debug("Model: Initialization complete!");
      return this;
    }
    /**
     * Initializes development tools for the model.
     * @param {Object} [options={}] - Options for the development tools.
     * @returns {DevTools} - An instance of the DevTools class.
     */
    runDevTools(options = {}) {
      return new dev_tools_default(this, options);
    }
    /**
     * Saves the current state of the model.
     * @returns {{data: *, timestamp: number}|null}
     */
    save() {
      return this.stateManager.saveState();
    }
    /**
     * Restores the model to a previously saved state.
     * @returns {*|null}
     */
    restore() {
      return this.stateManager.restoreState();
    }
    /**
     * Creates a snapshot of the current state.
     * @param _snapshot
     * @returns {*|null|{data: *, timestamp: number}}
     */
    snapshot(_snapshot) {
      if (!_snapshot) {
        return this.stateManager.createSnapshot();
      }
      return this.stateManager.restoreSnapshot(s);
    }
    /**
     * Enables or disables auto-saving of the model's state.
     * @param interval
     */
    autoSave(interval) {
      if (!interval) {
        this.stateManager.disableAutoSave();
      } else {
        this.stateManager.enableAutoSave(interval);
      }
    }
    /**
     * Registers a plugin for the model.
     * @param {string} name - Name of the plugin.
     * @param {Function} plugin - Plugin class or constructor function.
     * @throws {Error} If a plugin with the same name is already registered.
     */
    static registerPlugin(name2, plugin) {
      if (_Model.plugins.has(name2)) {
        throw new Error(`Plugin ${name2} already registered`);
      }
      _Model.plugins.set(name2, plugin);
      this.emit("pluginRegistered", name2);
    }
    /**
     * Uses a registered plugin by name.
     * @param {string} name - Name of the plugin to use.
     * @param {Object} [options={}] - Options to pass to the plugin.
     * @returns {Model} - Returns the model instance to allow method chaining.
     */
    usePlugin(name2, options = {}) {
      const Plugin = _Model.plugins.get(name2);
      if (!Plugin) {
        console.error(`Plugin ${name2} not found`);
      }
      new Plugin(this, options);
      return this;
    }
    /**
     * Removes a registered plugin by name.
     * @param name
     */
    static removePlugin(name2) {
      if (_Model.plugins.has(name2)) {
        _Model.plugins.delete(name2);
        this.emit("pluginUnregistered", name2);
      }
    }
    /**
     * Destroys the model instance and cleans up resources.
     */
    destroy() {
      this.dom.destroy();
      this.store.destroy();
      this.emit("destroy");
    }
  };
  var model_default = Model2;
  var version4 = "0.17.0";
  var build_time4 = "06.03.2025, 13:09:45";
  model_default.info = () => {
    console.info(`%c Model %c v${version4} %c ${build_time4} `, "color: white; font-weight: bold; background: #0080fe", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  var index_default = model_default;

  // source/model/index.js
  globalThis.Model = index_default;

  // source/core/global.js
  (function($5) {
    "use strict";
    globalThis["__version__"] = "5.1.0";
    globalThis["__build_time__"] = "30.04.2025, 11:02:27";
    const meta_init = $5.meta("metro:init").attr("content");
    const meta_locale = $5.meta("metro:locale").attr("content");
    const meta_week_start = $5.meta("metro:week_start").attr("content");
    const meta_date_format = $5.meta("metro:date_format").attr("content");
    const meta_date_format_input = $5.meta("metro:date_format_input").attr("content");
    const meta_animation_duration = $5.meta("metro:animation_duration").attr("content");
    const meta_callback_timeout = $5.meta("metro:callback_timeout").attr("content");
    const meta_timeout = $5.meta("metro:timeout").attr("content");
    const meta_scroll_multiple = $5.meta("metro:scroll_multiple").attr("content");
    const meta_cloak = $5.meta("metro:cloak").attr("content");
    const meta_cloak_duration = $5.meta("metro:cloak_duration").attr("content");
    const meta_global_common = $5.meta("metro:global_common").attr("content");
    const meta_blur_image = $5.meta("metro:blur_image").attr("content");
    const meta_smooth_scroll = $5.meta("metro:smooth_scroll").attr("content");
    const meta_theme = $5.meta("metro:theme").attr("content");
    if (meta_theme !== void 0) {
      $5("html").addClass(meta_theme === "auto" ? $5.dark ? "dark-side" : "" : meta_theme === "dark" ? "dark-side" : "light-side");
    }
    if (globalThis["METRO_BLUR_IMAGE"] === void 0) {
      globalThis["METRO_BLUR_IMAGE"] = meta_blur_image !== void 0 ? JSON.parse(meta_global_common) : false;
    }
    if (globalThis["METRO_GLOBAL_COMMON"] === void 0) {
      globalThis["METRO_GLOBAL_COMMON"] = meta_global_common !== void 0 ? JSON.parse(meta_global_common) : false;
    }
    const meta_jquery = $5.meta("metro:jquery").attr("content");
    globalThis["jquery_present"] = typeof globalThis["jQuery"] !== "undefined";
    if (globalThis["METRO_JQUERY"] === void 0) {
      globalThis["METRO_JQUERY"] = meta_jquery !== void 0 ? JSON.parse(meta_jquery) : true;
    }
    globalThis["useJQuery"] = globalThis["jquery_present"] && globalThis["METRO_JQUERY"];
    const meta_info = $5.meta("metro:info").attr("content");
    if (globalThis["METRO_SHOW_INFO"] === void 0) {
      globalThis["METRO_SHOW_INFO"] = meta_info !== void 0 ? JSON.parse(meta_info) : true;
    }
    const meta_compile = $5.meta("metro:compile").attr("content");
    if (globalThis["METRO_SHOW_COMPILE_TIME"] === void 0) {
      globalThis["METRO_SHOW_COMPILE_TIME"] = meta_compile !== void 0 ? JSON.parse(meta_compile) : true;
    }
    if (globalThis["METRO_INIT"] === void 0) {
      globalThis["METRO_INIT"] = meta_init !== void 0 ? JSON.parse(meta_init) : true;
    }
    if (globalThis["METRO_DEBUG"] === void 0) {
      globalThis["METRO_DEBUG"] = true;
    }
    if (globalThis["METRO_WEEK_START"] === void 0) {
      globalThis["METRO_WEEK_START"] = meta_week_start !== void 0 ? parseInt(meta_week_start) : 0;
    }
    if (globalThis["METRO_DATE_FORMAT"] === void 0) {
      globalThis["METRO_DATE_FORMAT"] = meta_date_format !== void 0 ? meta_date_format : "YYYY-MM-DD";
    }
    if (globalThis["METRO_DATE_FORMAT_INPUT"] === void 0) {
      globalThis["METRO_DATE_FORMAT_INPUT"] = meta_date_format_input !== void 0 ? meta_date_format_input : "YYYY-MM-DD";
    }
    if (globalThis["METRO_LOCALE"] === void 0) {
      globalThis["METRO_LOCALE"] = meta_locale !== void 0 ? meta_locale : "en-US";
    }
    if (globalThis["METRO_ANIMATION_DURATION"] === void 0) {
      globalThis["METRO_ANIMATION_DURATION"] = meta_animation_duration !== void 0 ? parseInt(meta_animation_duration) : 100;
    }
    if (globalThis["METRO_CALLBACK_TIMEOUT"] === void 0) {
      globalThis["METRO_CALLBACK_TIMEOUT"] = meta_callback_timeout !== void 0 ? parseInt(meta_callback_timeout) : 500;
    }
    if (globalThis["METRO_TIMEOUT"] === void 0) {
      globalThis["METRO_TIMEOUT"] = meta_timeout !== void 0 ? parseInt(meta_timeout) : 2e3;
    }
    if (globalThis["METRO_SCROLL_MULTIPLE"] === void 0) {
      globalThis["METRO_SCROLL_MULTIPLE"] = meta_scroll_multiple !== void 0 ? parseInt(meta_scroll_multiple) : 20;
    }
    if (globalThis["METRO_CLOAK_REMOVE"] === void 0) {
      globalThis["METRO_CLOAK_REMOVE"] = meta_cloak !== void 0 ? ("" + meta_cloak).toLowerCase() : "fade";
    }
    if (globalThis["METRO_CLOAK_DURATION"] === void 0) {
      globalThis["METRO_CLOAK_DURATION"] = meta_cloak_duration !== void 0 ? parseInt(meta_cloak_duration) : 300;
    }
    if (globalThis["METRO_SMOOTH_SCROLL"] === void 0) {
      globalThis["METRO_SMOOTH_SCROLL"] = meta_smooth_scroll !== void 0 ? JSON.parse(meta_smooth_scroll) : true;
    }
    if (globalThis["METRO_HOTKEYS_FILTER_CONTENT_EDITABLE"] === void 0) {
      globalThis["METRO_HOTKEYS_FILTER_CONTENT_EDITABLE"] = true;
    }
    if (globalThis["METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS"] === void 0) {
      globalThis["METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS"] = true;
    }
    if (globalThis["METRO_HOTKEYS_FILTER_TEXT_INPUTS"] === void 0) {
      globalThis["METRO_HOTKEYS_FILTER_TEXT_INPUTS"] = true;
    }
    if (globalThis["METRO_HOTKEYS_BUBBLE_UP"] === void 0) {
      globalThis["METRO_HOTKEYS_BUBBLE_UP"] = false;
    }
    if (globalThis["METRO_THROWS"] === void 0) {
      globalThis["METRO_THROWS"] = true;
    }
    globalThis["METRO_MEDIA"] = [];
  })(Dom);

  // source/core/props.js
  var isTouch2 = "ontouchstart" in window;
  var Props = {
    controlsPosition: {
      INSIDE: "inside",
      OUTSIDE: "outside"
    },
    groupMode: {
      ONE: "one",
      MULTI: "multi"
    },
    aspectRatio: {
      HD: "hd",
      SD: "sd",
      CINEMA: "cinema"
    },
    fullScreenMode: {
      WINDOW: "window",
      DESKTOP: "desktop"
    },
    position: {
      TOP: "top",
      BOTTOM: "bottom",
      LEFT: "left",
      RIGHT: "right",
      TOP_RIGHT: "top-right",
      TOP_LEFT: "top-left",
      BOTTOM_LEFT: "bottom-left",
      BOTTOM_RIGHT: "bottom-right",
      LEFT_BOTTOM: "left-bottom",
      LEFT_TOP: "left-top",
      RIGHT_TOP: "right-top",
      RIGHT_BOTTOM: "right-bottom"
    },
    popoverEvents: {
      CLICK: "click",
      HOVER: "hover",
      FOCUS: "focus"
    },
    stepperView: {
      SQUARE: "square",
      CYCLE: "cycle",
      DIAMOND: "diamond"
    },
    listView: {
      LIST: "list",
      CONTENT: "content",
      ICONS: "icons",
      ICONS_MEDIUM: "icons-medium",
      ICONS_LARGE: "icons-large",
      TILES: "tiles",
      TABLE: "table"
    },
    events: {
      click: "click",
      start: isTouch2 ? "touchstart" : "mousedown",
      stop: isTouch2 ? "touchend" : "mouseup",
      move: isTouch2 ? "touchmove" : "mousemove",
      enter: isTouch2 ? "touchstart" : "mouseenter",
      startAll: "mousedown touchstart",
      stopAll: "mouseup touchend",
      moveAll: "mousemove touchmove",
      leave: "mouseleave",
      focus: "focus",
      blur: "blur",
      resize: "resize",
      keyup: "keyup",
      keydown: "keydown",
      keypress: "keypress",
      dblclick: "dblclick",
      input: "input",
      change: "change",
      cut: "cut",
      paste: "paste",
      scroll: "scroll",
      mousewheel: "mousewheel",
      inputchange: "change input propertychange cut paste copy drop",
      dragstart: "dragstart",
      dragend: "dragend",
      dragenter: "dragenter",
      dragover: "dragover",
      dragleave: "dragleave",
      drop: "drop",
      drag: "drag"
    },
    keyCode: {
      BACKSPACE: 8,
      TAB: 9,
      ENTER: 13,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      BREAK: 19,
      CAPS: 20,
      ESCAPE: 27,
      SPACE: 32,
      PAGEUP: 33,
      PAGEDOWN: 34,
      END: 35,
      HOME: 36,
      LEFT_ARROW: 37,
      UP_ARROW: 38,
      RIGHT_ARROW: 39,
      DOWN_ARROW: 40,
      COMMA: 188
    },
    media_queries: {
      FS: "(min-width: 0px)",
      XS: "(min-width: 360px)",
      SM: "(min-width: 576px)",
      LD: "(min-width: 640px)",
      MD: "(min-width: 768px)",
      LG: "(min-width: 992px)",
      XL: "(min-width: 1200px)",
      XXL: "(min-width: 1452px)",
      XXXL: "(min-width: 2000px)"
    },
    media_sizes: {
      FS: 0,
      XS: 360,
      SM: 576,
      LD: 640,
      MD: 768,
      LG: 992,
      XL: 1200,
      XXL: 1452,
      XXXL: 2e3
    },
    media_mode: {
      FS: "fs",
      XS: "xs",
      SM: "sm",
      LD: "ld",
      MD: "md",
      LG: "lg",
      XL: "xl",
      XXL: "xxl",
      XXXL: "xxxl"
    },
    media_modes: ["fs", "xs", "sm", "ld", "md", "lg", "xl", "xxl", "xxxl"],
    actions: {
      NONE: 0,
      REMOVE: 1,
      HIDE: 2,
      MINIMIZE: 3,
      MAXIMIZE: 4,
      CLOSE: 5,
      RESTORE: 6,
      SHOW: 7
    },
    theme: {
      LIGHT: "light",
      DARK: "dark"
    }
  };

  // source/core/metro.js
  (() => {
    "use strict";
    const $5 = Dom;
    if (typeof Dom === "undefined") {
      throw new Error("Metro UI requires Dom helper!");
    }
    if (!("MutationObserver" in window)) {
      throw new Error("Metro UI requires MutationObserver!");
    }
    const isTouch3 = "ontouchstart" in window || navigator["MaxTouchPoints"] > 0 || navigator["msMaxTouchPoints"] > 0;
    const normalizeComponentName = (name2) => typeof name2 !== "string" ? void 0 : name2.replace(/-/g, "").toLowerCase();
    const Metro2 = {
      version: "5.1.0",
      build_time: "30.04.2025, 11:02:27",
      buildNumber: 0,
      isTouchable: isTouch3,
      fullScreenEnabled: document.fullscreenEnabled,
      sheet: null,
      hotkeys: {},
      locales: {},
      utils: {},
      colors: {},
      dialog: null,
      pagination: null,
      md5: null,
      storage: null,
      export: null,
      animations: null,
      cookie: null,
      template: null,
      defaults: {},
      info: () => {
        if (typeof globalThis["METRO_LIB_INFO"] !== "undefined") {
          Metro2.welcome();
        }
      },
      welcome: () => {
        console.info(
          `%c METRO UI %c v${Metro2.version} %c ${Metro2.build_time} `,
          "color: pink; font-weight: bold; background: #800000",
          "color: white; background: darkgreen",
          "color: white; background: #0080fe;"
        );
        if (globalThis["$"] && $5.info) $5.info();
        if (globalThis["Hooks"] && Hooks.info) Hooks.info();
        if (globalThis["HTML"] && HTML.info) HTML.info();
        if (globalThis["Farbe"] && Farbe.info) Farbe.info();
        if (globalThis["Datetime"] && Datetime.info) Datetime.info();
        if (globalThis["Str"] && Str.info) Str.info();
        if (globalThis["G"] && G.info) G.info();
        if (globalThis["Router"] && Router.info) Router.info();
        if (globalThis["Model"] && Model.info) Model.info();
      },
      aboutDlg: () => {
        alert("Metro UI - v" + Metro2.version);
      },
      observe: () => {
        let observer, observerCallback;
        const observerConfig = {
          childList: true,
          attributes: true,
          subtree: true
        };
        observerCallback = (mutations) => {
          mutations.map((mutation) => {
            if (mutation.type === "attributes" && mutation.attributeName !== "data-role") {
              if (mutation.attributeName === "data-hotkey") {
                Metro2.initHotkeys([mutation.target], true);
              } else {
                const element2 = $5(mutation.target);
                const mc = element2.data("metroComponent");
                const attr = mutation.attributeName, newValue = element2.attr(attr), oldValue = mutation.oldValue;
                if (mc !== void 0) {
                  element2.fire("attr-change", {
                    attr,
                    newValue,
                    oldValue,
                    __this: element2[0]
                  });
                  $5.each(mc, function() {
                    const plug = Metro2.getPlugin(element2, this);
                    if (plug && typeof plug.changeAttribute === "function") {
                      plug.changeAttribute(attr, newValue, oldValue);
                    }
                  });
                }
              }
            } else if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
              let widgets = [], hotkeys = [], $node, node;
              const nodes = mutation.addedNodes;
              if (nodes.length) {
                for (let node2 of $5(nodes).find("[data-hotkey]")) {
                  hotkeys.push($5(node2));
                }
                for (let i3 = 0; i3 < nodes.length; i3++) {
                  node = nodes[i3];
                  $node = $5(node);
                  if ($node.attr("data-role") !== void 0) {
                    widgets.push(node);
                  }
                  $5.each($node.find("[data-role]"), function() {
                    if (widgets.indexOf(this) !== -1) {
                      return;
                    }
                    widgets.push(this);
                  });
                }
                if (widgets.length) Metro2.initWidgets(widgets, "observe");
                if (hotkeys.length) Metro2.initHotkeys(hotkeys);
              }
            } else {
            }
          });
        };
        observer = new MutationObserver(observerCallback);
        observer.observe($5("html")[0], observerConfig);
      },
      init: () => {
        const widgets = $5("[data-role]");
        const hotkeys = $5("[data-hotkey]");
        const html = $5("html");
        Metro2.i18n.load(html.attr("lang"));
        if (globalThis["METRO_SHOW_INFO"]) {
          Metro2.info(true);
        }
        if (isTouch3 === true) {
          html.addClass("touchable-device");
        }
        Metro2.sheet = Metro2.utils.newCssSheet();
        Metro2.utils.addCssRule(Metro2.sheet, "*, *::before, *::after", "box-sizing: border-box;");
        globalThis["METRO_MEDIA"] = [];
        $5.each(Metro2.media_queries, (key, query) => {
          if (Metro2.utils.media(query)) {
            globalThis["METRO_MEDIA"].push(Metro2.media_mode[key]);
          }
        });
        Metro2.observe();
        Metro2.initHotkeys(hotkeys);
        Metro2.initWidgets(widgets, "init");
        if (globalThis["METRO_CLOAK_REMOVE"] !== "fade") {
          $5(".m4-cloak").removeClass("m4-cloak");
          $5(".cloak").removeClass("cloak");
          $5(globalThis).fire("metro-initiated");
        } else {
          $5(".m4-cloak, .cloak").animate({
            draw: {
              opacity: [0, 1]
            },
            dur: 300,
            onDone: () => {
              $5(".m4-cloak").removeClass("m4-cloak");
              $5(".cloak").removeClass("cloak");
              $5(globalThis).fire("metro-initiated");
            }
          });
        }
        $5(document).on("click", "[data-copy-to-clipboard]", function() {
          const val = $5(this).attr("data-copy-to-clipboard");
          Metro2.utils.copy2clipboard(val);
          if (Metro2.toast) {
            Metro2.toast.create(`Data copied to clipboard!`);
          }
        });
        if (METRO_SMOOTH_SCROLL) {
          const smoothLinks = document.querySelectorAll('a.smooth-scroll[href^="#"]');
          for (const smoothLink of smoothLinks) {
            smoothLink.addEventListener("click", (e2) => {
              e2.preventDefault();
              const id = smoothLink.getAttribute("href");
              document.querySelector(id).scrollIntoView({
                behavior: "smooth",
                block: "start"
              });
            });
          }
        }
      },
      initHotkeys: (hotkeys, redefine) => {
        $5.each(hotkeys, function() {
          const element2 = $5(this);
          const hotkey = element2.attr("data-hotkey") ? element2.attr("data-hotkey").toLowerCase() : false;
          const fn = element2.attr("data-hotkey-func") ? element2.attr("data-hotkey-func") : false;
          if (hotkey === false) {
            return;
          }
          if (element2.data("hotKeyBonded") === true && redefine !== true) {
            return;
          }
          Metro2.hotkeys[hotkey] = [this, fn];
          element2.data("hotKeyBonded", true);
          element2.fire("hot-key-bonded", {
            __this: element2[0],
            hotkey,
            fn
          });
        });
      },
      initWidgets: (widgets) => {
        $5.each(widgets, function() {
          let $this = $5(this), roles;
          if (!this.hasAttribute("data-role")) {
            return;
          }
          roles = $this.attr("data-role").split(/\s*,\s*/);
          roles.map((func) => {
            const $$ = Metro2.utils.$();
            const _func = normalizeComponentName(func);
            if ($$.fn[_func] !== void 0 && $this.attr("data-role-" + _func) === void 0) {
              try {
                $$.fn[_func].call($this);
                $this.attr("data-role-" + _func, true);
                let mc = $this.data("metroComponent");
                if (mc === void 0) {
                  mc = [_func];
                } else {
                  mc.push(_func);
                }
                $this.data("metroComponent", mc);
                $this.fire("create", {
                  __this: $this[0],
                  name: _func
                });
                $5(document).fire("component-create", {
                  element: $this[0],
                  name: _func
                });
              } catch (e2) {
                console.error("Error creating component " + func + " for ", $this[0]);
                throw e2;
              }
            }
          });
        });
        Metro2.i18n.updateUI();
      },
      plugin: (name2, object) => {
        const _name = normalizeComponentName(name2);
        const register = ($6) => {
          $6.fn[_name] = function(options) {
            return this.each(function() {
              $6.data(this, _name, Object.create(object).init(options, this));
            });
          };
        };
        register(Dom);
        if (globalThis["useJQuery"]) {
          register(globalThis["jQuery"]);
        }
      },
      pluginExists: (name2) => {
        const $6 = globalThis["useJQuery"] ? globalThis["jQuery"] : Dom;
        return typeof $6.fn[normalizeComponentName(name2)] === "function";
      },
      destroyPlugin: (element2, name2) => {
        let p3, mc;
        const el = $5(element2);
        const _name = normalizeComponentName(name2);
        p3 = Metro2.getPlugin(el, _name);
        if (typeof p3 === "undefined") {
          console.warn("Component " + name2 + " can not be destroyed: the element is not a Metro UI component.");
          return;
        }
        if (typeof p3["destroy"] !== "function") {
          console.warn("Component " + name2 + " can not be destroyed: method destroy not found.");
          return;
        }
        p3["destroy"]();
        mc = el.data("metroComponent");
        Metro2.utils.arrayDelete(mc, _name);
        el.data("metroComponent", mc);
        $5.removeData(el[0], _name);
        el.removeAttr("data-role-" + _name);
      },
      destroyPluginAll: (element2) => {
        const el = $5(element2);
        const mc = el.data("metroComponent");
        if (mc !== void 0 && mc.length > 0)
          $5.each(mc, function() {
            Metro2.destroyPlugin(el[0], this);
          });
      },
      noop: () => {
      },
      noop_true: () => true,
      noop_false: () => false,
      noop_arg: (a3) => a3,
      requestFullScreen: (element2) => {
        if (element2["mozRequestFullScreen"]) {
          element2["mozRequestFullScreen"]();
        } else if (element2["webkitRequestFullScreen"]) {
          element2["webkitRequestFullScreen"]();
        } else if (element2["msRequestFullscreen"]) {
          element2["msRequestFullscreen"]();
        } else {
          element2.requestFullscreen().catch((err) => {
            console.warn("Error attempting to enable full-screen mode: " + err.message + " " + err.name);
          });
        }
      },
      exitFullScreen: () => {
        if (document["mozCancelFullScreen"]) {
          document["mozCancelFullScreen"]();
        } else if (document["webkitCancelFullScreen"]) {
          document["webkitCancelFullScreen"]();
        } else if (document["msExitFullscreen"]) {
          document["msExitFullscreen"]();
        } else {
          document.exitFullscreen().catch((err) => {
            console.warn("Error attempting to disable full-screen mode: " + err.message + " " + err.name);
          });
        }
      },
      inFullScreen: () => {
        const fsm = document.fullscreenElement || document["webkitFullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"];
        return fsm !== void 0;
      },
      $: () => globalThis["useJQuery"] ? globalThis["jQuery"] : Dom,
      get$el: (el) => Metro2.$()($5(el)[0]),
      get$elements: (el) => Metro2.$()($5(el)),
      // TODO add if name is not defined, return one or array of plugins
      getPlugin: (el, name2) => {
        const _name = normalizeComponentName(name2);
        const $el = Metro2.get$el(el);
        return $el.length ? $el.data(_name) : void 0;
      },
      makePlugin: (el, name2, options) => {
        const _name = normalizeComponentName(name2);
        const $el = Metro2.get$elements(el);
        return $el.length && typeof $el[_name] === "function" ? $el[_name](options) : void 0;
      },
      Component: (nameName, compObj) => {
        const name2 = normalizeComponentName(nameName);
        const Utils = Metro2.utils;
        const component = $5.extend(
          { name: name2 },
          {
            _super: function(el, options, defaults, setup) {
              this.elem = el;
              this.element = $5(el);
              this.options = $5.extend({}, defaults, options);
              this.component = this.elem;
              this.locale = "en";
              this.strings = {};
              this._setOptionsFromDOM();
              this._runtime();
              this._setLocale();
              if (setup && typeof setup === "object") {
                $5.each(setup, (key, val) => {
                  this[key] = val;
                });
              }
              this._createExec();
            },
            _setOptionsFromDOM: function() {
              const element2 = this.element, o2 = this.options;
              $5.each(element2.data(), (key, value) => {
                if (key in o2) {
                  try {
                    o2[key] = JSON.parse(value);
                  } catch (e2) {
                    o2[key] = value;
                  }
                }
              });
            },
            _runtime: function() {
              let element2 = this.element, mc;
              const roles = (element2.attr("data-role") || "").toArray(",").map((v4) => normalizeComponentName(v4)).filter((v4) => v4.trim() !== "");
              if (!element2.attr("data-role-" + this.name)) {
                element2.attr("data-role-" + this.name, true);
                if (roles.indexOf(this.name) === -1) {
                  roles.push(this.name);
                  element2.attr("data-role", roles.join(","));
                }
                mc = element2.data("metroComponent");
                if (mc === void 0) {
                  mc = [this.name];
                } else {
                  mc.push(this.name);
                }
                element2.data("metroComponent", mc);
              }
            },
            _createExec: function() {
              const timeout = this.options[this.name + "Deferred"];
              if (timeout) {
                setTimeout(() => {
                  this._create();
                }, timeout);
              } else {
                this._create();
              }
            },
            _fireEvent: function(eventName, data, log, noFire, context = null) {
              const element2 = this.element, o2 = this.options;
              let _data;
              const event = str(eventName).camelCase().capitalize(false).value;
              data = $5.extend({}, data, { __this: element2[0] });
              _data = data ? Object.values(data) : {};
              if (log) {
                console.warn(log);
                console.warn("Event: on" + event);
                console.warn("Data: ", data);
                console.warn("Element: ", element2[0]);
              }
              if (noFire !== true) element2.fire(event.toLowerCase(), data);
              return Utils.exec(o2["on" + event], _data, context ? context : element2[0]);
            },
            _fireEvents: function(events, data, log, noFire, context) {
              let that = this, _events;
              if (arguments.length === 0) {
                return;
              }
              if (arguments.length === 1) {
                $5.each(events, function() {
                  that._fireEvent(this.name, this.data, this.log, this.noFire, context);
                });
                return Utils.objectLength(events);
              }
              if (!Array.isArray(events) && typeof events !== "string") {
                return;
              }
              _events = Array.isArray(events) ? events : events.toArray(",");
              $5.each(_events, function() {
                that._fireEvent(this, data, log, noFire, context);
              });
            },
            _setLocale: function() {
              const lang = this.element.closest("[lang]");
              if (lang.length > 0) {
                this.locale = lang.attr("lang");
              } else {
                this.locale = $5("html").attr("lang") || "en";
              }
              this.strings = $5.extend({}, Metro2.locales["en"], Metro2.locales[this.locale]);
            },
            getComponent: function() {
              return this.component;
            },
            getComponentName: function() {
              return this.name;
            }
          },
          compObj
        );
        Metro2.plugin(name2, component);
        return component;
      },
      fetch: {
        status: (response) => response.ok ? Promise.resolve(response) : Promise.reject(new Error(response.statusText)),
        json: (response) => response.json(),
        text: (response) => response.text(),
        form: (response) => response.formData(),
        blob: (response) => response.blob(),
        buffer: (response) => response.arrayBuffer()
      },
      i18n: {
        language: "en",
        load(lang = "en") {
          Metro2.i18n.language = Metro2.locales[lang] ? lang : "en";
          Metro2.locale = Metro2.locales[Metro2.i18n.language];
        },
        add(id, data) {
          Metro2.locales[id] = data;
        },
        get(key, locale) {
          return Metro2.locales[locale][key] || "";
        },
        updateUI(from = document, lang) {
          if (!lang) {
            lang = $5.html().attr("lang") || "en";
          }
          if (!Metro2.locales[lang]) {
            return;
          }
          Metro2.i18n.load(lang);
          $5.html().attr("lang", lang);
          from.querySelectorAll("[data-i18n]").forEach((el) => {
            const key = el.getAttribute("data-i18n");
            el.innerHTML = Metro2.i18n.get(key, lang);
          });
        },
        extend(data) {
          $5.each(data, (key, value) => {
            Metro2.locales[key] = Object.assign({}, Metro2.locales[key], value);
          });
        }
      }
    };
    Object.assign(Metro2, Props);
    $5(globalThis).on(Metro2.events.resize, () => {
      globalThis["METRO_MEDIA"] = [];
      $5.each(Metro2.media_queries, (key, query) => {
        if (Metro2.utils.media(query)) {
          globalThis["METRO_MEDIA"].push(Metro2.media_mode[key]);
        }
      });
    });
    globalThis["Metro"] = Metro2;
    if (globalThis["METRO_INIT"] === true) {
      $5(() => {
        Metro2.init();
      });
    }
    return Metro2;
  })();

  // source/i18n/en.js
  (function() {
    Metro.i18n.add("en", {
      weekStart: 0,
      january: "January",
      february: "February",
      march: "March",
      april: "April",
      may: "May",
      june: "June",
      july: "July",
      august: "August",
      september: "September",
      october: "October",
      november: "November",
      december: "December",
      january_short: "Jan",
      february_short: "Feb",
      march_short: "Mar",
      april_short: "Apr",
      may_short: "May",
      june_short: "Jun",
      july_short: "Jul",
      august_short: "Aug",
      september_short: "Sep",
      october_short: "Oct",
      november_short: "Nov",
      december_short: "Dec",
      sunday: "Sunday",
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday",
      sunday_short: "Sun",
      monday_short: "Mon",
      tuesday_short: "Tue",
      wednesday_short: "Wed",
      thursday_short: "Thu",
      friday_short: "Fri",
      saturday_short: "Sat",
      sunday_short_2: "Su",
      monday_short_2: "Mo",
      tuesday_short_2: "Tu",
      wednesday_short_2: "We",
      thursday_short_2: "Th",
      friday_short_2: "Fr",
      saturday_short_2: "Sa",
      label_ok: "OK",
      label_cancel: "Cancel",
      label_done: "Done",
      label_today: "Today",
      label_now: "Now",
      label_clear: "Clear",
      label_help: "Help",
      label_yes: "Yes",
      label_no: "No",
      label_random: "Random",
      label_save: "Save",
      label_reset: "Reset",
      label_submit: "Submit",
      label_add_user_color: "Add to swatches",
      label_send: "Send",
      label_accept: "Accept",
      label_cookies_title: "This site uses cookies",
      label_cookies_text: "This website uses cookies to ensure you get the best experience on our website.",
      label_choose_file: "Choose file(s)",
      label_drop_file: "Click or drop file(s) here",
      label_files_selected: "{n} file(s) selected",
      label_days: "days",
      label_hours: "hours",
      label_minutes: "min",
      label_seconds: "sec",
      label_month: "mon",
      label_months: "mon's",
      label_day: "day",
      label_year: "year",
      label_years: "years",
      label_rows_count: "Show:",
      label_search: "Search:",
      label_table_info: "Showing $1 to $2 of $3 entries",
      label_prev: "Prev",
      label_next: "Next",
      label_all: "All",
      label_inspector: "Inspector",
      label_goto_page: "Goto",
      label_enter_page: "Enter page...",
      label_empty: "Nothing to show",
      label_user_colors: "User Colors",
      label_tiles: "Tiles",
      label_list: "List",
      label_load_more: "Load more",
      label_buy: "Buy",
      label_buy_now: "Buy now",
      label_buy_today: "Buy today",
      label_download: "Download",
      label_search_results: "Search results",
      label_add: "Add",
      label_edit: "Edit",
      label_delete: "Delete",
      label_new: "New",
      label_sell: "Sell",
      label_details: "Details",
      label_sorting: "Sorting",
      label_on: "on",
      label_off: "off",
      label_rename_tab: "Rename tab",
      label_close_tab: "Close tab",
      label_close_other_tabs: "Close other tabs",
      label_close_tabs_left: "Close tabs left",
      label_close_tabs_right: "Close tabs right",
      label_close_all_tabs: "Close all tabs",
      label_close_inactive_tabs: "Close inactive tabs",
      label_clear_input: "Clear input",
      label_reveal_password: "Reveal password",
      label_hide_password: "Hide password",
      label_generate_random: "Generate random value",
      label_search_input: "Search for the entered value",
      label_note: "Note",
      label_tip: "Tip",
      label_info: "Info",
      label_warning: "Warning",
      label_question: "Question",
      label_error: "Error",
      label_success: "Success",
      label_caution: "Caution",
      label_alert: "Alert",
      label_bug: "Bug",
      label_fuck: "Fuck",
      label_important: "Important",
      label_shit: "Shit",
      label_air: "Air",
      label_select_all: "Select all",
      label_select_more: "Select...",
      label_select: "Select",
      label_filter: "Filter",
      label_collapse: "Collapse"
    });
  })();

  // source/i18n/ua.js
  (function() {
    Metro.i18n.add("ua", {
      weekStart: 1,
      january: "\u0421\u0456\u0447\u0435\u043D\u044C",
      february: "\u041B\u044E\u0442\u0438\u0439",
      march: "\u0411\u0435\u0440\u0435\u0437\u0435\u043D\u044C",
      april: "\u041A\u0432\u0456\u0442\u0435\u043D\u044C",
      may: "\u0422\u0440\u0430\u0432\u0435\u043D\u044C",
      june: "\u0427\u0435\u0440\u0432\u0435\u043D\u044C",
      july: "\u041B\u0438\u043F\u0435\u043D\u044C",
      august: "\u0421\u0435\u0440\u043F\u0435\u043D\u044C",
      september: "\u0412\u0435\u0440\u0435\u0441\u0435\u043D\u044C",
      october: "\u0416\u043E\u0432\u0442\u0435\u043D\u044C",
      november: "\u041B\u0438\u0441\u0442\u043E\u043F\u0430\u0434",
      december: "\u0413\u0440\u0443\u0434\u0435\u043D\u044C",
      january_short: "\u0421\u0456\u0447",
      february_short: "\u041B\u044E\u0442",
      march_short: "\u0411\u0435\u0440",
      april_short: "\u041A\u0432\u0456",
      may_short: "\u0422\u0440\u0430",
      june_short: "\u0427\u0435\u0440",
      july_short: "\u041B\u0438\u043F",
      august_short: "\u0421\u0435\u0440",
      september_short: "\u0412\u0435\u0440",
      october_short: "\u0416\u043E\u0432",
      november_short: "\u041B\u0438\u0441",
      december_short: "\u0413\u0440\u0443",
      sunday: "\u041D\u0435\u0434\u0456\u043B\u044F",
      monday: "\u041F\u043E\u043D\u0435\u0434\u0456\u043B\u043E\u043A",
      tuesday: "\u0412\u0456\u0432\u0442\u043E\u0440\u043E\u043A",
      wednesday: "\u0421\u0435\u0440\u0435\u0434\u0430",
      thursday: "\u0427\u0435\u0442\u0432\u0435\u0440",
      friday: "\u041F'\u044F\u0442\u043D\u0438\u0446\u044F",
      saturday: "\u0421\u0443\u0431\u043E\u0442\u0430",
      sunday_short: "\u041D\u0435\u0434",
      monday_short: "\u041F\u043E\u043D",
      tuesday_short: "\u0412\u0456\u0432",
      wednesday_short: "\u0421\u0435\u0440",
      thursday_short: "\u0427\u0435\u0442",
      friday_short: "\u041F\u0442\u043D",
      saturday_short: "\u0421\u0443\u0431",
      sunday_short_2: "\u041D\u0434",
      monday_short_2: "\u041F\u043D",
      tuesday_short_2: "\u0412\u0442",
      wednesday_short_2: "\u0421\u0440",
      thursday_short_2: "\u0427\u0442",
      friday_short_2: "\u041F\u0442",
      saturday_short_2: "\u0421\u0431",
      label_ok: "OK",
      label_cancel: "\u0412\u0456\u0434\u043C\u0456\u043D\u0430",
      label_done: "\u0412\u0438\u043A\u043E\u043D\u0430\u043D\u043E",
      label_today: "\u0421\u044C\u043E\u0433\u043E\u0434\u043D\u0456",
      label_now: "\u0417\u0430\u0440\u0430\u0437",
      label_clear: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u0438",
      label_help: "\u0414\u043E\u043F\u043E\u043C\u043E\u0433\u0430",
      label_yes: "\u0422\u0430\u043A",
      label_no: "\u041D\u0456",
      label_random: "\u0412\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u043E",
      label_save: "\u0417\u0431\u0435\u0440\u0456\u0433\u0442\u0438",
      label_reset: "\u0421\u043A\u0438\u043D\u0443\u0442\u0438",
      label_submit: "\u0412\u0456\u0434\u043F\u0440\u0430\u0432\u0438\u0442\u0438",
      label_add_user_color: "\u0414\u043E\u0434\u0430\u0442\u0438 \u0434\u043E \u0437\u0440\u0430\u0437\u043A\u0456\u0432",
      label_send: "\u0412\u0456\u0434\u043F\u0440\u0430\u0432\u0438\u0442\u0438",
      label_accept: "\u041F\u0440\u0438\u0439\u043D\u044F\u0442\u0438",
      label_cookies_title: "\u0426\u0435\u0439 \u0441\u0430\u0439\u0442 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454 \u0444\u0430\u0439\u043B\u0438 cookie",
      label_cookies_text: "\u0426\u0435\u0439 \u0432\u0435\u0431-\u0441\u0430\u0439\u0442 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454 \u0444\u0430\u0439\u043B\u0438 cookie, \u0449\u043E\u0431 \u0437\u0430\u0431\u0435\u0437\u043F\u0435\u0447\u0438\u0442\u0438 \u0432\u0430\u043C \u043D\u0430\u0439\u043A\u0440\u0430\u0449\u0438\u0439 \u0434\u043E\u0441\u0432\u0456\u0434 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u043D\u0430\u0448\u043E\u0433\u043E \u0432\u0435\u0431-\u0441\u0430\u0439\u0442\u0443.",
      label_choose_file: "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C \u0444\u0430\u0439\u043B(\u0438)",
      label_drop_file: "\u041D\u0430\u0442\u0438\u0441\u043D\u0456\u0442\u044C \u0430\u0431\u043E \u043F\u0435\u0440\u0435\u0442\u044F\u0433\u043D\u0456\u0442\u044C \u0444\u0430\u0439\u043B(\u0438) \u0441\u044E\u0434\u0438",
      label_files_selected: "\u0412\u0438\u0431\u0440\u0430\u043D\u043E {n} \u0444\u0430\u0439\u043B(\u0456\u0432)",
      label_days: "\u0434\u043D\u0456",
      label_hours: "\u0433\u043E\u0434",
      label_minutes: "\u0445\u0432\u0438\u043B",
      label_seconds: "\u0441\u0435\u043A",
      label_month: "\u043C\u0456\u0441",
      label_months: "\u043C\u0456\u0441\u044F\u0446\u0456",
      label_day: "\u0434\u0435\u043D\u044C",
      label_year: "\u0440\u0456\u043A",
      label_years: "\u0440\u043E\u043A\u0456\u0432",
      label_rows_count: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u0438:",
      label_search: "\u041F\u043E\u0448\u0443\u043A:",
      label_table_info: "\u0412\u0456\u0434\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u043E \u0437 $1 \u043F\u043E $2 \u0456\u0437 $3 \u0437\u0430\u043F\u0438\u0441\u0456\u0432",
      label_prev: "\u041F\u043E\u043F\u0435\u0440",
      label_next: "\u041D\u0430\u0441\u0442",
      label_all: "\u0423\u0441\u0456",
      label_inspector: "\u0406\u043D\u0441\u043F\u0435\u043A\u0442\u043E\u0440",
      label_goto_page: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438",
      label_enter_page: "\u0412\u0432\u0435\u0434\u0456\u0442\u044C \u0441\u0442\u043E\u0440\u0456\u043D\u043A\u0443...",
      label_empty: "\u041D\u0456\u0447\u043E\u0433\u043E \u043F\u043E\u043A\u0430\u0437\u0430\u0442\u0438",
      label_user_colors: "\u041A\u043E\u043B\u044C\u043E\u0440\u0438 \u043A\u043E\u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0447\u0430",
      label_tiles: "\u041F\u043B\u0438\u0442\u043A\u0430",
      label_list: "\u0421\u043F\u0438\u0441\u043E\u043A",
      label_load_more: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u0438 \u0449\u0435",
      label_buy: "\u041A\u0443\u043F\u0438\u0442\u0438",
      label_buy_now: "\u041A\u0443\u043F\u0438\u0442\u0438 \u0437\u0430\u0440\u0430\u0437",
      label_buy_today: "\u041A\u0443\u043F\u0438\u0442\u0438 \u0441\u044C\u043E\u0433\u043E\u0434\u043D\u0456",
      label_download: "\u0417\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0438\u0442\u0438",
      label_search_results: "\u0420\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\u0438 \u043F\u043E\u0448\u0443\u043A\u0443",
      label_add: "\u0414\u043E\u0434\u0430\u0442\u0438",
      label_edit: "\u0420\u0435\u0434\u0430\u0433\u0443\u0432\u0430\u0442\u0438",
      label_delete: "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438",
      label_new: "\u041D\u043E\u0432\u0435",
      label_sell: "\u041F\u0440\u043E\u0434\u0430\u0442\u0438",
      label_details: "\u041F\u043E\u0434\u0440\u043E\u0431\u0438\u0446\u0456",
      label_sorting: "\u0421\u043E\u0440\u0442\u0443\u0432\u0430\u043D\u043D\u044F",
      label_on: "\u0443\u0432\u043C",
      label_off: "\u0432\u0438\u043C",
      label_rename_tab: "\u041F\u0435\u0440\u0435\u0439\u043C\u0435\u043D\u0443\u0432\u0430\u0442\u0438 \u0432\u043A\u043B\u0430\u0434\u043A\u0443",
      label_close_tab: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u0432\u043A\u043B\u0430\u0434\u043A\u0443",
      label_close_other_tabs: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u0456\u043D\u0448\u0456 \u0432\u043A\u043B\u0430\u0434\u043A\u0438",
      label_close_tabs_left: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u0432\u043A\u043B\u0430\u0434\u043A\u0438 \u043B\u0456\u0432\u043E\u0440\u0443\u0447",
      label_close_tabs_right: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u0432\u043A\u043B\u0430\u0434\u043A\u0438 \u043F\u0440\u0430\u0432\u043E\u0440\u0443\u0447",
      label_close_all_tabs: "\u0417\u0430\u043A\u0440\u0438\u0439\u0442\u0435 \u0432\u0441\u0456 \u0432\u043A\u043B\u0430\u0434\u043A\u0438",
      label_close_inactive_tabs: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u043D\u0435\u0430\u043A\u0442\u0438\u0432\u043D\u0456 \u0432\u043A\u043B\u0430\u0434\u043A\u0438",
      label_clear_input: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u0438 \u0432\u0432\u0435\u0434\u0435\u043D\u043D\u044F",
      label_reveal_password: "\u0412\u0456\u0434\u043A\u0440\u0438\u0442\u0438 \u043F\u0430\u0440\u043E\u043B\u044C",
      label_hide_password: "\u041F\u0440\u0438\u0445\u043E\u0432\u0430\u0442\u0438 \u043F\u0430\u0440\u043E\u043B\u044C",
      label_generate_random: "\u0413\u0435\u043D\u0435\u0440\u0443\u0432\u0430\u0442\u0438 \u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432e \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F",
      label_search_input: "\u0428\u0443\u043A\u0430\u0442\u0438 \u0432\u0432\u0435\u0434\u0435\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F",
      label_note: "\u041F\u0440\u0438\u043C\u0456\u0442\u043A\u0430",
      label_tip: "\u041F\u0456\u0434\u043A\u0430\u0437\u043A\u0430",
      label_info: "\u0406\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0456\u044F",
      label_warning: "\u0423\u0432\u0430\u0433\u0430",
      label_question: "\u041F\u0438\u0442\u0430\u043D\u043D\u044F",
      label_error: "\u041F\u043E\u043C\u0438\u043B\u043A\u0430",
      label_success: "\u0423\u0441\u043F\u0456\u0445",
      label_caution: "\u041E\u0431\u0435\u0440\u0435\u0436\u043D\u043E",
      label_alert: "\u041F\u043E\u043F\u0435\u0440\u0435\u0434\u0436\u0435\u043D\u043D\u044F",
      label_bug: "\u041F\u043E\u043C\u0438\u043B\u043A\u0430",
      label_fuck: "\u0411\u043B\u044F",
      label_important: "\u0412\u0430\u0436\u043B\u0438\u0432\u043E",
      label_shit: "\u041E\u0442 \u043B\u0430\u0439\u043D\u043E",
      label_air: "\u041F\u0443\u0444\u0444\u0444...",
      label_select_all: "\u0412\u0438\u0431\u0440\u0430\u0442\u0438 \u0443\u0441\u0456",
      label_select_more: "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C...",
      label_select: "\u0412\u0438\u0431\u0440\u0430\u0442\u0438",
      label_filter: "\u0424\u0456\u043B\u044C\u0442\u0440",
      label_collapse: "\u0417\u0433\u043E\u0440\u043D\u0443\u0442\u0438"
    });
  })();

  // source/i18n/pt-BR.js
  (function() {
    Metro.i18n.add("pt-BR", {
      weekStart: 0,
      january: "Janeiro",
      february: "Fevereiro",
      march: "Mar\xE7o",
      april: "Abril",
      may: "Maio",
      june: "Junho",
      july: "Julho",
      august: "Agosto",
      september: "Setembro",
      october: "Outubro",
      november: "Novembro",
      december: "Dezembro",
      january_short: "Jan",
      february_short: "Fev",
      march_short: "Mar",
      april_short: "Abr",
      may_short: "Mai",
      june_short: "Jun",
      july_short: "Jul",
      august_short: "Ago",
      september_short: "Set",
      october_short: "Out",
      november_short: "Nov",
      december_short: "Dez",
      sunday: "Domingo",
      monday: "Segunda",
      tuesday: "Ter\xE7a",
      wednesday: "Quarta",
      thursday: "Quinta",
      friday: "Sexta",
      saturday: "S\xE1bado",
      sunday_short: "Dom",
      monday_short: "Seg",
      tuesday_short: "Ter",
      wednesday_short: "Qua",
      thursday_short: "Qui",
      friday_short: "Sex",
      saturday_short: "S\xE1b",
      sunday_short_2: "D",
      monday_short_2: "S",
      tuesday_short_2: "T",
      wednesday_short_2: "Q",
      thursday_short_2: "Q",
      friday_short_2: "S",
      saturday_short_2: "S",
      label_ok: "OK",
      label_cancel: "Cancelar",
      label_done: "Pronto",
      label_today: "Hoje",
      label_now: "Agora",
      label_clear: "Limpar",
      label_help: "Ajuda",
      label_yes: "Sim",
      label_no: "N\xE3o",
      label_random: "Aleat\xF3rio",
      label_save: "Salvar",
      label_reset: "Resetar",
      label_submit: "Enviar",
      label_add_user_color: "Adicionar \xE0s amostras",
      label_send: "Enviar",
      label_accept: "Aceitar",
      label_cookies_title: "Este site usa cookis",
      label_cookies_text: "Este site utiliza cookies para garantir que voc\xEA tenha a melhor experi\xEAncia.",
      label_choose_file: "Escolher arquivo(s)",
      label_drop_file: "Clique ou solte arquivo(s) aqui",
      label_files_selected: "{n} arquivo(s) selecionado(s)",
      label_days: "dias",
      label_hours: "horas",
      label_minutes: "min",
      label_seconds: "seg",
      label_month: "m\xEAs",
      label_months: "meses",
      label_day: "dia",
      label_year: "ano",
      label_years: "anos",
      label_rows_count: "Exibir:",
      label_search: "Pesquisar:",
      label_table_info: "Exibindo de $1 at\xE9 $2 de um total de $3 registros",
      label_prev: "Anterior",
      label_next: "Pr\xF3ximo",
      label_all: "Todos",
      label_inspector: "Inspetor",
      label_goto_page: "Ir para",
      label_enter_page: "Digite a p\xE1gina...",
      label_empty: "Nada para exibir",
      label_user_colors: "Cores do usu\xE1rio",
      label_tiles: "Blocos",
      label_list: "Lista",
      label_load_more: "Carregar mais",
      label_buy: "Comprar",
      label_buy_now: "Comprar agora",
      label_buy_today: "Comprar hoje",
      label_download: "Download",
      label_search_results: "Pesquisar resultados",
      label_add: "Adicionar",
      label_edit: "Editar",
      label_delete: "Excluir",
      label_new: "Novo",
      label_sell: "Vender",
      label_details: "Detalhes",
      label_sorting: "Ordenar",
      label_on: "lig",
      label_off: "deslig",
      label_rename_tab: "Renomear aba",
      label_close_tab: "Fechar aba",
      label_close_other_tabs: "Fechar outras abas",
      label_close_tabs_left: "Fechar abas a esquerda",
      label_close_tabs_right: "Fechar abas a direita",
      label_close_all_tabs: "Fechar todas as abas",
      label_close_inactive_tabs: "Fechar abas inativas",
      label_clear_input: "Limpar",
      label_reveal_password: "Mostrar senha",
      label_hide_password: "Ocultar senha",
      label_generate_random: "Gerar valor aleat\xF3rio",
      label_search_input: "Pesquisar pelo valor",
      label_note: "Nota",
      label_tip: "Dica",
      label_info: "Informa\xE7\xE3o",
      label_warning: "Aviso",
      label_question: "Quest\xE3o",
      label_error: "Erro",
      label_success: "Sucesso",
      label_caution: "Cuidado",
      label_alert: "Alerta",
      label_bug: "Bug",
      label_fuck: "Falha catastr\xF3tico",
      label_important: "Importante",
      label_shit: "Shit",
      label_air: "Air",
      label_select_all: "Select all",
      label_select_more: "Select...",
      label_select: "Select",
      label_filter: "Filter",
      label_collapse: "Collapse"
    });
  })();

  // source/i18n/es-ES.js
  (function() {
    Metro.i18n.add("es-ES", {
      weekStart: 0,
      january: "Enero",
      february: "Febrero",
      march: "Marzo",
      april: "Abril",
      may: "Mayo",
      june: "Junio",
      july: "Julio",
      august: "Agosto",
      september: "Septiembre",
      october: "Octubre",
      november: "Noviembre",
      december: "Diciembre",
      january_short: "Ene",
      february_short: "Feb",
      march_short: "Mar",
      april_short: "Abr",
      may_short: "May",
      june_short: "Jun",
      july_short: "Jul",
      august_short: "Ago",
      september_short: "Sep",
      october_short: "Oct",
      november_short: "Nov",
      december_short: "Dic",
      sunday: "Domingo",
      monday: "Lunes",
      tuesday: "Martes",
      wednesday: "Mi\xE9rcoles",
      thursday: "Jueves",
      friday: "Viernes",
      saturday: "S\xE1bado",
      sunday_short: "Dom",
      monday_short: "Lun",
      tuesday_short: "Mar",
      wednesday_short: "Mi\xE9",
      thursday_short: "Jue",
      friday_short: "Vie",
      saturday_short: "S\xE1b",
      sunday_short_2: "D",
      monday_short_2: "L",
      tuesday_short_2: "M",
      wednesday_short_2: "M",
      thursday_short_2: "J",
      friday_short_2: "V",
      saturday_short_2: "S",
      label_ok: "OK",
      label_cancel: "Cancelar",
      label_done: "Listo",
      label_today: "Hoy",
      label_now: "Ahora",
      label_clear: "Limpiar",
      label_help: "Ayuda",
      label_yes: "S\xED",
      label_no: "No",
      label_random: "Aleatorio",
      label_save: "Guardar",
      label_reset: "Restablecer",
      label_submit: "Enviar",
      label_add_user_color: "Agregar a la paleta",
      label_send: "Enviar",
      label_accept: "Aceptar",
      label_cookies_title: "Este sitio usa cookies",
      label_cookies_text: "Este sitio utiliza cookies para garantizar que tengas la mejor experiencia.",
      label_choose_file: "Elegir archivo(s)",
      label_drop_file: "Haz clic o suelta archivo(s) aqu\xED",
      label_files_selected: "{n} archivo(s) seleccionado(s)",
      label_days: "d\xEDas",
      label_hours: "horas",
      label_minutes: "min",
      label_seconds: "seg",
      label_month: "mes",
      label_months: "meses",
      label_day: "d\xEDa",
      label_year: "a\xF1o",
      label_years: "a\xF1os",
      label_rows_count: "Mostrar:",
      label_search: "Buscar:",
      label_table_info: "Mostrando de $1 a $2 de un total de $3 registros",
      label_prev: "Anterior",
      label_next: "Siguiente",
      label_all: "Todos",
      label_inspector: "Inspector",
      label_goto_page: "Ir a la p\xE1gina",
      label_enter_page: "Escribe la p\xE1gina...",
      label_empty: "Nada para mostrar",
      label_user_colors: "Colores del usuario",
      label_tiles: "Cuadr\xEDculas",
      label_list: "Lista",
      label_load_more: "Cargar m\xE1s",
      label_buy: "Comprar",
      label_buy_now: "Comprar ahora",
      label_buy_today: "Comprar hoy",
      label_download: "Descargar",
      label_search_results: "Buscar resultados",
      label_add: "Agregar",
      label_edit: "Editar",
      label_delete: "Eliminar",
      label_new: "Nuevo",
      label_sell: "Vender",
      label_details: "Detalles",
      label_sorting: "Ordenar",
      label_on: "encendido",
      label_off: "apagado",
      label_rename_tab: "Renombrar pesta\xF1a",
      label_close_tab: "Cerrar pesta\xF1a",
      label_close_other_tabs: "Cerrar otras pesta\xF1as",
      label_close_tabs_left: "Cerrar pesta\xF1as a la izquierda",
      label_close_tabs_right: "Cerrar pesta\xF1as a la derecha",
      label_close_all_tabs: "Cerrar todas las pesta\xF1as",
      label_close_inactive_tabs: "Cerrar pesta\xF1as inactivas",
      label_clear_input: "Limpiar",
      label_reveal_password: "Mostrar contrase\xF1a",
      label_hide_password: "Ocultar contrase\xF1a",
      label_generate_random: "Generar valor aleatorio",
      label_search_input: "Buscar por valor",
      label_note: "Nota",
      label_tip: "Consejo",
      label_info: "Informaci\xF3n",
      label_warning: "Advertencia",
      label_question: "Pregunta",
      label_error: "Error",
      label_success: "\xC9xito",
      label_caution: "Precauci\xF3n",
      label_alert: "Alerta",
      label_bug: "Bug",
      label_fuck: "Falla catastr\xF3fica",
      label_important: "Importante",
      label_shit: "Shit",
      label_air: "Air",
      label_select_all: "Select all",
      label_select_more: "Select...",
      label_select: "Select",
      label_filter: "Filter",
      label_collapse: "Collapse"
    });
  })();

  // source/extensions/array.js
  (function() {
    "use strict";
    if (typeof Array.prototype.shuffle !== "function") {
      Array.prototype.shuffle = function() {
        var currentIndex = this.length, temporaryValue, randomIndex;
        while (0 !== currentIndex) {
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex -= 1;
          temporaryValue = this[currentIndex];
          this[currentIndex] = this[randomIndex];
          this[randomIndex] = temporaryValue;
        }
        return this;
      };
    }
    if (typeof Array.prototype.clone !== "function") {
      Array.prototype.clone = function() {
        return this.slice(0);
      };
    }
    if (typeof Array.prototype.unique !== "function") {
      Array.prototype.unique = function() {
        var a3 = this.concat();
        for (var i3 = 0; i3 < a3.length; ++i3) {
          for (var j4 = i3 + 1; j4 < a3.length; ++j4) {
            if (a3[i3] === a3[j4])
              a3.splice(j4--, 1);
          }
        }
        return a3;
      };
    }
    if (typeof Array.prototype.pack !== "function") {
      Array.prototype.pack = function() {
        return this.map((n2) => n2.trim()).filter(Boolean);
      };
    }
  })();

  // source/extensions/number.js
  (function() {
    "use strict";
    Number.prototype.format = function(n2, x4, s3, c3) {
      var re3 = "\\d(?=(\\d{" + (x4 || 3) + "})+" + (n2 > 0 ? "\\D" : "$") + ")", num = this.toFixed(Math.max(0, ~~n2));
      return (c3 ? num.replace(".", c3) : num).replace(new RegExp(re3, "g"), "$&" + (s3 || ","));
    };
  })();

  // source/extensions/string.js
  (function() {
    "use strict";
    String.prototype.toArray = function(delimiter = ",", type = "string", format, locale) {
      var str2 = this;
      var a3;
      format = format === void 0 || format === null ? false : format;
      a3 = ("" + str2).split(delimiter);
      return a3.map(function(s3) {
        var result;
        switch (type) {
          case "int":
          case "integer":
            result = isNaN(s3) ? s3.trim() : parseInt(s3);
            break;
          case "number":
          case "float":
            result = isNaN(s3) ? s3 : parseFloat(s3);
            break;
          case "date":
            result = !format ? datetime(s3) : Datetime.from(s3, format, locale || "en-US");
            break;
          default:
            result = s3.trim();
        }
        return result;
      });
    };
    String.prototype.capitalize = function() {
      var str2 = this;
      return str2.substr(0, 1).toUpperCase() + str2.substr(1);
    };
  })();

  // source/common-js/utilities.js
  (function(Metro2, $5) {
    "use strict";
    Metro2.utils = {
      nothing: function() {
      },
      noop: function() {
      },
      elementId: function(prefix) {
        return prefix + "-" + (/* @__PURE__ */ new Date()).getTime() + $5.random(1, 1e3);
      },
      secondsToTime: function(s3) {
        const days = Math.floor(s3 % 31536e3 / 86400);
        const hours = Math.floor(s3 % 31536e3 % 86400 / 3600);
        const minutes = Math.floor(s3 % 31536e3 % 86400 % 3600 / 60);
        const seconds = Math.round(s3 % 31536e3 % 86400 % 3600 % 60);
        return {
          d: days,
          h: hours,
          m: minutes,
          s: seconds
        };
      },
      secondsToFormattedString: function(time) {
        const sec_num = parseInt(time, 10);
        const hours = Math.floor(sec_num / 3600);
        const minutes = Math.floor((sec_num - hours * 3600) / 60);
        const seconds = sec_num - hours * 3600 - minutes * 60;
        return [
          Str.lpad(hours, "0", 2),
          Str.lpad(minutes, "0", 2),
          Str.lpad(seconds, "0", 2)
        ].join(":");
      },
      func: function(f5) {
        return new Function("a", f5);
      },
      exec: function(f5, args, context) {
        let result;
        if (f5 === void 0 || f5 === null) {
          return false;
        }
        let func = this.isFunc(f5);
        if (func === false) {
          func = this.func(f5);
        }
        try {
          result = func.apply(context, args);
        } catch (err) {
          result = null;
          if (globalThis["METRO_THROWS"] === true) {
            throw err;
          }
        }
        return result;
      },
      embedUrl: function(val) {
        if (val.indexOf("youtu.be") !== -1) {
          val = "https://www.youtube.com/embed/" + val.split("/").pop();
        }
        return "<div class='embed-container'><iframe src='" + val + "'></iframe></div>";
      },
      isVisible: function(element2) {
        const el = $5(element2)[0];
        return this.getStyleOne(el, "display") !== "none" && this.getStyleOne(el, "visibility") !== "hidden" && el.offsetParent !== null;
      },
      isUrl: function(val) {
        return /^(\.\/|\.\.\/|ftp|http|https):\/\/(\w+:?\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@\-\/]))?/.test(
          val
        );
      },
      isTag: function(val) {
        return /^<\/?[\w\s="\/.':;#-\/?]+>/gi.test(val);
      },
      isEmbedObject: function(val) {
        const embed = ["iframe", "object", "embed", "video"];
        let result = false;
        $5.each(embed, function() {
          if (typeof val === "string" && val.toLowerCase() === this) {
            result = true;
          } else if (val.nodeType !== void 0 && val.tagName.toLowerCase() === this) {
            result = true;
          }
        });
        return result;
      },
      isVideoUrl: function(val) {
        return /youtu\.be|youtube|twitch|vimeo/gi.test(val);
      },
      isDate: function(val, format, locale = "en-US") {
        let result;
        if (this.isDateObject(val)) {
          return true;
        }
        try {
          result = format ? Datetime.from(val, format, locale) : datetime(val);
          return Datetime.isDatetime(result);
        } catch (e2) {
          return false;
        }
      },
      isDateObject: function(v4) {
        return typeof v4 === "object" && v4.getMonth !== void 0;
      },
      isInt: function(n2) {
        return !isNaN(n2) && +n2 % 1 === 0;
      },
      isFloat: function(n2) {
        return !isNaN(n2) && +n2 % 1 !== 0 || /^\d*\.\d+$/.test(n2);
      },
      isFunc: function(f5) {
        return this.isType(f5, "function");
      },
      isObject: function(o2) {
        return this.isType(o2, "object");
      },
      isObject2: function(o2) {
        return typeof o2 === "object" && !Array.isArray(o2);
      },
      isType: function(o2, t) {
        if (!this.isValue(o2)) {
          return false;
        }
        if (typeof o2 === t) {
          return o2;
        }
        if (("" + t).toLowerCase() === "tag" && this.isTag(o2)) {
          return o2;
        }
        if (("" + t).toLowerCase() === "url" && this.isUrl(o2)) {
          return o2;
        }
        if (("" + t).toLowerCase() === "array" && Array.isArray(o2)) {
          return o2;
        }
        if (t !== "string" && this.isTag(o2) || this.isUrl(o2)) {
          return false;
        }
        if (typeof window[o2] === t) {
          return window[o2];
        }
        if (typeof o2 === "string" && o2.indexOf(".") === -1) {
          return false;
        }
        if (typeof o2 === "string" && /[/\s([]+/gm.test(o2)) {
          return false;
        }
        if (typeof o2 === "number" && t.toLowerCase() !== "number") {
          return false;
        }
        const ns = o2.split(".");
        let i3, context = window;
        for (i3 = 0; i3 < ns.length; i3++) {
          context = context[ns[i3]];
        }
        return typeof context === t ? context : false;
      },
      $: function() {
        return globalThis["useJQuery"] ? globalThis["jQuery"] : Dom;
      },
      isMetroObject: function(el, type) {
        const $el = $5(el), el_obj = Metro2.getPlugin(el, type);
        if ($el.length === 0) {
          console.warn(type + " " + el + " not found!");
          return false;
        }
        if (el_obj === void 0) {
          console.warn(
            "Element not contain role " + type + '! Please add attribute data-role="' + type + '" to element ' + el
          );
          return false;
        }
        return true;
      },
      isJQuery: function(el) {
        return typeof globalThis["jQuery"] !== "undefined" && el instanceof globalThis["jQuery"];
      },
      isDom: function(el) {
        return typeof Dom !== "undefined" && el instanceof Dom;
      },
      isQ: function(el) {
        return this.isJQuery(el) || this.isDom(el);
      },
      isOutsider: function(element2) {
        const el = $5(element2);
        let inViewport;
        const clone = el.clone();
        clone.removeAttr("data-role").css({
          visibility: "hidden",
          position: "absolute",
          display: "block"
        });
        el.parent().append(clone);
        inViewport = this.inViewport(clone[0]);
        clone.remove();
        return !inViewport;
      },
      inViewport: function(el) {
        const rect = this.rect(el);
        return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (globalThis.innerHeight || document.documentElement.clientHeight) && rect.right <= (globalThis.innerWidth || document.documentElement.clientWidth);
      },
      viewportOutByWidth: function(el) {
        const rect = this.rect(el);
        const w5 = globalThis.innerWidth || document.documentElement.clientWidth;
        return rect.right > w5;
      },
      viewportOutByHeight: function(el) {
        const rect = this.rect(el);
        const h3 = globalThis.innerHeight || document.documentElement.clientHeight;
        return rect.bottom > h3;
      },
      viewportOut: function(el) {
        return this.viewportOutByWidth(el) || this.viewportOutByHeight(el);
      },
      rect: function(el) {
        return el.getBoundingClientRect();
      },
      getCursorPosition: function(el, e2) {
        const a3 = this.rect(el);
        return {
          x: this.pageXY(e2).x - a3.left - globalThis.scrollX,
          y: this.pageXY(e2).y - a3.top - globalThis.scrollY
        };
      },
      getCursorPositionX: function(el, e2) {
        return this.getCursorPosition(el, e2).x;
      },
      getCursorPositionY: function(el, e2) {
        return this.getCursorPosition(el, e2).y;
      },
      objectLength: function(obj) {
        return Object.keys(obj).length;
      },
      percent: function(total, part, round_value) {
        if (total === 0) {
          return 0;
        }
        const result = part * 100 / total;
        return round_value === true ? Math.round(result) : Math.round(result * 100) / 100;
      },
      objectShift: function(obj) {
        let min = 0;
        $5.each(obj, function(i3) {
          if (min === 0) {
            min = i3;
          } else {
            if (min > i3) {
              min = i3;
            }
          }
        });
        delete obj[min];
        return obj;
      },
      objectDelete: function(obj, key) {
        if (key in obj) delete obj[key];
      },
      arrayDeleteByMultipleKeys: function(arr, keys) {
        keys.forEach(function(ind) {
          delete arr[ind];
        });
        return arr.filter(function(item) {
          return item !== void 0;
        });
      },
      arrayDelete: function(arr, val) {
        const i3 = arr.indexOf(val);
        if (i3 > -1) arr.splice(i3, 1);
      },
      arrayDeleteByKey: function(arr, key) {
        arr.splice(key, 1);
      },
      nvl: function(data, other) {
        return data === void 0 || data === null ? other : data;
      },
      objectClone: function(obj) {
        const copy = {};
        for (const key in obj) {
          if ($5.hasProp(obj, key)) {
            copy[key] = obj[key];
          }
        }
        return copy;
      },
      github: async function(repo, callback) {
        const res = await fetch(`https://api.github.com/repos/${repo}`);
        if (!res.ok) return;
        const data = await res.json();
        this.exec(callback, [data]);
      },
      pageHeight: function() {
        const body = document.body, html = document.documentElement;
        return Math.max(
          body.scrollHeight,
          body.offsetHeight,
          html.clientHeight,
          html.scrollHeight,
          html.offsetHeight
        );
      },
      cleanPreCode: function(selector) {
        const els = Array.prototype.slice.call(
          document.querySelectorAll(selector),
          0
        );
        els.forEach(function(el) {
          const txt = el.textContent.replace(/^[\r\n]+/, "").replace(/\s+$/g, "");
          if (/^\S/gm.test(txt)) {
            el.textContent = txt;
            return;
          }
          let mat, str2, re3 = /^[\t ]+/gm, len, min = 1e3;
          while (mat = re3.exec(txt)) {
            len = mat[0].length;
            if (len < min) {
              min = len;
              str2 = mat[0];
            }
          }
          if (min === 1e3) return;
          el.textContent = txt.replace(new RegExp("^" + str2, "gm"), "").trim();
        });
      },
      coords: function(element2) {
        const el = $5(element2)[0];
        const box = el.getBoundingClientRect();
        return {
          top: box.top + globalThis.pageYOffset,
          left: box.left + globalThis.pageXOffset
        };
      },
      /**
      * @param {TouchEvent|Event|MouseEvent} e
      * @param t where: client, screen, or page
      * @param s source: touches or changedTouches
      */
      positionXY: function(e2, t, s3) {
        switch (t) {
          case "client":
            return this.clientXY(e2, s3);
          case "screen":
            return this.screenXY(e2, s3);
          case "page":
            return this.pageXY(e2, s3);
          default:
            return { x: 0, y: 0 };
        }
      },
      /**
       *
       * @param {TouchEvent|Event|MouseEvent} e
       * @param t source: touches or changedTouches
       * @returns {{x: (*), y: (*)}}
       */
      clientXY: function(e2, t = "touches") {
        return {
          x: e2[t] ? e2[t][0].clientX : e2.clientX,
          y: e2[t] ? e2[t][0].clientY : e2.clientY
        };
      },
      /**
       *
       * @param {TouchEvent|Event|MouseEvent} e
       * @param t source: touches or changedTouches
       * @returns {{x: (*), y: (*)}}
       */
      screenXY: function(e2, t = "touches") {
        return {
          x: e2[t] ? e2[t][0].screenX : e2.screenX,
          y: e2[t] ? e2[t][0].screenY : e2.screenY
        };
      },
      /**
       *
       * @param {TouchEvent|Event|MouseEvent} e
       * @param t source: touches or changedTouches
       * @returns {{x: (*), y: (*)}}
       */
      pageXY: function(e2, t = "touches") {
        return {
          x: e2[t] ? e2[t][0].pageX : e2.pageX,
          y: e2[t] ? e2[t][0].pageY : e2.pageY
        };
      },
      isRightMouse: function(e2) {
        return "which" in e2 ? e2.which === 3 : "button" in e2 ? e2.button === 2 : void 0;
      },
      hiddenElementSize: function(el, includeMargin) {
        let width, height, clone = $5(el).clone(true);
        clone.removeAttr("data-role").css({
          visibility: "hidden",
          position: "absolute",
          display: "block"
        });
        $5("body").append(clone);
        if (!this.isValue(includeMargin)) {
          includeMargin = false;
        }
        width = clone.outerWidth(includeMargin);
        height = clone.outerHeight(includeMargin);
        clone.remove();
        return {
          width,
          height
        };
      },
      getStyle: function(element2) {
        const el = $5(element2)[0];
        return globalThis.getComputedStyle(el);
      },
      getStyleOne: function(el, property) {
        return this.getStyle(el).getPropertyValue(property);
      },
      getInlineStyles: function(element2) {
        let i3, l3, styles = {}, el = $5(element2)[0];
        for (i3 = 0, l3 = el.style.length; i3 < l3; i3++) {
          const s3 = el.style[i3];
          styles[s3] = el.style[s3];
        }
        return styles;
      },
      encodeURI: function(str2) {
        return encodeURI(str2).replace(/%5B/g, "[").replace(/%5D/g, "]");
      },
      updateURIParameter: function(uri, key, value) {
        const re3 = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
        const separator = uri.indexOf("?") !== -1 ? "&" : "?";
        if (uri.match(re3)) {
          return uri.replace(re3, "$1" + key + "=" + value + "$2");
        } else {
          return uri + separator + key + "=" + value;
        }
      },
      getURIParameter: function(url, name2) {
        if (!url) url = globalThis.location.href;
        name2 = name2.replace(/[\[\]]/g, "\\$&");
        const regex = new RegExp("[?&]" + name2 + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return "";
        return decodeURIComponent(results[2].replace(/\+/g, " "));
      },
      getLocales: function() {
        return Object.keys(Metro2.locales);
      },
      addLocale: function(locale) {
        Metro2.locales = $5.extend({}, Metro2.locales, locale);
      },
      aspectRatioH: function(width, a3) {
        if (a3 === "16/9") return width * 9 / 16;
        if (a3 === "21/9") return width * 9 / 21;
        if (a3 === "4/3") return width * 3 / 4;
      },
      aspectRatioW: function(height, a3) {
        if (a3 === "16/9") return height * 16 / 9;
        if (a3 === "21/9") return height * 21 / 9;
        if (a3 === "4/3") return height * 4 / 3;
      },
      valueInObject: function(obj, value) {
        return Object.values(obj).indexOf(value) > -1;
      },
      keyInObject: function(obj, key) {
        return Object.keys(obj).indexOf(key) > -1;
      },
      inObject: function(obj, key, val) {
        return obj[key] !== void 0 && obj[key] === val;
      },
      newCssSheet: function(media) {
        const style = document.createElement("style");
        if (media !== void 0) {
          style.setAttribute("media", media);
        }
        style.appendChild(document.createTextNode(""));
        document.head.appendChild(style);
        return style.sheet;
      },
      addCssRule: function(sheet, selector, rules, index) {
        sheet.insertRule(selector + "{" + rules + "}", index);
      },
      media: function(query) {
        return globalThis.matchMedia(query).matches;
      },
      mediaModes: function() {
        return globalThis["METRO_MEDIA"];
      },
      mediaExist: function(media) {
        return globalThis["METRO_MEDIA"].indexOf(media) > -1;
      },
      inMedia: function(media) {
        return globalThis["METRO_MEDIA"].indexOf(media) > -1 && globalThis["METRO_MEDIA"].indexOf(media) === globalThis["METRO_MEDIA"].length - 1;
      },
      isValue: function(val) {
        return val !== void 0 && val !== null && val !== "";
      },
      isNull: function(val) {
        return val === void 0 || val === null;
      },
      isNegative: function(val) {
        return parseFloat(val) < 0;
      },
      isPositive: function(val) {
        return parseFloat(val) > 0;
      },
      isZero: function(val) {
        return parseFloat(val.toFixed(2)) === 0;
      },
      between: function(val, bottom, top, equals) {
        return equals === true ? val >= bottom && val <= top : val > bottom && val < top;
      },
      parseMoney: function(val) {
        return Number(parseFloat(val.replace(/[^0-9-.]/g, "")));
      },
      parseCard: function(val) {
        return val.replace(/[^0-9]/g, "");
      },
      parsePhone: function(val) {
        return this.parseCard(val);
      },
      parseNumber: function(val, thousand, decimal) {
        return val.replace(new RegExp("\\" + thousand, "g"), "").replace(new RegExp("\\" + decimal, "g"), ".");
      },
      nearest: function(val, precision, down) {
        val /= precision;
        val = Math[down === true ? "floor" : "ceil"](val) * precision;
        return val;
      },
      bool: function(value) {
        switch (value) {
          case true:
          case "true":
          case 1:
          case "1":
          case "on":
          case "yes":
            return true;
          default:
            return false;
        }
      },
      decCount: function(v4) {
        return v4 % 1 === 0 ? 0 : v4.toString().split(".")[1].length;
      },
      classNames: function() {
        const args = Array.prototype.slice.call(arguments, 0);
        const classes = [];
        for (let a3 of args) {
          if (!a3) continue;
          if (typeof a3 === "string") {
            classes.push(a3);
          } else if (Metro2.utils.isObject(a3)) {
            for (let k4 in a3) {
              if (a3[k4]) {
                classes.push(k4);
              }
            }
          } else {
            Metro2.utils.nothing();
          }
        }
        return classes.join(" ");
      },
      join: function() {
        const values = Array.prototype.slice.call(arguments, 0);
        const sep = values.pop();
        const classes = [];
        for (let a3 of values) {
          if (!a3) continue;
          classes.push(Metro2.utils.isObject(a3) ? Object.values(a3)[0] : a3);
        }
        return classes.join(sep);
      },
      copy2clipboard: function(v4, cb) {
        navigator.clipboard.writeText(v4).then(function() {
          Metro2.utils.exec(cb, [v4]);
        });
      },
      getCssVar: function(v4) {
        const root = document.documentElement;
        const style = getComputedStyle(root);
        return style.getPropertyValue(v4);
      },
      scrollTo: function(element2, options) {
        const elem = typeof element2 === "string" ? $5(element2)[0] : element2;
        elem.scrollIntoView({
          ...options,
          behavior: "smooth",
          block: "start"
        });
      }
    };
    if (globalThis["METRO_GLOBAL_COMMON"] === true) {
      globalThis["Utils"] = Metro2.utils;
    }
  })(Metro, Dom);

  // source/components/carousel/animations.js
  ((Metro2, $5) => {
    "use strict";
    const AnimationDefaultConfig = {
      duration: METRO_ANIMATION_DURATION,
      ease: "linear"
    };
    Metro2.Effects = {
      switchIn: (el) => {
        $5(el).hide().css({
          left: 0,
          top: 0
        }).show();
      },
      switchOut: (el) => {
        $5(el).hide();
      },
      switch: function(current, next) {
        this.switchOut(current);
        this.switchIn(next);
      },
      slideUpIn: (el, o2) => {
        const $el = $5(el);
        const h3 = $el.parent().outerHeight(true);
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          top: h3,
          left: 0,
          zIndex: 2
        }).animate({
          draw: {
            top: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideUpOut: (el, o2) => {
        const $el = $5(el);
        const h3 = $el.parent().outerHeight(true);
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            top: -h3,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideUp: function(current, next, o2) {
        this.slideUpOut(current, o2);
        this.slideUpIn(next, o2);
      },
      slideDownIn: (el, o2) => {
        const $el = $5(el);
        const h3 = $el.parent().outerHeight(true);
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          left: 0,
          top: -h3,
          zIndex: 2
        }).animate({
          draw: {
            top: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideDownOut: (el, o2) => {
        const $el = $5(el);
        const h3 = $el.parent().outerHeight(true);
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            top: h3,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideDown: function(current, next, o2) {
        this.slideDownOut(current, o2);
        this.slideDownIn(next, o2);
      },
      slideLeftIn: (el, o2) => {
        const $el = $5(el);
        const w5 = $el.parent().outerWidth(true);
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          left: w5,
          zIndex: 2
        }).animate({
          draw: {
            left: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideLeftOut: (el, o2) => {
        const $el = $5(el);
        const w5 = $el.parent().outerWidth(true);
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            left: -w5,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideLeft: function(current, next, o2) {
        this.slideLeftOut(current, o2);
        this.slideLeftIn(next, o2);
      },
      slideRightIn: (el, o2) => {
        const $el = $5(el);
        const w5 = $el.parent().outerWidth(true);
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          left: -w5,
          zIndex: 2
        }).animate({
          draw: {
            left: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideRightOut: (el, o2) => {
        const $el = $5(el);
        const w5 = $el.parent().outerWidth(true);
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            left: w5,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideRight: function(current, next, o2) {
        this.slideRightOut(current, o2);
        this.slideRightIn(next, o2);
      },
      fadeIn: (el, o2) => {
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        const $el = $5(el);
        $el.css({
          top: 0,
          left: 0,
          opacity: 0
        }).animate({
          draw: {
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      fadeOut: (el, o2) => {
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        const $el = $5(el);
        $el.animate({
          draw: {
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      fade: function(current, next, o2) {
        this.fadeOut(current, o2);
        this.fadeIn(next, o2);
      },
      zoomIn: (el, o2) => {
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        const $el = $5(el);
        $el.css({
          top: 0,
          left: 0,
          opacity: 0,
          transform: "scale(3)",
          zIndex: 2
        }).animate({
          draw: {
            scale: 1,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      zoomOut: (el, o2) => {
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        const $el = $5(el);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            scale: 3,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      zoom: function(current, next, o2) {
        this.zoomOut(current, o2);
        this.zoomIn(next, o2);
      },
      swirlIn: (el, o2) => {
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        const $el = $5(el);
        $el.css({
          top: 0,
          left: 0,
          opacity: 0,
          transform: "scale(3) rotate(180deg)",
          zIndex: 2
        }).animate({
          draw: {
            scale: 1,
            rotate: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      swirlOut: (el, o2) => {
        const op = $5.extend({}, AnimationDefaultConfig, o2);
        const $el = $5(el);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            scale: 3,
            rotate: "180deg",
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      swirl: function(current, next, o2) {
        this.swirlOut(current, o2);
        this.swirlIn(next, o2);
      }
    };
  })(Metro, Dom);

  // source/components/accordion/accordion.js
  ((Metro2, $5) => {
    "use strict";
    let AccordionDefaultConfig = {
      accordionDeferred: 0,
      showMarker: true,
      material: false,
      duration: METRO_ANIMATION_DURATION,
      oneFrame: true,
      showActive: true,
      clsFrame: "",
      clsHeading: "",
      clsContent: "",
      clsAccordion: "",
      clsActiveFrame: "",
      clsActiveFrameHeading: "",
      clsActiveFrameContent: "",
      onFrameOpen: Metro2.noop,
      onFrameBeforeOpen: Metro2.noop_true,
      onFrameClose: Metro2.noop,
      onFrameBeforeClose: Metro2.noop_true,
      onAccordionCreate: Metro2.noop
    };
    Metro2.accordionSetup = (options) => {
      AccordionDefaultConfig = $5.extend({}, AccordionDefaultConfig, options);
    };
    if (typeof globalThis.metroAccordionSetup !== "undefined") {
      Metro2.accordionSetup(globalThis.metroAccordionSetup);
    }
    Metro2.Component("accordion", {
      init: function(options, elem) {
        this._super(elem, options, AccordionDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("accordionCreate", {
          element: element2
        });
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const frames = element2.children(".frame");
        const active = element2.children(".frame.active");
        let frame_to_open;
        if (!element2.id()) {
          element2.id(Hooks.useId("accordion"));
        }
        element2.addClass("accordion").addClass(o2.clsAccordion);
        frames.addClass(o2.clsFrame).each(function() {
          const el = $5(this);
          const heading = el.children(".heading");
          const content = el.children(".content");
          const headingId = Hooks.useId("accordion-heading");
          const contentId = Hooks.useId("accordion-content");
          heading.attr({
            "id": headingId,
            "role": "button",
            "aria-expanded": el.hasClass("active") ? "true" : "false",
            "aria-controls": contentId,
            "tabindex": "0"
          });
          content.attr({
            "id": contentId,
            "role": "region",
            "aria-labelledby": headingId
          });
          heading.addClass(o2.clsHeading);
          content.addClass(o2.clsContent);
        });
        if (o2.showMarker === true) {
          element2.addClass("marker-on");
        }
        if (o2.material === true) {
          element2.addClass("material");
        }
        if (active.length === 0) {
          frame_to_open = frames[0];
        } else {
          frame_to_open = active[0];
        }
        this._hideAll();
        if (o2.showActive === true) {
          if (o2.oneFrame === true) {
            this._openFrame(frame_to_open);
          } else {
            $5.each(active, function() {
              that._openFrame(this);
            });
          }
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const active = element2.children(".frame.active");
        element2.on("keydown", ".heading", function(e2) {
          const heading = $5(this);
          const frame = heading.parent();
          if (heading.closest(".accordion")[0] !== element2[0]) {
            return false;
          }
          if (e2.keyCode === 13 || e2.keyCode === 32) {
            e2.preventDefault();
            if (frame.hasClass("active")) {
              if (!(active.length === 1 && o2.oneFrame)) {
                that._closeFrame(frame);
              }
            } else {
              that._openFrame(frame);
            }
          }
          if (e2.keyCode === 38 || e2.keyCode === 40) {
            e2.preventDefault();
            const frames = element2.children(".frame");
            const currentIndex = frames.index(frame);
            let nextIndex;
            if (e2.keyCode === 38) {
              nextIndex = (currentIndex - 1 + frames.length) % frames.length;
            } else {
              nextIndex = (currentIndex + 1) % frames.length;
            }
            frames.eq(nextIndex).children(".heading").focus();
          }
        });
        element2.on(Metro2.events.click, ".heading", function() {
          const heading = $5(this);
          const frame = heading.parent();
          if (heading.closest(".accordion")[0] !== element2[0]) {
            return false;
          }
          if (frame.hasClass("active")) {
            if (active.length === 1 && o2.oneFrame) {
            } else {
              that._closeFrame(frame);
            }
          } else {
            that._openFrame(frame);
          }
        });
      },
      _openFrame: function(f5) {
        const element2 = this.element;
        const o2 = this.options;
        const frame = $5(f5);
        if (Metro2.utils.exec(o2.onFrameBeforeOpen, [frame[0]], element2[0]) === false) {
          return false;
        }
        if (o2.oneFrame === true) {
          this._closeAll(frame[0]);
        }
        frame.addClass("active").addClass(o2.clsActiveFrame);
        frame.children(".heading").addClass(o2.clsActiveFrameHeading);
        frame.children(".content").addClass(o2.clsActiveFrameContent).slideDown(o2.duration);
        this._fireEvent("frameOpen", {
          frame: frame[0]
        });
      },
      _closeFrame: function(f5) {
        const element2 = this.element;
        const o2 = this.options;
        const frame = $5(f5);
        if (!frame.hasClass("active")) {
          return;
        }
        if (Metro2.utils.exec(o2.onFrameBeforeClose, [frame[0]], element2[0]) === false) {
          return;
        }
        frame.removeClass("active").removeClass(o2.clsActiveFrame);
        frame.children(".heading").removeClass(o2.clsActiveFrameHeading);
        frame.children(".content").removeClass(o2.clsActiveFrameContent).slideUp(o2.duration);
        this._fireEvent("frameClose", {
          frame: frame[0]
        });
      },
      _closeAll: function(skip) {
        const that = this;
        const element2 = this.element;
        const frames = element2.children(".frame");
        $5.each(frames, function() {
          if (skip === this) return;
          that._closeFrame(this);
        });
      },
      _hideAll: function() {
        const element2 = this.element;
        const frames = element2.children(".frame");
        $5.each(frames, function() {
          $5(this).children(".content").hide();
        });
      },
      _openAll: function() {
        const that = this;
        const element2 = this.element;
        const frames = element2.children(".frame");
        $5.each(frames, function() {
          that._openFrame(this);
        });
      },
      open: function(i3) {
        const frame = this.element.children(".frame").eq(i3);
        this._openFrame(frame);
      },
      close: function(i3) {
        const frame = this.element.children(".frame").eq(i3);
        this._closeFrame(frame);
      },
      toggle: function(i3) {
        const frame = this.element.children(".frame").eq(i3);
        if (frame.hasClass("active")) {
          this._closeFrame(frame);
        } else {
          this._openFrame(frame);
        }
      },
      getActive: function() {
        const element2 = this.element;
        const frames = element2.children(".frame");
        const active = [];
        frames.each(function(index) {
          if ($5(this).hasClass("active")) {
            active.push(index);
          }
        });
        return active;
      },
      changeAttribute: (attr, newVal) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".heading");
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/action-button/action-button.js
  ((Metro2, $5) => {
    "use strict";
    let ActionButtonDefaultConfig = {
      onClick: Metro2.noop,
      onActionClick: Metro2.noop,
      onActionButtonCreate: Metro2.noop
    };
    Metro2.actionButtonSetup = (options) => {
      ActionButtonDefaultConfig = $5.extend({}, ActionButtonDefaultConfig, options);
    };
    if (typeof globalThis.metroActionButtonSetup !== "undefined") {
      Metro2.actionButtonSetup(globalThis.metroActionButtonSetup);
    }
    Metro2.Component("action-button", {
      init: function(options, elem) {
        this._super(elem, options, ActionButtonDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("action-button-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const actions = element2.find(".actions li, .actions button");
        element2.addClass("action-button");
        element2.cssVar("num-actions", actions.length);
        if (actions.length > 8) {
          element2.cssVar("action-shift", `${60 + (actions.length - 8) * 6}px`);
        }
        actions.each(function(index) {
          $5(this).cssVar("action-index", index).addClass("sub-action");
        });
        element2.children("button").addClass("main-action");
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        element2.on(Metro2.events.click, ".actions li, .actions button", function(e2) {
          that._fireEvent("action-click", { action: this });
        });
        element2.on(Metro2.events.click, ".main-action", function(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          $5(this).toggleClass("active");
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
    $5(document).on("click", (e2) => {
      $5("[data-role-actionbutton]").each((i3, el) => {
        $5(el).children("button").removeClass("active");
      });
    });
  })(Metro, Dom);

  // source/components/dialog/dialog.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var DialogDefaultConfig = {
      dialogDeferred: 0,
      closeButton: false,
      leaveOverlayOnClose: false,
      toTop: false,
      toBottom: false,
      title: "",
      content: "",
      customButtons: null,
      actionsAlign: "right",
      defaultActions: true,
      defaultActionButtons: "ok,cancel,help",
      overlay: true,
      overlayColor: "#000000",
      overlayAlpha: 0.5,
      overlayClickClose: false,
      width: "auto",
      height: "auto",
      closeAction: true,
      clsDialog: "",
      clsTitle: "",
      clsContent: "",
      clsAction: "",
      clsDefaultAction: "",
      clsOverlay: "",
      autoHide: 0,
      removeOnClose: false,
      show: false,
      _runtime: false,
      onOk: Metro2.noop,
      onCancel: Metro2.noop,
      onHelp: Metro2.noop,
      onShow: Metro2.noop,
      onHide: Metro2.noop,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onDialogCreate: Metro2.noop
    };
    Metro2.dialogSetup = function(options) {
      DialogDefaultConfig = $5.extend({}, DialogDefaultConfig, options);
    };
    if (typeof globalThis["metroDialogSetup"] !== "undefined") {
      Metro2.dialogSetup(globalThis["metroDialogSetup"]);
    }
    Metro2.Component("dialog", {
      _counter: 0,
      init: function(options, elem) {
        this._super(elem, options, DialogDefaultConfig, {
          interval: null,
          overlay: null,
          id: Utils.elementId("dialog")
        });
        return this;
      },
      _create: function() {
        this._build();
      },
      _build: function() {
        var that = this, element2 = this.element, o2 = this.options, strings = this.strings;
        var body = $5("body");
        var overlay;
        element2.addClass("dialog");
        if (o2.title !== "") {
          this.setTitle(o2.title);
        }
        if (o2.content !== "") {
          this.setContent(o2.content);
        }
        if (o2.defaultActions === true || o2.customButtons) {
          var buttons = element2.find(".dialog-actions");
          var button;
          if (buttons.length === 0) {
            buttons = $5("<div>").addClass("dialog-actions").addClass("text-" + o2.actionsAlign).appendTo(element2);
          }
          if (o2.defaultActions === true && element2.find(".dialog-actions > *").length === 0) {
            for (let b4 of o2.defaultActionButtons.toArray(",")) {
              button = $5("<button>").addClass(b4 !== "help" ? ".js-dialog-close" : "").addClass(o2.clsDefaultAction).html(strings[`label_${b4}`]);
              button.appendTo(buttons);
              if (b4 === "ok") {
                button.on(Metro2.events.click, function() {
                  Utils.exec(o2.onOk, [element2]);
                });
              }
              if (b4 === "help") {
                button.on(Metro2.events.click, function() {
                  Utils.exec(o2.onHelp, [element2]);
                });
              }
              if (b4 === "cancel") {
                button.on(Metro2.events.click, function() {
                  Utils.exec(o2.onCancel, [element2]);
                });
              }
            }
          }
          const customButtons = Utils.isObject(o2.customButtons);
          if (Array.isArray(customButtons))
            $5.each(customButtons, function() {
              var item = this;
              button = $5("<button>").addClass("button").addClass(item.cls).html(item.text);
              if (item.onclick)
                button.on(Metro2.events.click, function() {
                  Utils.exec(item.onclick, [element2]);
                });
              button.appendTo(buttons);
            });
        }
        if (o2.overlay === true) {
          overlay = this._overlay();
          this.overlay = overlay;
        }
        if (o2.closeAction === true) {
          element2.on(Metro2.events.click, ".js-dialog-close", function() {
            that.close();
          });
        }
        var closer = element2.find("closer");
        if (closer.length === 0) {
          closer = $5("<span>").addClass("closer js-dialog-close");
          closer.appendTo(element2);
        }
        if (o2.closeButton !== true) {
          closer.hide();
        }
        element2.css({
          height: o2.height,
          visibility: "hidden",
          top: "100%"
        });
        if (o2.width !== "auto") {
          element2.css({
            width: o2.width
          });
        }
        element2.addClass(o2.clsDialog);
        element2.find(".dialog-title").addClass(o2.clsTitle);
        element2.find(".dialog-content").addClass(o2.clsContent);
        element2.find(".dialog-actions").addClass(o2.clsAction);
        element2.appendTo(body);
        if (o2.show) {
          this.open();
        }
        $5(globalThis).on(
          Metro2.events.resize,
          function() {
            that.setPosition();
          },
          { ns: this.id }
        );
        this._fireEvent("dialog-create", {
          element: element2
        });
      },
      _overlay: function() {
        var o2 = this.options;
        var overlay = $5("<div>");
        overlay.addClass("overlay").addClass(o2.clsOverlay);
        if (o2.overlayColor === "transparent") {
          overlay.addClass("transparent");
        } else {
          overlay.css({
            background: Farbe.Routines.toRGBA(Farbe.Routines.parse(o2.overlayColor), o2.overlayAlpha)
          });
        }
        return overlay;
      },
      hide: function(callback) {
        var element2 = this.element, o2 = this.options;
        var timeout = 0;
        if (o2.onHide !== Metro2.noop) {
          timeout = 500;
          this._fireEvent("hide");
        }
        setTimeout(function() {
          Utils.exec(callback, null, element2[0]);
          element2.css({
            visibility: "hidden",
            top: "100%"
          });
        }, timeout);
      },
      show: function(callback) {
        var element2 = this.element;
        this.setPosition();
        element2.css({
          visibility: "visible"
        });
        this._fireEvent("show");
        Utils.exec(callback, null, element2[0]);
      },
      setPosition: function() {
        var element2 = this.element, o2 = this.options;
        var top, bottom;
        if (o2.toTop !== true && o2.toBottom !== true) {
          top = ($5(globalThis).height() - element2.outerHeight()) / 2;
          if (top < 0) {
            top = 0;
          }
          bottom = "auto";
        } else {
          if (o2.toTop === true) {
            top = 0;
            bottom = "auto";
          }
          if (o2.toTop !== true && o2.toBottom === true) {
            bottom = 0;
            top = "auto";
          }
        }
        element2.css({
          top,
          bottom,
          left: ($5(globalThis).width() - element2.outerWidth()) / 2
        });
      },
      setContent: function(c3) {
        var element2 = this.element;
        var content = element2.find(".dialog-content");
        if (content.length === 0) {
          content = $5("<div>").addClass("dialog-content");
          content.appendTo(element2);
        }
        if (!Utils.isQ(c3) && Utils.isFunc(c3)) {
          c3 = Utils.exec(c3);
        }
        if (Utils.isQ(c3)) {
          c3.appendTo(content);
        } else {
          content.html(c3);
        }
      },
      setTitle: function(t) {
        var element2 = this.element;
        var title = element2.find(".dialog-title");
        if (title.length === 0) {
          title = $5("<div>").addClass("dialog-title");
          title.appendTo(element2);
        }
        title.html(t);
      },
      close: function() {
        var that = this, element2 = this.element, o2 = this.options;
        if (!Utils.bool(o2.leaveOverlayOnClose)) {
          $5("body").find(".overlay").remove();
        }
        this.hide(function() {
          element2.data("open", false);
          that._fireEvent("close");
          if (o2.removeOnClose === true) {
            element2.remove();
          }
        });
      },
      open: function() {
        var that = this, element2 = this.element, o2 = this.options;
        if (o2.overlay === true && $5(".overlay").length === 0) {
          this.overlay.appendTo($5("body"));
          if (o2.overlayClickClose === true) {
            this.overlay.on(Metro2.events.click, function() {
              that.close();
            });
          }
        }
        this.show(function() {
          that._fireEvent("open");
          element2.data("open", true);
          if (parseInt(o2.autoHide) > 0) {
            setTimeout(function() {
              that.close();
            }, parseInt(o2.autoHide));
          }
        });
      },
      toggle: function() {
        var element2 = this.element;
        if (element2.data("open")) {
          this.close();
        } else {
          this.open();
        }
      },
      isOpen: function() {
        return this.element.data("open") === true;
      },
      /* eslint-disable-next-line */
      changeAttribute: function(attributeName) {
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.click, ".js-dialog-close");
        element2.find(".button").off(Metro2.events.click);
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
    Metro2.dialog = {
      isDialog: function(el) {
        return Utils.isMetroObject(el, "dialog");
      },
      open: function(el, content, title) {
        if (!this.isDialog(el)) {
          return false;
        }
        var dialog = Metro2.getPlugin(el, "dialog");
        if (title) {
          dialog.setTitle(title);
        }
        if (content) {
          dialog.setContent(content);
        }
        dialog.open();
      },
      close: function(el) {
        if (!this.isDialog(el)) {
          return false;
        }
        Metro2.getPlugin($5(el)[0], "dialog").close();
      },
      toggle: function(el) {
        if (!this.isDialog(el)) {
          return false;
        }
        Metro2.getPlugin($5(el)[0], "dialog").toggle();
      },
      isOpen: function(el) {
        if (!this.isDialog(el)) {
          return false;
        }
        Metro2.getPlugin($5(el)[0], "dialog").isOpen();
      },
      remove: function(el) {
        if (!this.isDialog(el)) {
          return false;
        }
        var dialog = Metro2.getPlugin($5(el)[0], "dialog");
        dialog.options.removeOnClose = true;
        dialog.close();
      },
      create: function(options) {
        var dlg;
        dlg = $5("<div>").appendTo($5("body"));
        var dlg_options = $5.extend(
          {},
          {
            show: true,
            closeAction: true,
            removeOnClose: true
          },
          options ? options : {}
        );
        dlg_options._runtime = true;
        return Metro2.makePlugin(dlg, "dialog", dlg_options);
      }
    };
  })(Metro, Dom);

  // source/components/activity/activity.js
  ((Metro2, $5) => {
    "use strict";
    let ActivityDefaultConfig = {
      activityDeferred: 0,
      type: "ring",
      style: "",
      size: 64,
      radius: 20,
      onActivityCreate: Metro2.noop
    };
    Metro2.activitySetup = (options) => {
      ActivityDefaultConfig = $5.extend({}, ActivityDefaultConfig, options);
    };
    if (typeof globalThis.metroActivitySetup !== "undefined") {
      Metro2.activitySetup(globalThis.metroActivitySetup);
    }
    Metro2.Component("activity", {
      init: function(options, elem) {
        this._super(elem, options, ActivityDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        let i3;
        let wrap;
        element2.html("").addClass(o2.style === "dark" ? "dark-side" : o2.style === "color" ? "color-style" : "").addClass(`activity-${o2.type}`);
        function _metro() {
          for (i3 = 0; i3 < 5; i3++) {
            $5("<div/>").addClass("circle").appendTo(element2);
          }
        }
        function _square() {
          for (i3 = 0; i3 < 4; i3++) {
            $5("<div/>").addClass("square").appendTo(element2);
          }
        }
        function _cycle() {
          $5("<div/>").addClass("cycle").appendTo(element2);
        }
        function _ring() {
          for (i3 = 0; i3 < 5; i3++) {
            wrap = $5("<div/>").addClass("wrap").appendTo(element2);
            $5("<div/>").addClass("circle").appendTo(wrap);
          }
        }
        function _simple() {
          $5(`
                    <svg class="circular">
                        <circle class="path" 
                                cx="${o2.size / 2}" 
                                cy="${o2.size / 2}" 
                                r="${o2.radius}" 
                                fill="none" 
                                stroke-width="2" 
                                stroke-miterlimit="10"
                        />
                    </svg>
                `).appendTo(element2);
        }
        function _atom() {
          for (i3 = 0; i3 < 3; i3++) {
            $5("<span/>").addClass("electron").appendTo(element2);
          }
        }
        function _bars() {
          for (i3 = 0; i3 < 6; i3++) {
            $5("<span/>").addClass("bar").appendTo(element2);
          }
        }
        switch (o2.type) {
          case "metro":
            _metro();
            break;
          case "square":
            _square();
            break;
          case "cycle":
            _cycle();
            break;
          case "simple":
            _simple();
            break;
          case "atom":
            _atom();
            break;
          case "bars":
            _bars();
            break;
          default:
            _ring();
        }
        this._fireEvent("activity-create", {
          element: element2
        });
      },
      changeAttribute: (attributeName) => {
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2.activity = {
      open: (options = {}) => {
        const o2 = options;
        const activity = `<div data-role="activity" data-type="${o2.type ? o2.type : "cycle"}" data-style="${o2.style ? o2.style : "color"}"></div>`;
        const text = o2.text ? `<div class="text-center">${o2.text}</div>` : "";
        return Metro2.dialog.create({
          content: activity + text,
          defaultActions: false,
          clsContent: "d-flex flex-column flex-center bg-transparent no-shadow w-auto",
          clsDialog: "no-border no-shadow bg-transparent global-dialog",
          autoHide: o2.autoHide ? o2.autoHide : 0,
          overlayClickClose: o2.overlayClickClose === true,
          overlayColor: o2.overlayColor ? o2.overlayColor : "#000000",
          overlayAlpha: o2.overlayAlpha ? o2.overlayAlpha : 0.5,
          clsOverlay: "global-overlay"
        });
      },
      close: (a3) => {
        Metro2.dialog.close(a3);
      }
    };
  })(Metro, Dom);

  // source/components/adblock/adblock.js
  ((Metro2, $5) => {
    "use strict";
    let AdblockDefaultConfig = {
      adblockDeferred: 0,
      checkInterval: 1e3,
      fireOnce: true,
      checkStop: 10,
      localhost: false,
      onAlert: Metro2.noop,
      onFishingStart: Metro2.noop,
      onFishingDone: Metro2.noop
    };
    Metro2.adblockSetup = (options) => {
      AdblockDefaultConfig = $5.extend({}, AdblockDefaultConfig, options);
    };
    if (typeof globalThis.metroAdblockSetup !== "undefined") {
      Metro2.adblockSetup(globalThis.metroAdblockSetup);
    }
    const Adblock = {
      bite: () => {
        const classes = "adblock-bite adsense google-adsense dblclick advert topad top_ads topAds textads sponsoredtextlink_container show_ads right-banner rekl mpu module-ad mid_ad mediaget horizontal_ad headerAd contentAd brand-link bottombanner bottom_ad_block block_ad bannertop banner-right banner-body b-banner b-article-aside__banner b-advert adwrapper adverts advertisment advertisement:not(body) advertise advert_list adtable adsense adpic adlist adleft adinfo adi adholder adframe addiv ad_text ad_space ad_right ad_links ad_body ad_block ad_Right adTitle adText";
        $5("<div>").addClass(classes.split(" ").shuffle().join(" ")).css({
          position: "fixed",
          height: 1,
          width: 1,
          overflow: "hidden",
          visibility: "visible",
          top: 0,
          left: 0
        }).append($5("<a href='https://dblclick.net'>").html("dblclick.net")).appendTo("body");
        if (Adblock.options.adblockDeferred) {
          setTimeout(() => {
            Adblock.fishing();
          }, Adblock.options.adblockDeferred);
        } else Adblock.fishing();
      },
      fishing: () => {
        const o2 = Adblock.options;
        let checks = typeof o2.fireOnce === "number" ? o2.fireOnce : 0;
        let checkStop = o2.checkStop;
        let interval = false;
        const run = () => {
          const a3 = $5(".adsense.google-adsense.dblclick.advert.adblock-bite");
          const b4 = a3.find("a");
          const done = () => {
            clearInterval(interval);
            Metro2.utils.exec(o2.onFishingDone);
            $5(globalThis).fire("fishing-done");
            a3.remove();
          };
          if (!o2.localhost && $5.localhost) {
            done();
            return;
          }
          if (!a3.length || !b4.length || a3.css("display").indexOf("none") > -1 || b4.css("display").indexOf("none") > -1) {
            Metro2.utils.exec(Adblock.options.onAlert);
            $5(globalThis).fire("adblock-alert");
            if (Adblock.options.fireOnce === true) {
              done();
            } else {
              checks--;
              if (checks === 0) {
                done();
              }
            }
          } else {
            if (checkStop !== false) {
              checkStop--;
              if (checkStop === 0) {
                done();
              }
            }
          }
        };
        Metro2.utils.exec(o2.onFishingStart);
        $5(globalThis).fire("fishing-start");
        interval = setInterval(() => {
          run();
        }, Adblock.options.checkInterval);
        run();
      }
    };
    Metro2.Adblock = Adblock;
    $5(() => {
      Adblock.options = $5.extend({}, AdblockDefaultConfig);
      $5(globalThis).on("metro-initiated", () => {
        Adblock.bite();
      });
    });
  })(Metro, Dom);

  // source/components/analog-clock/analog-clock.js
  ((Metro2, $5) => {
    "use strict";
    let AnalogClockDefaultConfig = {
      icon: null,
      showNumbers: false,
      showMoon: true,
      showDay: true,
      showDigitalClock: true,
      timeFormat: 24,
      onAnalogClockCreate: Metro2.noop
    };
    Metro2.analogClockSetup = (options) => {
      AnalogClockDefaultConfig = $5.extend({}, AnalogClockDefaultConfig, options);
    };
    if (typeof globalThis.metroAnalogClockSetup !== "undefined") {
      Metro2.analogClockSetup(globalThis.metroAnalogClockSetup);
    }
    Metro2.Component("analog-clock", {
      init: function(options, elem) {
        this._super(elem, options, AnalogClockDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("analog-clock-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const now = datetime();
        element2.addClass("analog-clock");
        if (o2.showNumbers) {
          element2.addClass("show-numbers");
        }
        for (let i3 = 1; i3 <= 12; i3++) {
          element2.append(`<label class="dash" style="--i: ${i3}"><span>${o2.showNumbers ? i3 : "|"}</span></label>`);
        }
        for (let i3 = 1; i3 <= 90; i3++) {
          if (i3 % 5 === 0) {
            continue;
          }
          element2.append(`<label class="secondary-dash" style="--i2: ${i3}"><span>|</span></label>`);
        }
        element2.append(`
                <div class="hands">
                    <div class="hour"></div>                
                    <div class="minute"></div>                
                    <div class="second"></div>                
                </div>
                  
            `);
        element2.append(`
                <div class="day-month">
                    <div class="day-month-inner">
                        <div class="day">${now.format("DD", this.locale)}</div>
                        <div class="month">${now.format("MMM", this.locale)}</div>                    
                    </div>
                    <div class="week-day">${now.format("dddd", this.locale)}</div>
                </div>
            `);
        if (o2.showDay === false) {
          element2.find(".day-month").hide();
        }
        element2.append(`
                <div class="digital-clock">
                    <div class="dc-hour">${now.format(o2.timeFormat === 24 ? "HH" : "hh", this.locale)}</div>
                    <div class="dc-minute">${now.format("mm", this.locale)}</div>
                    <div class="dc-second">${now.format("ss", this.locale)}</div>
                </div>
            `);
        if (o2.showDigitalClock === false) {
          element2.find(".digital-clock").hide();
        }
        if (o2.icon) {
          element2.append(`<div class="icon">${o2.icon}</div>`);
        }
        if (o2.showMoon === true) {
          element2.append(`<div class="moon"></div>`);
        }
        this._updateTime();
        setInterval(() => {
          element2.toggleClass("tick");
        }, 500);
      },
      _createEvents: () => {
      },
      _updateTime: function() {
        const element2 = this.element;
        const o2 = this.options;
        const secondHand = element2.find(".second");
        const minuteHand = element2.find(".minute");
        const hourHand = element2.find(".hour");
        const secondDig = element2.find(".dc-second");
        const minuteDig = element2.find(".dc-minute");
        const hourDig = element2.find(".dc-hour");
        const dayEl = element2.find(".day");
        const monthEl = element2.find(".month");
        const moonEl = element2.find(".moon");
        const updateTime = () => {
          const date = datetime();
          const sec = date.second() / 60 * 360;
          const min = date.minute() / 60 * 360;
          const hr4 = date.hour12() / 12 * 360;
          const day = date.format("DD", this.locale);
          const month = date.format("MMM", this.locale);
          const moon = date.moon();
          secondHand[0].style.transform = `rotate(${sec}deg)`;
          minuteHand[0].style.transform = `rotate(${min}deg)`;
          hourHand[0].style.transform = `rotate(${hr4}deg)`;
          dayEl.html(day);
          monthEl.html(month);
          moonEl.removeClass("").addClass(`${moon.name}`);
          hourDig[0].innerHTML = date.format(o2.timeFormat === 24 ? "HH" : "hh", this.locale);
          minuteDig[0].innerHTML = date.format("mm", this.locale);
          secondDig[0].innerHTML = date.format("ss", this.locale);
        };
        updateTime();
        setInterval(updateTime, 1e3);
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/app-bar/app-bar.js
  ((Metro2, $5) => {
    "use strict";
    let AppBarDefaultConfig = {
      appbarDeferred: 0,
      expand: false,
      expandPoint: null,
      duration: 100,
      checkHamburgerColor: false,
      onMenuOpen: Metro2.noop,
      onMenuClose: Metro2.noop,
      onBeforeMenuOpen: Metro2.noop,
      onBeforeMenuClose: Metro2.noop,
      onMenuCollapse: Metro2.noop,
      onMenuExpand: Metro2.noop,
      onAppBarCreate: Metro2.noop
    };
    Metro2.appBarSetup = (options) => {
      AppBarDefaultConfig = $5.extend({}, AppBarDefaultConfig, options);
    };
    if (typeof globalThis.metroAppBarSetup !== "undefined") {
      Metro2.appBarSetup(globalThis.metroAppBarSetup);
    }
    Metro2.Component("app-bar", {
      init: function(options, elem) {
        this._super(elem, options, AppBarDefaultConfig, {
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = element2.attr("id") || Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("app-bar-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let hamburger;
        let menu;
        const elementColor = Metro2.utils.getStyleOne(element2, "background-color");
        element2.addClass("app-bar").attr("role", "navigation");
        hamburger = element2.find(".hamburger");
        if (hamburger.length === 0) {
          hamburger = $5("<button>").attr("type", "button").addClass("hamburger menu-down").attr("aria-label", "Toggle menu").attr("aria-expanded", "false").attr("aria-controls", `app-bar-menu-${this.id}`);
          for (let i3 = 0; i3 < 3; i3++) {
            $5("<span>").addClass("line").appendTo(hamburger);
          }
        }
        element2.prepend(hamburger);
        menu = element2.find(".app-bar-menu");
        if (menu.length > 0) {
          menu.attr("id", `app-bar-menu-${this.id}`);
          menu.attr("role", "menubar");
        }
        if (menu.length === 0) {
          hamburger.css("display", "none");
        } else {
          menu.find("li").attr("role", "menuitem");
          menu.find("li a").attr("tabindex", "0");
          menu.find("li:has(ul)").attr("aria-haspopup", "true");
          menu.find("li ul").attr("role", "menu").attr("aria-hidden", "true");
        }
        if (hamburger.css("display") === "block") {
          menu.hide().addClass("collapsed");
          hamburger.removeClass("hidden");
        } else {
          hamburger.addClass("hidden");
        }
        if (o2.expand === true) {
          element2.addClass("app-bar-expand");
          hamburger.addClass("hidden");
        } else {
          if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint)) {
            element2.addClass("app-bar-expand");
            hamburger.addClass("hidden");
          }
        }
        if (o2.checkHamburgerColor === true) {
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const menu = element2.find(".app-bar-menu");
        const hamburger = element2.find(".hamburger");
        element2.on(Metro2.events.click, ".hamburger", () => {
          if (menu.length === 0) return;
          const collapsed = menu.hasClass("collapsed");
          if (collapsed) {
            that.open();
          } else {
            that.close();
          }
        });
        hamburger.on("keydown", (e2) => {
          if (e2.keyCode === 13 || e2.keyCode === 32) {
            e2.preventDefault();
            hamburger.trigger("click");
          }
        });
        menu.find("li a").on("keydown", function(e2) {
          if (e2.keyCode === 13 || e2.keyCode === 32) {
            e2.preventDefault();
            $5(this).trigger("click");
          }
          if (e2.keyCode === 27) {
            e2.preventDefault();
            that.close();
            hamburger.focus();
          }
        });
        $5(globalThis).on(
          Metro2.events.resize,
          () => {
            if (o2.expand !== true) {
              if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint)) {
                element2.addClass("app-bar-expand");
                that._fireEvent("menu-expand");
              } else {
                element2.removeClass("app-bar-expand");
                that._fireEvent("menu-collapse");
              }
            }
            if (menu.length === 0) {
              hamburger.addClass("hidden");
              return;
            }
            menu.removeClass("opened").removeClass("collapsed");
            if (hamburger.css("display") !== "block") {
              hamburger.addClass("hidden");
              menu.show();
            } else {
              hamburger.removeClass("hidden");
              if (hamburger.hasClass("active")) {
                menu.removeClass("collapsed").addClass("opened");
              } else {
                menu.addClass("collapsed").removeClass("opened");
              }
            }
          },
          { ns: this.id }
        );
      },
      close: function() {
        const element2 = this.element;
        const o2 = this.options;
        const menu = element2.find(".app-bar-menu");
        const hamburger = element2.find(".hamburger");
        this._fireEvent("before-menu-close", {
          menu: menu[0]
        });
        hamburger.attr("aria-expanded", "false");
        menu.find("ul").attr("aria-hidden", "true");
        menu.slideUp(o2.duration, () => {
          menu.addClass("collapsed").removeClass("opened");
          hamburger.removeClass("active");
          this._fireEvent("menu-close", {
            menu: menu[0]
          });
        });
      },
      open: function() {
        const element2 = this.element;
        const o2 = this.options;
        const menu = element2.find(".app-bar-menu");
        const hamburger = element2.find(".hamburger");
        this._fireEvent("before-menu-open", {
          menu: menu[0]
        });
        hamburger.attr("aria-expanded", "true");
        menu.find("ul").attr("aria-hidden", "false");
        menu.slideDown(o2.duration, () => {
          menu.removeClass("collapsed").addClass("opened");
          hamburger.addClass("active");
          this._fireEvent("menu-open", {
            menu: menu[0]
          });
        });
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".hamburger");
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/audio-button/audio-button.js
  ((Metro2, $5) => {
    "use strict";
    let AudioButtonDefaultConfig = {
      audioVolume: 0.5,
      audioSrc: "",
      onAudioStart: Metro2.noop,
      onAudioEnd: Metro2.noop,
      onAudioButtonCreate: Metro2.noop
    };
    Metro2.audioButtonSetup = (options) => {
      AudioButtonDefaultConfig = $5.extend({}, AudioButtonDefaultConfig, options);
    };
    if (typeof globalThis.metroAudioButtonSetup !== "undefined") {
      Metro2.audioButtonSetup(globalThis.metroAudioButtonSetup);
    }
    Metro2.Component("audio-button", {
      init: function(options, elem) {
        this._super(elem, options, AudioButtonDefaultConfig, {
          audio: null,
          canPlay: null,
          id: Metro2.utils.elementId("audioButton")
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("audioButtonCreate", {
          element: element2
        });
      },
      _createStructure: function() {
        const o2 = this.options;
        this.audio = new Audio(o2.audioSrc);
        this.audio.volume = o2.audioVolume;
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        audio.addEventListener("loadeddata", () => {
          this.canPlay = true;
        });
        audio.addEventListener("ended", () => {
          this._fireEvent("audioEnd", {
            src: o2.audioSrc,
            audio
          });
        });
        element2.on(Metro2.events.click, () => {
          this.play();
        }, { ns: this.id });
      },
      play: function(cb) {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        if (o2.audioSrc !== "" && this.audio.duration && this.canPlay) {
          this._fireEvent("audioStart", {
            src: o2.audioSrc,
            audio
          });
          audio.pause();
          audio.currentTime = 0;
          audio.play();
          Metro2.utils.exec(cb, [audio], element2[0]);
        }
      },
      stop: function(cb) {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        audio.pause();
        audio.currentTime = 0;
        this._fireEvent("audioEnd", {
          src: o2.audioSrc,
          audio
        });
        Metro2.utils.exec(cb, [audio], element2[0]);
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        const changeSrc = () => {
          const src = element2.attr("data-audio-src");
          if (src && src.trim() !== "") {
            o2.audioSrc = src;
            audio.src = src;
          }
        };
        const changeVolume = () => {
          const volume = Number.parseFloat(element2.attr("data-audio-volume"));
          if (Number.isNaN(volume)) {
            return;
          }
          o2.audioVolume = volume;
          audio.volume = volume;
        };
        if (attributeName === "data-audio-src") {
          changeSrc();
        }
        if (attributeName === "data-audio-volume") {
          changeVolume();
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, { ns: this.id });
        element2.remove();
      }
    });
    Metro2.playSound = (data) => {
      const src = typeof data === "string" ? data : data.audioSrc;
      const volume = data?.audioVolume ? data.audioVolume : 0.5;
      if (!src) {
        return;
      }
      const audio = new Audio(src);
      audio.volume = Number.parseFloat(volume);
      audio.addEventListener("loadeddata", function() {
        if (data?.onAudioStart)
          Metro2.utils.exec(data.onAudioStart, [src], this);
        this.play();
      });
      audio.addEventListener("ended", function() {
        if (data?.onAudioEnd)
          Metro2.utils.exec(data.onAudioEnd, [null], this);
      });
    };
  })(Metro, Dom);

  // source/components/slider/slider.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var SliderDefaultConfig = {
      sliderDeferred: 0,
      roundValue: true,
      min: 0,
      max: 100,
      accuracy: 0,
      showMinMax: false,
      minMaxPosition: Metro2.position.TOP,
      value: 0,
      buffer: 0,
      hint: false,
      hintAlways: false,
      hintPosition: Metro2.position.TOP,
      hintMask: "$1",
      vertical: false,
      target: null,
      returnType: "value",
      // value or percent
      size: 0,
      label: null,
      clsSlider: "",
      clsBackside: "",
      clsComplete: "",
      clsBuffer: "",
      clsMarker: "",
      clsHint: "",
      clsMinMax: "",
      clsMin: "",
      clsMax: "",
      onStart: Metro2.noop,
      onStop: Metro2.noop,
      onMove: Metro2.noop,
      onSliderClick: Metro2.noop,
      onChange: Metro2.noop,
      onChangeValue: Metro2.noop,
      onChangeBuffer: Metro2.noop,
      onFocus: Metro2.noop,
      onBlur: Metro2.noop,
      onSliderCreate: Metro2.noop
    };
    Metro2.sliderSetup = function(options) {
      SliderDefaultConfig = $5.extend({}, SliderDefaultConfig, options);
    };
    if (typeof globalThis["metroSliderSetup"] !== "undefined") {
      Metro2.sliderSetup(globalThis["metroSliderSetup"]);
    }
    Metro2.Component("slider", {
      init: function(options, elem) {
        this._super(elem, options, SliderDefaultConfig, {
          slider: null,
          value: 0,
          percent: 0,
          pixel: 0,
          buffer: 0,
          keyInterval: false,
          id: Utils.elementId("slider")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        this._createSlider();
        this._createEvents();
        this.buff(o2.buffer);
        this.val(o2.value);
        this._fireEvent("slider-create", {
          element: element2
        });
      },
      _createSlider: function() {
        var element2 = this.element, o2 = this.options;
        var backside = $5("<div>").addClass("backside").addClass(o2.clsBackside);
        var complete = $5("<div>").addClass("complete").addClass(o2.clsComplete);
        var buffer = $5("<div>").addClass("buffer").addClass(o2.clsBuffer);
        var marker = $5("<button>").attr("type", "button").addClass("marker").addClass(o2.clsMarker);
        var hint = $5("<div>").addClass("hint").addClass(o2.hintPosition + "-side").addClass(o2.clsHint);
        var i3;
        var slider = element2.wrap("<div>").addClass("slider").addClass(element2[0].className).addClass(o2.clsSlider);
        if (o2.size > 0) {
          if (o2.vertical === true) {
            slider.outerHeight(o2.size);
          } else {
            slider.outerWidth(o2.size);
          }
        }
        if (o2.vertical === true) {
          slider.addClass("vertical-slider");
        }
        if (o2.hintAlways === true) {
          hint.css({
            display: "block"
          }).addClass("permanent-hint");
        }
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(slider);
          if (element2.id()) {
            label.attr("for", element2.id());
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
        }
        backside.appendTo(slider);
        complete.appendTo(slider);
        buffer.appendTo(slider);
        marker.appendTo(slider);
        hint.appendTo(marker);
        if (o2.showMinMax === true) {
          var min_max_wrapper = $5("<div>").addClass("slider-min-max").addClass(o2.clsMinMax);
          $5("<span>").addClass("slider-text-min").addClass(o2.clsMin).html(o2.min).appendTo(min_max_wrapper);
          $5("<span>").addClass("slider-text-max").addClass(o2.clsMax).html(o2.max).appendTo(min_max_wrapper);
          if (o2.minMaxPosition === Metro2.position.TOP) {
            min_max_wrapper.insertBefore(slider);
          } else {
            min_max_wrapper.insertAfter(slider);
          }
        }
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          for (i3 = 0; i3 < element2[0].style.length; i3++) {
            slider.css(element2[0].style[i3], element2.css(element2[0].style[i3]));
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.slider = slider;
      },
      _createEvents: function() {
        var that = this, slider = this.slider, o2 = this.options;
        var marker = slider.find(".marker");
        var hint = slider.find(".hint");
        marker.on(Metro2.events.startAll, function() {
          if (o2.hint === true && o2.hintAlways !== true) {
            hint.fadeIn(300);
          }
          $5(document).on(Metro2.events.moveAll, function(e2) {
            if (e2.cancelable) e2.preventDefault();
            that._move(e2);
            that._fireEvent("move", {
              val: that.value,
              percent: that.percent
            });
          }, { ns: that.id, passive: false });
          $5(document).on(Metro2.events.stopAll, function() {
            $5(document).off(Metro2.events.moveAll, { ns: that.id });
            $5(document).off(Metro2.events.stopAll, { ns: that.id });
            if (o2.hintAlways !== true) {
              hint.fadeOut(300);
            }
            that._fireEvent("stop", {
              val: that.value,
              percent: that.percent
            });
          }, { ns: that.id });
          that._fireEvent("start", {
            val: that.value,
            percent: that.percent
          });
        });
        marker.on(Metro2.events.focus, function() {
          that._fireEvent("focus", {
            val: that.value,
            percent: that.percent
          });
        });
        marker.on(Metro2.events.blur, function() {
          that._fireEvent("blur", {
            val: that.value,
            percent: that.percent
          });
        });
        marker.on(Metro2.events.keydown, function(e2) {
          var key = e2.keyCode ? e2.keyCode : e2.which;
          if ([37, 38, 39, 40].indexOf(key) === -1) {
            return;
          }
          var step = o2.accuracy === 0 ? 1 : o2.accuracy;
          if (that.keyInterval) {
            return;
          }
          that.keyInterval = setInterval(function() {
            var val = that.value;
            if (e2.keyCode === 37 || e2.keyCode === 40) {
              if (val - step < o2.min) {
                val = o2.min;
              } else {
                val -= step;
              }
            }
            if (e2.keyCode === 38 || e2.keyCode === 39) {
              if (val + step > o2.max) {
                val = o2.max;
              } else {
                val += step;
              }
            }
            that.value = that._correct(val);
            that.percent = that._convert(that.value, "val2prc");
            that.pixel = that._convert(that.percent, "prc2pix");
            that._redraw();
          }, 100);
          e2.preventDefault();
        });
        marker.on(Metro2.events.keyup, function() {
          clearInterval(that.keyInterval);
          that.keyInterval = false;
        });
        slider.on(Metro2.events.click, function(e2) {
          that._move(e2);
          that._fireEvent("slider-click", {
            val: that.value,
            percent: that.percent
          });
          that._fireEvent("stop", {
            val: that.value,
            percent: that.percent
          });
        });
        $5(globalThis).on(Metro2.events.resize, function() {
          that.val(that.value);
          that.buff(that.buffer);
        }, { ns: that.id });
      },
      _convert: function(v4, how) {
        var slider = this.slider, o2 = this.options;
        var length = (o2.vertical === true ? slider.outerHeight() : slider.outerWidth()) - slider.find(".marker").outerWidth();
        switch (how) {
          case "pix2prc":
            return v4 * 100 / length;
          case "pix2val":
            return this._convert(v4, "pix2prc") * ((o2.max - o2.min) / 100) + o2.min;
          case "val2prc":
            return (v4 - o2.min) / ((o2.max - o2.min) / 100);
          case "prc2pix":
            return v4 / (100 / length);
          case "val2pix":
            return this._convert(this._convert(v4, "val2prc"), "prc2pix");
        }
        return 0;
      },
      _correct: function(value) {
        var res = value;
        var accuracy = this.options.accuracy;
        var min = this.options.min, max = this.options.max;
        if (accuracy === 0 || isNaN(accuracy)) {
          return res;
        }
        res = Math.round(value / accuracy) * accuracy;
        if (res < min) {
          res = min;
        }
        if (res > max) {
          res = max;
        }
        return res.toFixed(Utils.decCount(accuracy));
      },
      _move: function(e2) {
        var slider = this.slider, o2 = this.options;
        var offset = slider.offset(), marker_size = slider.find(".marker").outerWidth(), length = o2.vertical === true ? slider.outerHeight() : slider.outerWidth(), cPos, cPix, cStart = 0, cStop = length - marker_size;
        cPos = o2.vertical === true ? Utils.pageXY(e2).y - offset.top : Utils.pageXY(e2).x - offset.left;
        cPix = o2.vertical === true ? length - cPos - marker_size / 2 : cPos - marker_size / 2;
        if (cPix < cStart || cPix > cStop) {
          return;
        }
        this.value = this._correct(this._convert(cPix, "pix2val"));
        this.percent = this._convert(this.value, "val2prc");
        this.pixel = this._convert(this.percent, "prc2pix");
        this._redraw();
      },
      _hint: function() {
        var o2 = this.options, slider = this.slider, hint = slider.find(".hint");
        var value = +this.value || 0;
        var percent = +this.percent || 0;
        if (o2.roundValue) {
          value = (Utils.isValue(value) ? +value : 0).toFixed(Utils.decCount(o2.accuracy));
          percent = (Utils.isValue(percent) ? +percent : 0).toFixed(Utils.decCount(o2.accuracy));
        }
        hint.text(o2.hintMask.replace("$1", value).replace("$2", percent));
      },
      _value: function() {
        var element2 = this.element, o2 = this.options;
        var value = o2.returnType === "value" ? this.value : this.percent;
        var percent = this.percent;
        var buffer = this.buffer;
        if (o2.roundValue) {
          value = (Utils.isValue(value) ? +value : 0).toFixed(Utils.decCount(o2.accuracy));
          percent = (Utils.isValue(percent) ? +percent : 0).toFixed(Utils.decCount(o2.accuracy));
          buffer = (Utils.isValue(buffer) ? +buffer : 0).toFixed(Utils.decCount(o2.accuracy));
        }
        if (element2[0].tagName === "INPUT") {
          element2.val(value);
        }
        if (o2.target !== null) {
          var target = $5(o2.target);
          if (target.length !== 0) {
            $5.each(target, function() {
              var t = $5(this);
              if (this.tagName === "INPUT") {
                t.val(value);
              } else {
                t.text(value);
              }
              t.trigger("change");
            });
          }
        }
        this._fireEvent("change-value", {
          val: value
        });
        this._fireEvent("change", {
          val: value,
          percent,
          buffer
        });
      },
      _marker: function() {
        var slider = this.slider, o2 = this.options;
        var marker = slider.find(".marker"), complete = slider.find(".complete");
        var length = o2.vertical === true ? slider.outerHeight() : slider.outerWidth();
        var marker_size = parseInt(Utils.getStyleOne(marker, "width"));
        var slider_visible = Utils.isVisible(slider);
        if (slider_visible) {
          marker.css({
            "margin-top": 0,
            "margin-left": 0
          });
        }
        if (o2.vertical === true) {
          if (slider_visible) {
            marker.css("top", length - this.pixel);
          } else {
            marker.css("top", 100 - this.percent + "%");
            marker.css("margin-top", marker_size / 2);
          }
          complete.css("height", this.percent + "%");
        } else {
          if (slider_visible) {
            marker.css("left", this.pixel);
          } else {
            marker.css("left", this.percent + "%");
            marker.css("margin-left", this.percent === 0 ? 0 : -1 * marker_size / 2);
          }
          complete.css("width", this.percent + "%");
        }
      },
      _redraw: function() {
        this._marker();
        this._value();
        this._hint();
      },
      _buffer: function() {
        var element2 = this.element, o2 = this.options;
        var buffer = this.slider.find(".buffer");
        if (o2.vertical === true) {
          buffer.css("height", this.buffer + "%");
        } else {
          buffer.css("width", this.buffer + "%");
        }
        this._fireEvent("change-buffer", {
          val: this.buffer
        });
        this._fireEvent("change", {
          val: element2.val(),
          percent: this.percent,
          buffer: this.buffer
        });
      },
      val: function(v4) {
        var o2 = this.options;
        if (v4 === void 0 || isNaN(v4)) {
          return this.value;
        }
        if (v4 < o2.min) {
          v4 = o2.min;
        }
        if (v4 > o2.max) {
          v4 = o2.max;
        }
        this.value = this._correct(v4);
        this.percent = this._convert(this.value, "val2prc");
        this.pixel = this._convert(this.percent, "prc2pix");
        this._redraw();
      },
      buff: function(v4) {
        var slider = this.slider;
        var buffer = slider.find(".buffer");
        if (v4 === void 0 || isNaN(v4)) {
          return this.buffer;
        }
        if (buffer.length === 0) {
          return false;
        }
        v4 = parseInt(v4);
        if (v4 > 100) {
          v4 = 100;
        }
        if (v4 < 0) {
          v4 = 0;
        }
        this.buffer = v4;
        this._buffer();
      },
      changeValue: function() {
        var element2 = this.element, o2 = this.options;
        var val = element2.attr("data-value");
        if (val < o2.min) {
          val = o2.min;
        }
        if (val > o2.max) {
          val = o2.max;
        }
        this.val(val);
      },
      changeBuffer: function() {
        var element2 = this.element;
        var val = parseInt(element2.attr("data-buffer"));
        if (val < 0) {
          val = 0;
        }
        if (val > 100) {
          val = 100;
        }
        this.buff(val);
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-value":
            this.changeValue();
            break;
          case "data-buffer":
            this.changeBuffer();
            break;
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options, slider = this.slider;
        const marker = slider.find(".marker");
        marker.off(Metro2.events.startAll);
        marker.off(Metro2.events.focus);
        marker.off(Metro2.events.blur);
        marker.off(Metro2.events.keydown);
        marker.off(Metro2.events.keyup);
        slider.off(Metro2.events.click);
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        if (o2.label) {
          slider.prev("label").remove();
        }
        slider.remove();
      }
    });
  })(Metro, Dom);

  // source/components/audio-player/audio-player.js
  ((Metro2, $5) => {
    "use strict";
    let AudioPlayerDefaultConfig = {
      audioDeferred: 0,
      playlist: null,
      src: null,
      volume: 0.5,
      loop: false,
      autoplay: false,
      showLoop: true,
      showPlay: true,
      showStop: true,
      showMute: true,
      showFull: true,
      showStream: true,
      showVolume: true,
      showInfo: true,
      showPlaylist: true,
      showNext: true,
      showPrev: true,
      showFirst: true,
      showLast: true,
      showForward: true,
      showBackward: true,
      showShuffle: true,
      showRandom: true,
      loopIcon: "\u{1F501}",
      stopIcon: "\u23F9",
      playIcon: "\u25B6",
      pauseIcon: "\u23F8",
      muteIcon: "\u{1F507}",
      volumeLowIcon: "\u{1F508}",
      volumeMediumIcon: "\u{1F509}",
      volumeHighIcon: "\u{1F50A}",
      playlistIcon: "\u{1F4C3}",
      nextIcon: "\u2192",
      prevIcon: "\u2190",
      firstIcon: "\u21E4",
      lastIcon: "\u21E5",
      forwardIcon: "\u21C9",
      backwardIcon: "\u21C7",
      shuffleIcon: "\u{1F500}",
      randomIcon: "\u{1F3B2}",
      onPlay: Metro2.noop,
      onPause: Metro2.noop,
      onStop: Metro2.noop,
      onEnd: Metro2.noop,
      onMetadata: Metro2.noop,
      onTime: Metro2.noop,
      onAudioPlayerCreate: Metro2.noop
    };
    Metro2.audioPlayerSetup = (options) => {
      AudioPlayerDefaultConfig = $5.extend({}, AudioPlayerDefaultConfig, options);
    };
    if (typeof globalThis.metroAudioPlayerSetup !== "undefined") {
      Metro2.audioPlayerSetup(globalThis.metroAudioPlayerSetup);
    }
    Metro2.Component("audio-player", {
      init: function(options, elem) {
        this._super(elem, options, AudioPlayerDefaultConfig, {
          preloader: null,
          player: null,
          audio: elem,
          stream: null,
          volume: null,
          volumeBackup: 0,
          muted: false
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this._createPlayer();
        this._createEvents();
        if (o2.autoplay === true) {
          this.play();
        }
        this._fireEvent("audio-player-create", {
          element: element2,
          player: this.player
        });
      },
      _createPlayer: function() {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        const player = element2.wrap("<div>").addClass(`media-player audio-player ${element2[0].className}`);
        $5.each(["muted", "autoplay", "controls", "height", "width", "loop", "poster", "preload"], function() {
          element2.removeAttr(this);
        });
        element2.attr("preload", "auto");
        audio.volume = o2.volume;
        if (o2.src !== null) {
          this._setSource(o2.src);
        }
        element2[0].className = "";
        this.player = player;
        this._createControls();
      },
      _setSource: function(src) {
        const element2 = this.element;
        element2.find("source").remove();
        element2.removeAttr("src");
        if (Array.isArray(src)) {
          $5.each(src, function() {
            if (this.src === void 0) return;
            $5("<source>").attr("src", this.src).attr("type", this.type !== void 0 ? this.type : "").appendTo(element2);
          });
        } else {
          element2.attr("src", src);
        }
      },
      _createControls: function() {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.elem;
        const controls = $5("<div>").addClass("controls").addClass(o2.clsControls).insertAfter(element2);
        const stream = $5("<div>").addClass("stream").appendTo(controls);
        const streamSlider = $5("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);
        const preloader = $5("<div>").addClass("load-audio").appendTo(stream);
        const volume = $5("<div>").addClass("volume").appendTo(controls);
        const volumeSlider = $5("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);
        const infoBox = $5("<div>").addClass("info-box").appendTo(controls);
        if (o2.showInfo !== true) {
          infoBox.hide();
        }
        preloader.activity({
          type: "metro",
          style: "color"
        });
        preloader.hide(0);
        this.preloader = preloader;
        Metro2.makePlugin(streamSlider, "slider", {
          clsMarker: "bg-red",
          clsHint: "bg-cyan fg-white",
          clsComplete: "bg-cyan",
          hint: true,
          onStart: () => {
            if (!audio.paused) audio.pause();
          },
          onStop: (val) => {
            if (audio.seekable.length > 0) {
              audio.currentTime = (this.duration * val / 100).toFixed(0);
            }
            if (audio.paused && audio.currentTime > 0) {
              audio.play();
            }
          }
        });
        this.stream = streamSlider;
        if (o2.showStream !== true) {
          stream.hide();
        }
        Metro2.makePlugin(volumeSlider, "slider", {
          clsMarker: "bg-red",
          clsHint: "bg-cyan fg-white",
          hint: true,
          value: o2.volume * 100,
          onChangeValue: (val) => {
            audio.volume = val / 100;
          }
        });
        this.volume = volumeSlider;
        if (o2.showVolume !== true) {
          volume.hide();
        }
        let loop;
        if (o2.showLoop === true) {
          loop = $5("<button>").attr("type", "button").addClass("button square loop").html(o2.loopIcon).appendTo(controls);
          loop.addClass("active");
          element2.attr("loop", "loop");
        }
        if (o2.showPlay === true) {
          $5("<button>").attr("type", "button").addClass("button square play").html(o2.playIcon).appendTo(controls);
        }
        if (o2.showStop === true) {
          $5("<button>").attr("type", "button").addClass("button square stop").html(o2.stopIcon).appendTo(controls);
        }
        if (o2.showMute === true) {
          $5("<button>").attr("type", "button").addClass("button square mute").html(o2.muteIcon).appendTo(controls);
        }
        this._setVolume();
        if (o2.muted) {
          this.volumeBackup = audio.volume;
          Metro2.getPlugin(this.volume, "slider").val(0);
          audio.volume = 0;
        }
        infoBox.html("00:00 / 00:00");
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.elem;
        const player = this.player;
        element2.on("loadstart", () => {
          this.preloader.fadeIn();
        });
        element2.on("loadedmetadata", () => {
          this.duration = audio.duration.toFixed(0);
          this._setInfo(0, this.duration);
          Metro2.utils.exec(o2.onMetadata, [audio, player], element2[0]);
        });
        element2.on("canplay", () => {
          this._setBuffer();
          this.preloader.fadeOut();
        });
        element2.on("progress", () => {
          this._setBuffer();
        });
        element2.on("timeupdate", () => {
          const position = Math.round(audio.currentTime * 100 / this.duration);
          this._setInfo(audio.currentTime, this.duration);
          Metro2.getPlugin(this.stream, "slider").val(position);
          Metro2.utils.exec(o2.onTime, [audio.currentTime, this.duration, audio, player], element2[0]);
        });
        element2.on("waiting", () => {
          this.preloader.fadeIn();
        });
        element2.on("loadeddata", () => {
        });
        element2.on("play", () => {
          player.find(".play").html(o2.pauseIcon);
          Metro2.utils.exec(o2.onPlay, [audio, player], element2[0]);
        });
        element2.on("pause", () => {
          player.find(".play").html(o2.playIcon);
          Metro2.utils.exec(o2.onPause, [audio, player], element2[0]);
        });
        element2.on("stop", () => {
          Metro2.getPlugin(this.stream, "slider").val(0);
          Metro2.utils.exec(o2.onStop, [audio, player], element2[0]);
        });
        element2.on("ended", () => {
          Metro2.getPlugin(this.stream, "slider").val(0);
          Metro2.utils.exec(o2.onEnd, [audio, player], element2[0]);
        });
        element2.on("volumechange", () => {
          this._setVolume();
        });
        player.on(Metro2.events.click, ".play", () => {
          if (audio.paused) {
            this.play();
          } else {
            this.pause();
          }
        });
        player.on(Metro2.events.click, ".stop", () => {
          this.stop();
        });
        player.on(Metro2.events.click, ".mute", () => {
          this._toggleMute();
        });
        player.on(Metro2.events.click, ".loop", () => {
          this._toggleLoop();
        });
      },
      _toggleLoop: function() {
        const loop = this.player.find(".loop");
        if (loop.length === 0) return;
        loop.toggleClass("active");
        if (loop.hasClass("active")) {
          this.element.attr("loop", "loop");
        } else {
          this.element.removeAttr("loop");
        }
      },
      _toggleMute: function() {
        this.muted = !this.muted;
        if (this.muted === false) {
          this.audio.volume = this.volumeBackup;
        } else {
          this.volumeBackup = this.audio.volume;
          this.audio.volume = 0;
        }
        Metro2.getPlugin(this.volume, "slider").val(this.muted === false ? this.volumeBackup * 100 : 0);
      },
      _setInfo: function(a3, b4) {
        this.player.find(".info-box").html(`${Metro2.utils.secondsToFormattedString(Math.round(a3))} / ${Metro2.utils.secondsToFormattedString(Math.round(b4))}`);
      },
      _setBuffer: function() {
        const buffer = this.audio.buffered.length ? Math.round(Math.floor(this.audio.buffered.end(0)) / Math.floor(this.audio.duration) * 100) : 0;
        Metro2.getPlugin(this.stream, "slider").buff(buffer);
      },
      _setVolume: function() {
        const audio = this.audio;
        const player = this.player;
        const o2 = this.options;
        const volumeButton = player.find(".mute");
        const volume = audio.volume * 100;
        if (volume > 1 && volume < 30) {
          volumeButton.html(o2.volumeLowIcon);
        } else if (volume >= 30 && volume < 60) {
          volumeButton.html(o2.volumeMediumIcon);
        } else if (volume >= 60 && volume <= 100) {
          volumeButton.html(o2.volumeHighIcon);
        } else {
          volumeButton.html(o2.muteIcon);
        }
      },
      play: function(src) {
        if (src !== void 0) {
          this._setSource(src);
        }
        if (this.element.attr("src") === void 0 && this.element.find("source").length === 0) {
          return;
        }
        this.audio.play();
      },
      pause: function() {
        this.audio.pause();
      },
      resume: function() {
        if (this.audio.paused) {
          this.play();
        }
      },
      stop: function() {
        this.audio.pause();
        this.audio.currentTime = 0;
        Metro2.getPlugin(this.stream, "slider").val(0);
      },
      setVolume: function(v4) {
        if (v4 === void 0) {
          return this.audio.volume;
        }
        const volume = v4 > 1 ? v4 / 100 : v4;
        this.audio.volume = v4;
        Metro2.getPlugin(this.volume, "slider").val(volume * 100);
      },
      loop: function() {
        this._toggleLoop();
      },
      mute: function() {
        this._toggleMute();
      },
      changeSource: function() {
        const src = JSON.parse(this.element.attr("data-src"));
        this.play(src);
      },
      changeVolume: function() {
        const volume = this.element.attr("data-volume");
        this.setVolume(volume);
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-src":
            this.changeSource();
            break;
          case "data-volume":
            this.changeVolume();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const player = this.player;
        element2.off("all");
        player.off("all");
        Metro2.getPlugin(this.stream, "slider").destroy();
        Metro2.getPlugin(this.volume, "slider").destroy();
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/bulls/bulls.js
  ((Metro2, $5) => {
    "use strict";
    let BullDefaultConfig = {
      type: "success",
      // success, fail, pending
      size: 16,
      onBullCreate: Metro2.noop
    };
    Metro2.bullSetup = (options) => {
      BullDefaultConfig = $5.extend({}, BullDefaultConfig, options);
    };
    if (typeof globalThis.metroBullSetup !== "undefined") {
      Metro2.bullSetup(globalThis.metroBullSetup);
    }
    Metro2.Component("bull", {
      init: function(options, elem) {
        this._super(elem, options, BullDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._fireEvent("bull-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let bull;
        switch (o2.type.toLowerCase()) {
          case "default":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="completed successfully" viewBox="0 0 16 16" role="img" xmlns="http://www.w3.org/2000/svg"><path fill="#57ab5a" d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16Zm3.78-9.72a.751.751 0 0 0-.018-1.042.751.751 0 0 0-1.042-.018L6.75 9.19 5.28 7.72a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042l2 2a.75.75 0 0 0 1.06 0Z"></path></svg>`;
            break;
          case "success":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="completed successfully" viewBox="0 0 16 16" role="img" xmlns="http://www.w3.org/2000/svg"><path fill="#57ab5a" d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16Zm3.78-9.72a.751.751 0 0 0-.018-1.042.751.751 0 0 0-1.042-.018L6.75 9.19 5.28 7.72a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042l2 2a.75.75 0 0 0 1.06 0Z"></path></svg>`;
            break;
          case "pending":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="currently running" fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" class="ani-spin"><path fill="none" stroke="#DBAB0A" stroke-width="2" d="M3.05 3.05a7 7 0 1 1 9.9 9.9 7 7 0 0 1-9.9-9.9Z" opacity=".5"></path><path fill="#DBAB0A" fill-rule="evenodd" d="M8 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z" clip-rule="evenodd"></path><path fill="#DBAB0A" d="M14 8a6 6 0 0 0-6-6V0a8 8 0 0 1 8 8h-2Z"></path></svg>`;
            break;
          case "fail":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="failed" viewBox="0 0 16 16" role="img" xmlns="http://www.w3.org/2000/svg"><path fill="#e5534b" d="M2.343 13.657A8 8 0 1 1 13.658 2.343 8 8 0 0 1 2.343 13.657ZM6.03 4.97a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042L6.94 8 4.97 9.97a.749.749 0 0 0 .326 1.275.749.749 0 0 0 .734-.215L8 9.06l1.97 1.97a.749.749 0 0 0 1.275-.326.749.749 0 0 0-.215-.734L9.06 8l1.97-1.97a.749.749 0 0 0-.326-1.275.749.749 0 0 0-.734.215L8 6.94Z"></path></svg>`;
            break;
          case "warning":
            bull = `<svg width="${o2.size}" height="${o2.size}" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#ff4d00" d="M246.312928,5.62892705 C252.927596,9.40873724 258.409564,14.8907053 262.189374,21.5053731 L444.667042,340.84129 C456.358134,361.300701 449.250007,387.363834 428.790595,399.054926 C422.34376,402.738832 415.04715,404.676552 407.622001,404.676552 L42.6666667,404.676552 C19.1025173,404.676552 7.10542736e-15,385.574034 7.10542736e-15,362.009885 C7.10542736e-15,354.584736 1.93772021,347.288125 5.62162594,340.84129 L188.099293,21.5053731 C199.790385,1.04596203 225.853517,-6.06216498 246.312928,5.62892705 Z M224,272 C208.761905,272 197.333333,283.264 197.333333,298.282667 C197.333333,313.984 208.415584,325.248 224,325.248 C239.238095,325.248 250.666667,313.984 250.666667,298.624 C250.666667,283.264 239.238095,272 224,272 Z M245.333333,106.666667 L202.666667,106.666667 L202.666667,234.666667 L245.333333,234.666667 L245.333333,106.666667 Z" id="Combined-Shape"></path></svg>`;
            break;
          case "bulb":
            bull = `<svg width="${o2.size}" height="${o2.size}" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg"><path fill="#ffde21" d="M213.333333,85.3333333 C284.025781,85.3333333 341.333333,142.640885 341.333333,213.333333 C341.333333,260.711239 315.5928,302.077122 277.333732,324.208982 L277.333333,405.333333 L256,426.666667 L234.666667,426.666667 C234.666667,438.448741 225.115408,448 213.333333,448 C201.551259,448 192,438.448741 192,426.666667 L192,426.666667 L170.666667,426.666667 L149.333333,405.333333 L149.332954,324.208993 C111.073876,302.077136 85.3333333,260.711248 85.3333333,213.333333 C85.3333333,142.640885 142.640885,85.3333333 213.333333,85.3333333 Z M234.667665,339.563386 C227.72957,340.727434 220.602209,341.333333 213.333333,341.333333 C206.064458,341.333333 198.937097,340.727434 191.999002,339.563386 L192,384 L234.666667,384 L234.667665,339.563386 Z M96.4250122,307.614237 L119.052429,330.241654 L73.7975952,375.496488 L51.1701782,352.869071 L96.4250122,307.614237 Z M330.241654,307.614237 L375.496488,352.869071 L352.869071,375.496488 L307.614237,330.241654 L330.241654,307.614237 Z M426.666667,197.333333 L426.666667,229.333333 L362.666667,229.333333 L362.666667,197.333333 L426.666667,197.333333 Z M64,197.333333 L64,229.333333 L7.10542736e-15,229.333333 L7.10542736e-15,197.333333 L64,197.333333 Z M352.869071,51.1701782 L375.496488,73.7975952 L330.241654,119.052429 L307.614237,96.4250122 L352.869071,51.1701782 Z M73.7975952,51.1701782 L119.052429,96.4250122 L96.4250122,119.052429 L51.1701782,73.7975952 L73.7975952,51.1701782 Z M229.333333,-1.0658141e-14 L229.333333,64 L197.333333,64 L197.333333,-1.0658141e-14 L229.333333,-1.0658141e-14 Z" id="Combined-Shape"></path></svg>`;
            break;
        }
        element2.clear().html(bull);
      },
      changeAttribute: function(attr, value) {
        if (attr === "data-type") {
          this._createStructure();
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/button-group/button-group.js
  ((Metro2, $5) => {
    "use strict";
    let ButtonGroupDefaultConfig = {
      buttongroupDeferred: 0,
      targets: "button",
      clsActive: "",
      requiredButton: false,
      mode: Metro2.groupMode.ONE,
      onButtonClick: Metro2.noop,
      onButtonGroupCreate: Metro2.noop
    };
    Metro2.buttonGroupSetup = (options) => {
      ButtonGroupDefaultConfig = $5.extend({}, ButtonGroupDefaultConfig, options);
    };
    if (typeof globalThis.metroButtonGroupSetup !== "undefined") {
      Metro2.buttonGroupSetup(globalThis.metroButtonGroupSetup);
    }
    Metro2.Component("button-group", {
      init: function(options, elem) {
        this._super(elem, options, ButtonGroupDefaultConfig, {
          active: null,
          id: Metro2.utils.elementId("button-group")
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createGroup();
        this._createEvents();
        this._fireEvent("button-group-create", {
          element: element2
        });
      },
      _createGroup: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("button-group");
        const buttons = element2.find(o2.targets);
        const buttons_active = element2.find(".active");
        if (o2.mode === Metro2.groupMode.ONE && buttons_active.length === 0 && o2.requiredButton === true) {
          $5(buttons[0]).addClass("active");
        }
        if (o2.mode === Metro2.groupMode.ONE && buttons_active.length > 1) {
          buttons.removeClass("active").removeClass(o2.clsActive);
          $5(buttons[0]).addClass("active");
        }
        element2.find(".active").addClass("js-active").addClass(o2.clsActive);
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.click, o2.targets, function() {
          const el = $5(this);
          that._fireEvent("button-click", {
            button: this
          });
          if (o2.mode === Metro2.groupMode.ONE && el.hasClass("active")) {
            return;
          }
          if (o2.mode === Metro2.groupMode.ONE) {
            element2.find(o2.targets).removeClass(o2.clsActive).removeClass("active js-active");
            el.addClass("active").addClass(o2.clsActive).addClass("js-active");
          } else {
            el.toggleClass("active").toggleClass(o2.clsActive).toggleClass("js-active");
          }
        });
      },
      changeAttribute: (attributeName) => {
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.off(Metro2.events.click, o2.targets);
        element2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/spinner/spinner.js
  (function(Metro2, $5) {
    "use strict";
    let SpinnerDefaultConfig = {
      spinnerDeferred: 0,
      label: "",
      step: 1,
      plusIcon: "+",
      minusIcon: "-",
      buttonsPosition: "default",
      defaultValue: 0,
      minValue: null,
      maxValue: null,
      fixed: 0,
      repeatThreshold: 2e3,
      hideCursor: false,
      clsSpinner: "",
      clsSpinnerInput: "",
      clsSpinnerButton: "",
      clsSpinnerButtonPlus: "",
      clsSpinnerButtonMinus: "",
      clsLabel: "",
      onBeforeChange: Metro2.noop_true,
      onChange: Metro2.noop,
      onPlusClick: Metro2.noop,
      onMinusClick: Metro2.noop,
      onArrowUp: Metro2.noop,
      onArrowDown: Metro2.noop,
      onButtonClick: Metro2.noop,
      onArrowClick: Metro2.noop,
      onSpinnerCreate: Metro2.noop
    };
    Metro2.spinnerSetup = function(options) {
      SpinnerDefaultConfig = $5.extend({}, SpinnerDefaultConfig, options);
    };
    if (typeof globalThis["metroSpinnerSetup"] !== "undefined") {
      Metro2.spinnerSetup(globalThis["metroSpinnerSetup"]);
    }
    Metro2.Component("spinner", {
      init: function(options, elem) {
        this._super(elem, options, SpinnerDefaultConfig, {
          repeat_timer: false
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("spinner-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        const spinner = $5("<div>").addClass("spinner").addClass("buttons-" + o2.buttonsPosition).addClass(element2[0].className).addClass(o2.clsSpinner);
        const button_plus = $5("<button>").attr("type", "button").addClass("button spinner-button spinner-button-plus").addClass(o2.clsSpinnerButton + " " + o2.clsSpinnerButtonPlus).html(o2.plusIcon);
        const button_minus = $5("<button>").attr("type", "button").addClass("button spinner-button spinner-button-minus").addClass(o2.clsSpinnerButton + " " + o2.clsSpinnerButtonMinus).html(o2.minusIcon);
        const init_value = element2.val().trim();
        if (!Metro2.utils.isValue(init_value)) {
          element2.val(0);
        }
        element2[0].className = "";
        spinner.insertBefore(element2);
        element2.appendTo(spinner).addClass(o2.clsSpinnerInput);
        element2.addClass("metro-input");
        button_plus.appendTo(spinner);
        button_minus.appendTo(spinner);
        if (o2.hideCursor === true) {
          spinner.addClass("hide-cursor");
        }
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(spinner);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (o2.disabled === true || element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const spinner = element2.closest(".spinner");
        const spinner_buttons = spinner.find(".spinner-button");
        let value, repeat_timer;
        const spinnerButtonClick = function(plus) {
          const events = [plus ? "plus-click" : "minus-click", plus ? "arrow-up" : "arrow-down", "button-click", "arrow-click"];
          const curr = +element2.val();
          let val = +element2.val();
          const step = +o2.step;
          if (plus) {
            val += step;
          } else {
            val -= step;
          }
          that._setValue(val.toFixed(o2.fixed), true);
          that._fireEvents(events, {
            curr,
            val,
            elementVal: element2.val(),
            button: plus ? "plus" : "minus"
          });
        };
        spinner.on(Metro2.events.startAll, ".spinner-button", function(e2) {
          const plus = $5(this).hasClass("spinner-button-plus");
          repeat_timer = setInterval(function() {
            spinnerButtonClick(plus);
          }, 100);
        }, { passive: true });
        spinner.on(Metro2.events.stopAll, ".spinner-button", function(e2) {
          clearInterval(repeat_timer);
        }, { passive: true });
        spinner.on(Metro2.events.click, ".spinner-button", function(e2) {
          const plus = $5(this).hasClass("spinner-button-plus");
          spinnerButtonClick(plus);
        }, { passive: true });
        spinner.on(Metro2.events.click, function(e2) {
          $5(".focused").removeClass("focused");
          spinner.addClass("focused");
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _setValue: function(val, trigger_change) {
        const element2 = this.element, o2 = this.options;
        if (Metro2.utils.exec(o2.onBeforeChange, [val], element2[0]) !== true) {
          return;
        }
        if (Metro2.utils.isValue(o2.maxValue) && val > Number(o2.maxValue)) {
          val = Number(o2.maxValue);
        }
        if (Metro2.utils.isValue(o2.minValue) && val < Number(o2.minValue)) {
          val = Number(o2.minValue);
        }
        element2.val(val);
        this._fireEvent("change", { val }, false, true);
        if (trigger_change === true) {
          element2.fire("change", {
            val
          });
        }
      },
      val: function(val) {
        const that = this, element2 = this.element, o2 = this.options;
        if (!Metro2.utils.isValue(val)) {
          return element2.val();
        }
        that._setValue(val.toFixed(o2.fixed), true);
      },
      toDefault: function() {
        const o2 = this.options;
        const val = Metro2.utils.isValue(o2.defaultValue) ? Number(o2.defaultValue) : 0;
        this._setValue(val.toFixed(o2.fixed), true);
        this._fireEvent("change", {
          val
        });
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        const that = this, element2 = this.element;
        var changeValue = function() {
          const val = element2.attr("value").trim();
          if (Metro2.utils.isValue(val)) {
            that._setValue(Number(val), false);
          }
        };
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
          case "value":
            changeValue();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        const spinner = element2.closest(".spinner");
        const spinner_buttons = spinner.find(".spinner-button");
        spinner.off(Metro2.events.click);
        spinner_buttons.off(Metro2.events.start);
        spinner_buttons.off(Metro2.events.stop);
        element2.off(Metro2.events.keydown);
        spinner.off(Metro2.events.keyup);
        if (o2.label) {
          spinner.prev("label").remove();
        }
        spinner.remove();
      }
    });
    $5(document).on(Metro2.events.click, function() {
      $5(".spinner").removeClass("focused");
    });
  })(Metro, Dom);

  // source/components/calendar/calendar.js
  ((Metro2, $5) => {
    "use strict";
    let CalendarDefaultConfig = {
      weekStart: null,
      static: false,
      readonly: false,
      showGhost: false,
      events: null,
      startContent: "days",
      showTime: false,
      initialTime: null,
      initialHours: null,
      initialMinutes: null,
      labelTimeHours: null,
      labelTimeMinutes: null,
      animationContent: true,
      animationSpeed: 10,
      calendarDeferred: 0,
      dayBorder: false,
      excludeDay: null,
      prevMonthIcon: "\u2BC7",
      nextMonthIcon: "\u2BC8",
      prevYearIcon: "\u2BC7",
      nextYearIcon: "\u2BC8",
      compact: false,
      wide: false,
      widePoint: null,
      pickerMode: false,
      show: null,
      outside: true,
      buttons: "",
      //cancel, today, clear, done
      yearsBefore: 100,
      yearsAfter: 100,
      headerFormat: "dddd, MMM DD",
      showHeader: true,
      showFooter: true,
      showWeekNumber: false,
      isDialog: false,
      ripple: false,
      rippleColor: "#cccccc",
      exclude: null,
      preset: null,
      minDate: null,
      maxDate: null,
      weekDayClick: false,
      weekNumberClick: false,
      multiSelect: false,
      special: null,
      format: METRO_DATE_FORMAT,
      inputFormat: null,
      clsCalendar: "",
      clsCalendarHeader: "",
      clsCalendarContent: "",
      clsCalendarFooter: "",
      clsCalendarMonths: "",
      clsCalendarYears: "",
      clsToday: "",
      clsSelected: "",
      clsExcluded: "",
      clsCancelButton: "",
      clsTodayButton: "",
      clsClearButton: "",
      clsDoneButton: "",
      clsEventCounter: "",
      clsWeekend: "",
      clsCurrentWeek: "",
      clsCalendarTime: "",
      clsTime: "",
      clsTimeHours: "",
      clsTimeMinutes: "",
      clsTimeButton: "",
      clsTimeButtonPlus: "",
      clsTimeButtonMinus: "",
      clsSpecial: "",
      clsEvents: "",
      clsEvent: "",
      onCancel: Metro2.noop,
      onToday: Metro2.noop,
      onClear: Metro2.noop,
      onDone: Metro2.noop,
      onDayClick: Metro2.noop,
      onDrawDay: Metro2.noop,
      onDrawMonth: Metro2.noop,
      onDrawYear: Metro2.noop,
      onWeekDayClick: Metro2.noop,
      onWeekNumberClick: Metro2.noop,
      onMonthChange: Metro2.noop,
      onYearChange: Metro2.noop,
      onTimeChange: Metro2.noop,
      onHoursChange: Metro2.noop,
      onMinutesChange: Metro2.noop,
      onCalendarCreate: Metro2.noop
    };
    Metro2.calendarSetup = (options) => {
      CalendarDefaultConfig = $5.extend({}, CalendarDefaultConfig, options);
    };
    if (typeof globalThis.metroCalendarSetup !== "undefined") {
      Metro2.calendarSetup(globalThis.metroCalendarSetup);
    }
    Metro2.Component("calendar", {
      init: function(options, elem) {
        const time = datetime();
        const now = this._correctDate(datetime());
        this._super(elem, options, CalendarDefaultConfig, {
          today: now,
          show: now,
          current: {
            year: now.year(),
            month: now.month(),
            day: now.day()
          },
          preset: [],
          selected: [],
          exclude: [],
          special: [],
          excludeDay: [],
          events: [],
          min: null,
          max: null,
          minYear: null,
          maxYear: null,
          id: Metro2.utils.elementId("calendar"),
          time: [time.hour(), time.minute()],
          content: "days",
          yearDistance: 11,
          yearGroupStart: now.year()
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.content = o2.startContent;
        this.minYear = this.current.year - this.options.yearsBefore;
        this.maxYear = this.current.year + this.options.yearsAfter;
        element2.html("").addClass(`calendar ${o2.compact === true ? "compact" : ""}`).addClass(o2.clsCalendar);
        if (Metro2.utils.isValue(o2.initialTime)) {
          this.time = o2.initialTime.split(":");
        }
        if (Metro2.utils.isValue(o2.initialHours) && Metro2.utils.between(o2.initialHours, 0, 23, true)) {
          this.time[0] = Number.parseInt(o2.initialHours);
        }
        if (Metro2.utils.isValue(o2.initialMinutes) && Metro2.utils.between(o2.initialMinutes, 0, 59, true)) {
          this.time[1] = Number.parseInt(o2.initialMinutes);
        }
        if (o2.dayBorder === true) {
          element2.addClass("day-border");
        }
        if (Metro2.utils.isValue(o2.excludeDay)) {
          this.excludeDay = `${o2.excludeDay}`.toArray(",", "int");
        }
        if (Metro2.utils.isValue(o2.preset)) {
          this._dates2array(o2.preset, "selected");
        }
        if (Metro2.utils.isValue(o2.exclude)) {
          this._dates2array(o2.exclude, "exclude");
        }
        if (Metro2.utils.isValue(o2.special)) {
          this._dates2array(o2.special, "special");
        }
        if (Metro2.utils.isValue(o2.events)) {
          this._dates2array(o2.events, "events");
        }
        this.min = o2.minDate ? (o2.inputFormat ? Datetime.from(o2.minDate, o2.inputFormat) : datetime(o2.minDate)).align("day") : null;
        this.max = o2.maxDate ? (o2.inputFormat ? Datetime.from(o2.maxDate, o2.inputFormat) : datetime(o2.maxDate)).align("day") : null;
        if (o2.show) {
          this.show = (!o2.show ? datetime() : o2.inputFormat ? Datetime.from(o2.show, o2.inputFormat) : datetime(o2.show)).align("day");
          this.current = {
            year: this.show.year(),
            month: this.show.month(),
            day: this.show.day()
          };
        }
        this._drawCalendar();
        this._createEvents();
        if (o2.wide === true) {
          element2.addClass("calendar-wide");
        } else {
          if (!Metro2.utils.isNull(o2.widePoint) && Metro2.utils.mediaExist(o2.widePoint)) {
            element2.addClass("calendar-wide");
          }
        }
        if (o2.ripple === true && Metro2.utils.isFunc(element2.ripple) !== false) {
          element2.ripple({
            rippleTarget: ".button, .prev-month, .next-month, .prev-year, .next-year, .day",
            rippleColor: this.options.rippleColor
          });
        }
        const id = element2.id();
        if (id) {
          if (Metro2.storage.getItem(`METRO:CALENDAR:${id}:COLLAPSED`, element2.hasClass("calendar-collapsed"))) {
            element2.addClass("calendar-collapsed");
          }
        }
        this._fireEvent("calendar-create");
      },
      _dates2array: function(val, category) {
        const that = this;
        const o2 = this.options;
        if (Metro2.utils.isNull(val)) {
          return;
        }
        const dates = typeof val === "string" ? val.toArray() : Array.isArray(val) ? val : [];
        $5.each(dates, function() {
          let _d;
          try {
            _d = that._correctDate(o2.inputFormat ? Datetime.from(this, o2.inputFormat) : datetime(this)).format("YYYY-MM-DD");
          } catch (e2) {
            return;
          }
          that[category].push(_d);
        });
      },
      _correctDate: (date) => datetime(date).addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset()),
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        $5(globalThis).on(
          Metro2.events.resize,
          () => {
            if (o2.wide !== true) {
              if (!Metro2.utils.isNull(o2.widePoint) && Metro2.utils.mediaExist(o2.widePoint)) {
                element2.addClass("calendar-wide");
              } else {
                element2.removeClass("calendar-wide");
              }
            }
          },
          { ns: this.id }
        );
        element2.on(Metro2.events.click, ".button-collapse", () => {
          const id = element2.id();
          element2.toggleClass("calendar-collapsed");
          if (id) {
            Metro2.storage.setItem(`METRO:CALENDAR:${id}:COLLAPSED`, element2.hasClass("calendar-collapsed"));
          }
        });
        element2.on(Metro2.events.click, ".prev-year-group, .next-year-group", function() {
          if (o2.static) {
            return;
          }
          if ($5(this).hasClass("prev-year-group")) {
            that.yearGroupStart -= that.yearDistance;
          } else {
            that.yearGroupStart += that.yearDistance;
          }
          that._drawContent();
        });
        element2.on(Metro2.events.click, ".prev-month, .next-month, .prev-year, .next-year", function() {
          let new_date;
          const el = $5(this);
          if (o2.static) {
            return;
          }
          if (el.hasClass("prev-month")) {
            new_date = datetime(that.current.year, that.current.month - 1, 1).useLocale(that.locale, true);
            if (new_date.year() < that.minYear) {
              return;
            }
          }
          if (el.hasClass("next-month")) {
            new_date = datetime(that.current.year, that.current.month + 1, 1).useLocale(that.locale, true);
            if (new_date.year() > that.maxYear) {
              return;
            }
          }
          if (el.hasClass("prev-year")) {
            new_date = datetime(that.current.year - 1, that.current.month, 1).useLocale(that.locale, true);
            if (new_date.year() < that.minYear) {
              return;
            }
          }
          if (el.hasClass("next-year")) {
            new_date = datetime(that.current.year + 1, that.current.month, 1).useLocale(that.locale, true);
            if (new_date.year() > that.maxYear) {
              return;
            }
          }
          that.current = {
            year: new_date.year(),
            month: new_date.month(),
            day: new_date.day()
          };
          setTimeout(
            () => {
              that._drawContent();
              if (el.hasClass("prev-month") || el.hasClass("next-month")) {
                that._fireEvent("month-change", {
                  current: that.current
                });
              }
              if (el.hasClass("prev-year") || el.hasClass("next-year")) {
                that._fireEvent("year-change", {
                  current: that.current
                });
              }
            },
            o2.ripple ? 300 : 1
          );
        });
        element2.on(Metro2.events.click, ".button-today", () => {
          that.toDay();
          that._fireEvent("today", {
            today: that.today.val(),
            time: that.time
          });
        });
        element2.on(Metro2.events.click, ".button-clear", () => {
          const date = datetime();
          that.selected = [];
          that.time = [date.hour(), date.minute()];
          that.yearGroupStart = date.year();
          that._drawContent();
          that._fireEvent("clear");
        });
        element2.on(Metro2.events.click, ".button-cancel", () => {
          that._drawContent();
          that._fireEvent("cancel");
        });
        element2.on(Metro2.events.click, ".button-done", () => {
          that._drawContent();
          that._fireEvent("done", {
            selected: that.selected,
            time: that.time
          });
        });
        if (o2.weekDayClick === true) {
          element2.on(Metro2.events.click, ".week-days .week-day", function(e2) {
            let index;
            let days;
            const ii = [];
            if (o2.static || o2.readonly) {
              return;
            }
            const day = $5(this);
            index = day.index();
            for (let i3 = 0; i3 < 7; i3++) {
              ii.push(index);
              index += o2.showWeekNumber ? 8 : 7;
            }
            if (o2.multiSelect === true) {
              days = element2.find(".day").filter((el) => {
                const $el = $5(el);
                return ii.indexOf($el.index()) > -1 && !$el.hasClass("outside disabled excluded");
              });
              $5.each(days, function() {
                const $el = $5(this);
                const day2 = $el.data("day");
                if (that.selected.indexOf(day2) === -1) {
                  that.selected.push(day2);
                  $el.addClass("selected").addClass(o2.clsSelected);
                } else {
                  $el.removeClass("selected").removeClass(o2.clsSelected);
                  Metro2.utils.arrayDelete(that.selected, day2);
                }
              });
            }
            that._fireEvent("week-day-click", {
              selected: that.selected,
              day: day[0]
            });
            e2.preventDefault();
            e2.stopPropagation();
          });
        }
        if (o2.weekNumberClick) {
          element2.on(Metro2.events.click, ".week-number", function(e2) {
            let days;
            const $el = $5(this);
            const wn = $el.text();
            const index = $el.index();
            if (wn === "#") {
              return;
            }
            if (o2.static || o2.readonly) {
              return;
            }
            if (o2.multiSelect === true) {
              days = element2.find(".day").filter((el) => {
                const $el2 = $5(el);
                const elIndex = $el2.index();
                return Metro2.utils.between(elIndex, index, index + 8, false) && !$el2.hasClass("outside disabled excluded");
              });
              $5.each(days, function() {
                const $el2 = $5(this);
                const day = $el2.data("day");
                if (that.selected.indexOf(day) === -1) {
                  that.selected.push(day);
                  $el2.addClass("selected").addClass(o2.clsSelected);
                } else {
                  $el2.removeClass("selected").removeClass(o2.clsSelected);
                  Metro2.utils.arrayDelete(that.selected, day);
                }
              });
            }
            that._fireEvent("week-number-click", {
              selected: that.selected,
              num: wn,
              numElement: $el[0]
            });
            e2.preventDefault();
            e2.stopPropagation();
          });
        }
        element2.on(Metro2.events.click, ".day", function(e2) {
          const day = $5(this);
          let index;
          let date;
          if (o2.static || o2.readonly) {
            return;
          }
          date = day.data("day");
          index = that.selected.indexOf(date);
          if (day.hasClass("outside")) {
            date = datetime(date);
            that.current = {
              year: date.year(),
              month: date.month(),
              day: date.day()
            };
            that._drawContent();
            that._fireEvent("month-change", {
              current: that.current
            });
            return;
          }
          if (!day.hasClass("disabled")) {
            if (o2.pickerMode === true) {
              that.selected = [date];
              that.today = datetime(date);
              that.current.year = that.today.year();
              that.current.month = that.today.month();
              that.current.day = that.today.day();
              that._drawHeader();
              that._drawContent();
            } else {
              if (index === -1) {
                if (o2.multiSelect === false) {
                  element2.find(".day").removeClass("selected").removeClass(o2.clsSelected);
                  that.selected = [];
                }
                that.selected.push(date);
                day.addClass("selected").addClass(o2.clsSelected);
              } else {
                day.removeClass("selected").removeClass(o2.clsSelected);
                Metro2.utils.arrayDelete(that.selected, date);
              }
            }
          }
          that._fireEvent("day-click", {
            selected: that.selected,
            day: day[0],
            time: that.time
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, ".curr-month, .header-day", (e2) => {
          that.content = "months";
          that._drawContent();
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, ".month", function(e2) {
          that.current.month = Number.parseInt($5(this).attr("data-month"));
          that.content = "days";
          that._drawContent();
          that._fireEvent("month-change", {
            current: that.current
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, ".curr-year, .header-year", (e2) => {
          if (that.content === "years") {
            return;
          }
          that.content = "years";
          that._drawContent();
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, ".year", function(e2) {
          that.current.year = Number.parseInt($5(this).attr("data-year"));
          that.yearGroupStart = that.current.year;
          that.content = "months";
          that._drawContent();
          that._fireEvent("year-change", {
            current: that.current
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _drawHeader: function() {
        const element2 = this.element;
        const o2 = this.options;
        let header = element2.find(".calendar-header");
        if (header.length === 0) {
          header = $5("<div>").addClass("calendar-header").addClass(o2.clsCalendarHeader).appendTo(element2);
        }
        header.html("");
        $5("<div>").addClass("header-year").html(this.today.year()).appendTo(header);
        $5("<div>").addClass("header-day").html(this.today.format(o2.headerFormat, this.locale)).appendTo(header);
        const headerActions = $5("<div>").addClass("header-actions").appendTo(header);
        $5("<button>").addClass("square small button-collapse").html(`
                <svg aria-hidden="true" class="caret toggle-collapsed" width="16" height="16" viewBox="0 0 24 24">
                    <path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path>
                </svg>
            `).attr("title", this.strings.label_collapse).appendTo(headerActions);
        if (o2.showHeader === false) {
          header.hide();
        }
      },
      _drawFooter: function() {
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        let footer = element2.find(".calendar-footer");
        if (!o2.buttons) {
          return;
        }
        if (footer.length === 0) {
          footer = $5("<div>").addClass("calendar-footer").addClass(o2.clsCalendarFooter).appendTo(element2);
        }
        footer.html("");
        $5.each(o2.buttons.toArray(","), function() {
          const button = $5("<button>").attr("type", "button").addClass(`button button-${this} ${o2[`cls${Str.capitalize(this)}Button`]}`).html(strings[`label_${this}`]).appendTo(footer);
          if (this === "cancel" || this === "done") {
            button.addClass("js-dialog-close");
          }
        });
        if (o2.showFooter === false) {
          footer.hide();
        }
      },
      _drawTime: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const calendarContent = element2.find(".calendar-content");
        const time = $5("<div>").addClass("calendar-time").addClass(o2.clsCalendarTime).appendTo(calendarContent);
        let inner;
        let hours;
        let minutes;
        let row;
        let h3 = `${this.time[0]}`;
        let m4 = `${this.time[1]}`;
        const onChange = function(val) {
          const value = Number.parseInt(val);
          if ($5(this).attr("data-time-part") === "hours") {
            that.time[0] = value;
            that._fireEvent("hours-change", {
              time: that.time,
              hours: value
            });
          } else {
            that.time[1] = value;
            that._fireEvent("minutes-change", {
              time: that.time,
              minutes: value
            });
          }
          that._fireEvent("time-change", {
            time: that.time
          });
        };
        time.append(inner = $5("<div>").addClass("calendar-time__inner"));
        inner.append(row = $5("<div>").addClass("calendar-time__inner-row"));
        row.append($5("<div>").addClass("calendar-time__inner-cell").append($5("<span>").html(str(strings.label_hours).capitalize())));
        row.append($5("<div>").addClass("calendar-time__inner-cell").append($5("<span>").html(str(strings.label_minutes).capitalize())));
        time.append(inner = $5("<div>").addClass("calendar-time__inner spinners").addClass(o2.clsTime));
        inner.append(
          // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
          hours = $5(`<input type='text' data-cls-spinner-input='${o2.clsTimeHours}' data-time-part='hours' data-buttons-position='right' data-min-value='0' data-max-value='23'>`).addClass("hours").addClass(o2.compact ? "input-small" : "input-normal")
        );
        inner.append(
          // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
          minutes = $5(`<input type='text' data-cls-spinner-input='${o2.clsTimeMinutes}' data-time-part='minutes' data-buttons-position='right' data-min-value='0' data-max-value='59'>`).addClass("minutes").addClass(o2.compact ? "input-small" : "input-normal")
        );
        h3 = Str.lpad(h3, "0", 2);
        m4 = Str.lpad(m4, "0", 2);
        hours.val(h3);
        minutes.val(m4);
        Metro2.makePlugin(inner.find("input[type=text]"), "spinner", {
          onChange,
          clsSpinnerButton: o2.clsTimeButton,
          clsSpinnerButtonPlus: o2.clsTimeButtonPlus,
          clsSpinnerButtonMinus: o2.clsTimeButtonMinus
        });
        if (o2.showTime === false) {
          time.hide();
        }
      },
      _drawContentDays: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        let content = element2.find(".calendar-content");
        let weekDays;
        const calendar = datetime(this.current.year, this.current.month, this.current.day).useLocale(this.locale, true).calendar(Metro2.utils.isValue(o2.weekStart) ? o2.weekStart : strings.weekStart);
        const showDay = this.show.format("YYYY-MM-DD");
        const now = datetime();
        if (content.length === 0) {
          content = $5("<div>").addClass("calendar-content").addClass(o2.clsCalendarContent).appendTo(element2);
        }
        if (o2.showWeekNumber) {
          content.addClass("-week-numbers");
        }
        content.empty();
        const toolbar = $5("<div>").addClass("calendar-toolbar").appendTo(content);
        $5("<span>").addClass("prev-month").html(o2.prevMonthIcon).appendTo(toolbar);
        $5("<span>").addClass("curr-month").html(Datetime.getLocale(this.locale).months[this.current.month]).appendTo(toolbar);
        $5("<span>").addClass("next-month").html(o2.nextMonthIcon).appendTo(toolbar);
        $5("<span>").addClass("prev-year").html(o2.prevYearIcon).appendTo(toolbar);
        $5("<span>").addClass("curr-year").html(this.current.year).appendTo(toolbar);
        $5("<span>").addClass("next-year").html(o2.nextYearIcon).appendTo(toolbar);
        weekDays = $5("<div>").addClass("week-days").appendTo(content);
        if (o2.showWeekNumber) {
          $5("<span>").addClass("week-number").html("#").appendTo(weekDays);
        }
        $5.each(calendar.weekdays, function() {
          $5("<span>").addClass("week-day").html(this).appendTo(weekDays);
        });
        const calendarDays = $5("<div>").addClass("days").appendTo(content);
        $5.each(calendar.days, function(i3) {
          const day = `${this}`;
          const date = that._correctDate(day);
          const outsideDate = date.month() !== that.current.month;
          if (o2.showWeekNumber && i3 % 7 === 0) {
            $5("<span>").addClass("week-number").html(`<span class="week-number-content">${date.weekNumber(o2.weekStart)}</span>`).appendTo(calendarDays);
          }
          const _day = date.day();
          const _data = date.format("YYYY-MM-DD");
          const cell = $5("<span>").addClass("day").html(`<span class="day-content">${_day}</span>`).appendTo(calendarDays);
          cell.attr("data-day", _data);
          if (day === showDay) {
            cell.addClass("showed");
          }
          if (outsideDate) {
            cell.addClass("outside");
            if (!o2.outside) {
              cell.empty();
            }
          }
          if (day === calendar.today) {
            cell.addClass("today");
          }
          if (o2.showGhost && date.day() === now.day()) {
            cell.addClass("coincidental");
          }
          if (that.special.length) {
            if (that.special.indexOf(day) === -1) {
              cell.addClass("disabled excluded").addClass(o2.clsExcluded);
            } else {
              cell.addClass(o2.clsSpecial);
            }
          } else {
            if (that.selected.includes(day)) {
              cell.addClass("selected").addClass(o2.clsSelected);
            }
            if (that.exclude.includes(day)) {
              cell.addClass("disabled excluded").addClass(o2.clsExcluded);
            }
            if (that.min && date.older(that.min)) {
              cell.addClass("disabled excluded").addClass(o2.clsExcluded);
            }
            if (that.max && date.younger(that.max)) {
              cell.addClass("disabled excluded").addClass(o2.clsExcluded);
            }
          }
          if (calendar.weekends.indexOf(day) !== -1) {
            cell.addClass(o2.clsWeekend);
          }
          if (calendar.week.indexOf(day) !== -1) {
            cell.addClass(o2.clsCurrentWeek);
          }
          if (that.events.length) {
            const events = $5("<div>").addClass("events").addClass(o2.clsEvents).appendTo(cell);
            $5.each(that.events, function() {
              if (this === day) {
                const event = $5("<div>").addClass("event").addClass(o2.clsEvent).appendTo(events);
                if (!o2.clsEvent) {
                  event.css({
                    backgroundColor: Farbe.Routines.randomColor()
                  });
                }
              }
            });
          }
          if (o2.animationContent) {
            cell.addClass("to-animate");
          }
          that._fireEvent("draw-day", {
            date: date.val(),
            day: date.day(),
            month: date.month(),
            year: date.year(),
            cell: cell[0]
          });
        });
        this._drawTime();
        this._animateContent(".day");
      },
      _drawContentMonths: function() {
        const element2 = this.element;
        const elem = this.elem;
        const o2 = this.options;
        const locale = this.locale;
        let content = element2.find(".calendar-content");
        let months;
        let month;
        const yearToday = datetime().year();
        const monthToday = datetime().month();
        if (content.length === 0) {
          content = $5("<div>").addClass("calendar-content").addClass(o2.clsCalendarContent).appendTo(element2);
        }
        content.clear();
        const toolbar = $5("<div>").addClass("calendar-toolbar").appendTo(content);
        $5("<span>").addClass("prev-year").html(o2.prevYearIcon).appendTo(toolbar);
        $5("<span>").addClass("curr-year").html(this.current.year).appendTo(toolbar);
        $5("<span>").addClass("next-year").html(o2.nextYearIcon).appendTo(toolbar);
        content.append(months = $5("<div>").addClass("months"));
        let index = 0;
        for (const m4 of Datetime.getLocale(locale).months) {
          months.append(
            // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
            month = $5("<div>").attr("data-month", index).addClass("month").addClass(index === monthToday && this.current.year === yearToday ? "today" : "").html(m4)
          );
          if (o2.animationContent) {
            month.addClass("to-animate");
          }
          this._fireEvent("draw-month", {
            month: index,
            year: this.current.year,
            cell: month[0]
          });
          index++;
        }
        Metro2.i18n.updateUI(elem, locale);
        this._animateContent(".months .month");
      },
      _drawContentYears: function() {
        const element2 = this.element;
        const o2 = this.options;
        let content = element2.find(".calendar-content");
        let years;
        let year;
        if (content.length === 0) {
          content = $5("<div>").addClass("calendar-content").addClass(o2.clsCalendarContent).appendTo(element2);
        }
        content.clear();
        const toolbar = $5("<div>").addClass("calendar-toolbar").appendTo(content);
        $5("<span>").addClass("prev-year-group").html(o2.prevYearIcon).appendTo(toolbar);
        $5("<span>").addClass("curr-year").html(`${this.yearGroupStart} - ${this.yearGroupStart + this.yearDistance}`).appendTo(toolbar);
        $5("<span>").addClass("next-year-group").html(o2.nextYearIcon).appendTo(toolbar);
        content.append(years = $5("<div>").addClass("years"));
        for (let i3 = this.yearGroupStart; i3 <= this.yearGroupStart + this.yearDistance; i3++) {
          years.append(
            // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
            year = $5("<div>").attr("data-year", i3).addClass("year").addClass(i3 === this.current.year ? "today" : "").html(i3)
          );
          if (o2.animationContent) {
            year.addClass("to-animate");
          }
          if (i3 < o2.minYear || i3 > o2.maxYear) {
            year.addClass("disabled");
          }
          this._fireEvent("draw-year", {
            year: i3,
            cell: year[0]
          });
        }
        this._animateContent(".years .year");
      },
      _drawContent: function() {
        switch (this.content) {
          case "years":
            this._drawContentYears();
            break;
          case "months":
            this._drawContentMonths();
            break;
          default:
            this._drawContentDays();
        }
        Metro2.i18n.updateUI(this.elem, this.locale);
      },
      _drawCalendar: function() {
        const element2 = this.elem;
        setTimeout(() => {
          this.element.html("");
          this._drawHeader();
          this._drawContent();
          this._drawFooter();
          Metro2.i18n.updateUI(element2, this.locale);
        }, 0);
      },
      _animateContent: function(target, cls = "to-animate") {
        const element2 = this.element;
        const o2 = this.options;
        const content = element2.find(".calendar-content");
        content.find(target).each(function(k4) {
          const day = $5(this);
          setTimeout(() => {
            day.removeClass(cls);
          }, o2.animationSpeed * k4);
        });
      },
      getTime: function(asString = false) {
        const h3 = Str.lpad(this.time[0], "0", 2);
        const m4 = Str.lpad(this.time[1], "0", 2);
        return asString ? `${h3}:${m4}` : this.time;
      },
      setTime: function(time) {
        if (Array.isArray(time)) {
          this.time = time;
        } else {
          this.time = time.split(":");
        }
        this._drawCalendar();
      },
      getPreset: function() {
        return this.preset;
      },
      getSelected: function() {
        return this.selected;
      },
      getExcluded: function() {
        return this.exclude;
      },
      getToday: function() {
        return this.today;
      },
      getCurrent: function() {
        return this.current;
      },
      clearSelected: function() {
        this.selected = [];
        this._drawContent();
      },
      toDay: function() {
        const time = datetime();
        this.today = datetime().align("day");
        this.current = {
          year: this.today.year(),
          month: this.today.month(),
          day: this.today.day()
        };
        this.time = [time.hour(), time.minute()];
        this.yearGroupStart = this.today.year();
        this.content = "days";
        this._drawHeader();
        this._drawContent();
      },
      setExclude: function(exclude) {
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.isNull(exclude) && Metro2.utils.isNull(element2.attr("data-exclude"))) {
          return;
        }
        o2.exclude = exclude ? exclude : element2.attr("data-exclude");
        this._dates2array(o2.exclude, "exclude");
        this._drawContent();
      },
      setPreset: function(preset) {
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.isNull(preset) && Metro2.utils.isNull(element2.attr("data-preset"))) {
          return;
        }
        o2.preset = preset ? preset : element2.attr("data-preset");
        this._dates2array(o2.preset, "selected");
        this._drawContent();
      },
      setSpecial: function(special) {
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.isNull(special) && Metro2.utils.isNull(element2.attr("data-special"))) {
          return;
        }
        o2.special = special ? special : element2.attr("data-special");
        this._dates2array(o2.exclude, "special");
        this._drawContent();
      },
      showDate: function(date) {
        return this.setShow(date);
      },
      setShow: function(show) {
        const element2 = this.element;
        const o2 = this.options;
        const attr = element2.attr("data-show");
        if (!show && !attr) {
          return;
        }
        o2.show = show ? show : attr;
        if (!o2.show) {
          this.show = datetime();
        } else {
          if (typeof o2.show === "string" && o2.inputFormat) {
            this.show = Datetime.from(o2.show, o2.inputFormat);
          } else {
            this.show = datetime(o2.show);
          }
        }
        this.show = this.show.align("day");
        this.current = {
          year: this.show.year(),
          month: this.show.month(),
          day: this.show.day()
        };
        this._drawContent();
      },
      setMinDate: function(date) {
        const element2 = this.element;
        const o2 = this.options;
        const attr = element2.attr("data-min-date");
        if (!date && !attr) {
          return;
        }
        o2.minDate = date ? date : attr;
        this.min = o2.minDate ? (o2.inputFormat ? Datetime.from(o2.minDate, o2.inputFormat) : datetime(o2.minDate)).align("day") : null;
        this._drawContent();
      },
      setMaxDate: function(date) {
        const element2 = this.element;
        const o2 = this.options;
        const attr = element2.attr("data-max-date");
        o2.maxDate = date ? date : attr;
        this.max = o2.maxDate ? (o2.inputFormat ? Datetime.from(o2.maxDate, o2.inputFormat) : datetime(o2.maxDate)).align("day") : null;
        this._drawContent();
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-exclude":
            this.setExclude();
            break;
          case "data-preset":
            this.setPreset();
            break;
          case "data-special":
            this.setSpecial();
            break;
          case "data-show":
            this.setShow();
            break;
          case "data-min-date":
            this.setMinDate();
            break;
          case "data-max-date":
            this.setMaxDate();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.off(Metro2.events.click, ".prev-month, .next-month, .prev-year, .next-year");
        element2.off(Metro2.events.click, ".button.today");
        element2.off(Metro2.events.click, ".button.clear");
        element2.off(Metro2.events.click, ".button.cancel");
        element2.off(Metro2.events.click, ".button.done");
        element2.off(Metro2.events.click, ".week-days .day");
        element2.off(Metro2.events.click, ".days-row .day");
        element2.off(Metro2.events.click, ".curr-month");
        element2.off(Metro2.events.click, ".calendar-months li");
        element2.off(Metro2.events.click, ".curr-year");
        element2.off(Metro2.events.click, ".calendar-years li");
        element2.off(Metro2.events.click);
        if (o2.ripple === true) {
          element2.data("ripple").destroy();
        }
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
    $5(document).on(Metro2.events.click, () => {
      $5(".calendar .calendar-years").each(function() {
        $5(this).removeClass("open");
      });
      $5(".calendar .calendar-months").each(function() {
        $5(this).removeClass("open");
      });
    });
    Metro2.defaults.Calendar = CalendarDefaultConfig;
  })(Metro, Dom);

  // source/components/calendarpicker/calendarpicker.js
  ((Metro2, $5) => {
    "use strict";
    let CalendarPickerDefaultConfig = {
      label: "",
      value: "",
      calendarPickerDeferred: 0,
      nullValue: true,
      useNow: false,
      prepend: "",
      dialogMode: false,
      dialogPoint: 640,
      dialogOverlay: true,
      overlayColor: "#000000",
      overlayAlpha: 0.5,
      size: "100%",
      format: METRO_DATE_FORMAT,
      inputFormat: null,
      clearButton: false,
      calendarButtonIcon: "\u{1F4C5}",
      clearButtonIcon: "\u274C",
      copyInlineStyles: false,
      openMode: "auto",
      clsPicker: "",
      clsInput: "",
      clsPrepend: "",
      clsLabel: "",
      onDayClick: Metro2.noop,
      onCalendarPickerCreate: Metro2.noop,
      onCalendarShow: Metro2.noop,
      onCalendarHide: Metro2.noop,
      onChange: Metro2.noop,
      onPickerChange: Metro2.noop,
      onMonthChange: Metro2.noop,
      onYearChange: Metro2.noop
    };
    Metro2.calendarPickerSetup = (options) => {
      CalendarPickerDefaultConfig = $5.extend({}, CalendarPickerDefaultConfig, options);
    };
    if (typeof globalThis.metroCalendarPickerSetup !== "undefined") {
      Metro2.calendarPickerSetup(globalThis.metroCalendarPickerSetup);
    }
    Metro2.Component("calendar-picker", {
      init: function(options, elem) {
        const time = datetime();
        this._super(elem, options, $5.extend({}, Metro2.defaults.Calendar, {}, CalendarPickerDefaultConfig), {
          value: null,
          value_date: null,
          calendar: null,
          overlay: null,
          id: Metro2.utils.elementId("calendar-picker"),
          time: [time.hour(), time.minute()]
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("calendar-picker-create", {
          element: this.element
        });
      },
      _correctTime: (time) => {
        const h3 = Str.lpad(time[0], "0", 2);
        const m4 = Str.lpad(time[1], "0", 2);
        return `${h3}:${m4}`;
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const locale = this.locale;
        const container = $5("<div>").addClass(`input ${element2[0].className} calendar-picker`);
        const buttons = $5("<div>").addClass("button-group");
        let clearButton;
        const cal = $5("<div>");
        let curr;
        let _curr;
        let initHours;
        let initMinutes;
        let elementValue;
        const body = $5("body");
        element2.attr("type", "text");
        element2.attr("autocomplete", "off");
        element2.attr("readonly", true);
        if (Metro2.utils.isValue(o2.initialTime)) {
          this.time = o2.initialTime.trim().split(":");
        }
        if (Metro2.utils.isValue(o2.initialHours)) {
          this.time[0] = Number.parseInt(o2.initialHours);
        }
        if (Metro2.utils.isValue(o2.initialMinutes)) {
          this.time[1] = Number.parseInt(o2.initialMinutes);
        }
        curr = `${o2.value}`.trim() !== "" ? o2.value : element2.val().trim();
        const preset = curr ? curr : "";
        if (!Metro2.utils.isValue(curr)) {
          if (o2.useNow) {
            this.value = datetime().addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
            this.time = [this.value.hour(), this.value.minute()];
          }
        } else {
          _curr = curr.split(" ");
          this.value = (!o2.inputFormat ? datetime(_curr[0]) : Datetime.from(_curr[0], o2.inputFormat, locale)).addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
          if (_curr[1]) {
            this.time = _curr[1].trim().split(":");
          }
        }
        elementValue = !curr && o2.nullValue === true ? "" : datetime(this.value).format(o2.format, locale);
        if (o2.showTime && this.time && elementValue) {
          elementValue += ` ${this._correctTime(this.time)}`;
        }
        element2.val(elementValue);
        container.insertBefore(element2);
        element2.appendTo(container);
        buttons.appendTo(container);
        cal.appendTo(o2.dialogMode ? body : container);
        if (this.time?.length) {
          initHours = this.time[0];
          if (typeof this.time[1] !== "undefined") initMinutes = this.time[1];
        }
        const initTime = o2.initialTime;
        if (o2.initialHours) {
          initHours = o2.initialHours;
        }
        if (o2.initialHours) {
          initMinutes = o2.initialMinutes;
        }
        Metro2.makePlugin(cal, "calendar", {
          showTime: o2.showTime,
          initialTime: initTime,
          initialHours: initHours,
          initialMinutes: initMinutes,
          clsCalendarTime: o2.clsCalendarTime,
          clsTime: o2.clsTime,
          clsTimeHours: o2.clsTimeHours,
          clsTimeMinutes: o2.clsTimeMinutes,
          clsTimeButton: o2.clsTimeButton,
          clsTimeButtonPlus: o2.clsTimeButtonPlus,
          clsTimeButtonMinus: o2.clsTimeButtonMinus,
          wide: o2.wide,
          widePoint: o2.widePoint,
          format: o2.format,
          inputFormat: o2.inputFormat,
          pickerMode: true,
          show: preset,
          preset,
          weekStart: o2.weekStart,
          outside: o2.outside,
          buttons: false,
          headerFormat: o2.headerFormat,
          clsCalendar: [o2.clsCalendar, "calendar-for-picker", o2.dialogMode ? "dialog-mode" : ""].join(" "),
          clsCalendarHeader: o2.clsCalendarHeader,
          clsCalendarContent: o2.clsCalendarContent,
          clsCalendarFooter: "d-none",
          clsCalendarMonths: o2.clsCalendarMonths,
          clsCalendarYears: o2.clsCalendarYears,
          clsToday: o2.clsToday,
          clsSelected: o2.clsSelected,
          clsExcluded: o2.clsExcluded,
          ripple: o2.ripple,
          rippleColor: o2.rippleColor,
          exclude: o2.exclude,
          minDate: o2.minDate,
          maxDate: o2.maxDate,
          yearsBefore: o2.yearsBefore,
          yearsAfter: o2.yearsAfter,
          special: o2.special,
          events: o2.events,
          showHeader: false,
          showFooter: false,
          multiSelect: false,
          showWeekNumber: o2.showWeekNumber,
          onDayClick: (sel, day, time, el) => {
            const date = datetime(sel[0]).addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
            let elementValue2;
            this._removeOverlay();
            this.value = date;
            this.time = time;
            elementValue2 = date.format(o2.format, locale);
            if (o2.showTime) {
              elementValue2 += ` ${this._correctTime(time)}`;
            }
            element2.val(elementValue2);
            element2.trigger("change");
            cal.removeClass("open open-up");
            cal.hide();
            this._fireEvent("change", {
              val: this.value.val(),
              time: this.time
            });
            this._fireEvent("day-click", {
              sel,
              day,
              time,
              el
            });
            this._fireEvent("picker-change", {
              val: this.value.val(),
              time: this.time
            });
          },
          onTimeChange: (time) => {
            let elementValue2;
            this.time = time;
            if (!this.value) {
              this.value = datetime();
            }
            elementValue2 = this.value.format(o2.format, this.locale);
            if (o2.showTime) {
              elementValue2 += ` ${this._correctTime(time)}`;
            }
            element2.val(elementValue2);
            this._fireEvent("change", {
              val: this.value.val(),
              time: this.time
            });
            this._fireEvent("picker-change", {
              val: this.value.val(),
              time: this.time
            });
          },
          onMonthChange: o2.onMonthChange,
          onYearChange: o2.onYearChange
        });
        this.calendar = cal;
        if (o2.clearButton === true) {
          clearButton = $5("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(buttons);
        }
        const calendarButton = $5("<button>").addClass("button input-calendar-button").attr("tabindex", -1).attr("type", "button").html(o2.calendarButtonIcon);
        calendarButton.appendTo(buttons);
        if (o2.prepend !== "") {
          const prepend = $5("<div>").html(o2.prepend);
          prepend.addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
        }
        if (element2.attr("dir") === "rtl") {
          container.addClass("rtl");
        }
        if (String(o2.size).indexOf("%") > -1) {
          container.css({
            width: o2.size
          });
        } else {
          container.css({
            width: `${Number.parseInt(o2.size)}px`
          });
        }
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          $5.each(Metro2.utils.getInlineStyles(element2), (key, value) => {
            container.css(key, value);
          });
        }
        container.addClass(o2.clsPicker);
        element2.addClass(o2.clsInput);
        if (o2.dialogOverlay === true) {
          this.overlay = this._overlay();
        }
        if (o2.dialogMode === true) {
          container.addClass("dialog-mode");
        } else {
          if (Metro2.utils.media(`(max-width: ${o2.dialogPoint}px)`)) {
            container.addClass("dialog-mode");
            this.calendar.addClass("dialog-mode");
          }
        }
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(container);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.parent();
        const clear = container.find(".input-clear-button");
        const cal = this.calendar;
        const cal_plugin = Metro2.getPlugin(cal[0], "calendar");
        const calendar = this.calendar;
        $5(globalThis).on(
          Metro2.events.resize,
          () => {
            if (o2.dialogMode !== true) {
              if (Metro2.utils.media(`(max-width: ${o2.dialogPoint}px)`)) {
                container.addClass("dialog-mode");
                calendar.appendTo("body").addClass("dialog-mode");
              } else {
                container.removeClass("dialog-mode");
                calendar.appendTo(container).removeClass("dialog-mode");
              }
            }
          },
          { ns: this.id }
        );
        if (clear.length > 0)
          clear.on(Metro2.events.click, (e2) => {
            element2.val("").trigger("change").blur();
            this.value = null;
            e2.preventDefault();
            e2.stopPropagation();
          });
        container.on(Metro2.events.click, "button, input", (e2) => {
          const value = this.value ? this.value : datetime().addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
          const presetValue = value.format("YYYY/MM/DD");
          value.align("day");
          if (cal.hasClass("open") === false && cal.hasClass("open-up") === false) {
            $5(".calendar-picker .calendar").removeClass("open open-up").hide();
            cal_plugin.setPreset([presetValue]);
            cal_plugin.setShow(value);
            if (container.hasClass("dialog-mode")) {
              this.overlay.appendTo($5("body"));
            }
            cal.addClass("open");
            if (o2.openMode === "auto") {
              if (!Metro2.utils.inViewport(cal[0])) {
                cal.addClass("open-up");
              }
              if (!Metro2.utils.inViewport(cal[0])) {
                cal.removeClass("open-up");
              }
            } else {
              if (o2.openMode === "up") {
                cal.addClass("open-up");
              }
            }
            this._fireEvent("calendar-show", {
              calendar: cal
            });
          } else {
            this._removeOverlay();
            cal.removeClass("open open-up");
            this._fireEvent("calendar-hide", {
              calendar: cal
            });
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.blur, () => {
          container.removeClass("focused");
        });
        element2.on(Metro2.events.focus, () => {
          container.addClass("focused");
        });
        element2.on(Metro2.events.change, () => {
          Metro2.utils.exec(o2.onChange, [this.value.val()], element2[0]);
        });
        container.on(Metro2.events.click, (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _overlay: function() {
        const o2 = this.options;
        const overlay = $5("<div>");
        overlay.addClass("overlay for-calendar-picker").addClass(o2.clsOverlay);
        if (o2.overlayColor === "transparent") {
          overlay.addClass("transparent");
        } else {
          overlay.css({
            background: Farbe.Routines.toRGBA(o2.overlayColor, o2.overlayAlpha)
          });
        }
        return overlay;
      },
      _removeOverlay: () => {
        $5("body").find(".overlay.for-calendar-picker").remove();
      },
      clear: function() {
        this.value = datetime();
        this.time = [datetime().hour(), datetime().minute()];
        this.element.val("");
      },
      val: function(v4, f5) {
        const element2 = this.element;
        const o2 = this.options;
        let elementValue;
        if (arguments.length === 0 || Metro2.utils.isNull(v4)) {
          return {
            date: this.value.val(),
            time: this.time
          };
        }
        if (v4 === "") {
          return this.clear();
        }
        if (f5) {
          o2.inputFormat = f5;
        }
        const _curr = v4.split(" ");
        this.value = !o2.inputFormat ? datetime(_curr[0]) : Datetime.from(_curr[0], o2.inputFormat, this.locale);
        if (_curr[1]) {
          this.time = _curr[1].trim().split(":");
        }
        this.value.align("day");
        Metro2.getPlugin(this.calendar, "calendar").setTime(this.time);
        elementValue = this.value.format(o2.format);
        if (o2.showTime && this.time && elementValue) {
          elementValue += ` ${this._correctTime(this.time)}`;
        }
        element2.val(elementValue);
        element2.trigger("change");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      getTime: function(asString = false) {
        const h3 = Str.lpad(this.time[0], "0", 2);
        const m4 = Str.lpad(this.time[1], "0", 2);
        return asString ? `${h3}:${m4}` : this.time;
      },
      changeAttribute: function(attributeName, newValue) {
        const cal = Metro2.getPlugin(this.calendar[0], "calendar");
        switch (attributeName) {
          case "value":
            this.val(newValue);
            break;
          case "disabled":
            this.toggleState();
            break;
          case "data-special":
            cal.setSpecial(newValue);
            break;
          case "data-exclude":
            cal.setExclude(newValue);
            break;
          case "data-min-date":
            cal.setMinDate(newValue);
            break;
          case "data-max-date":
            cal.setMaxDate(newValue);
            break;
          case "data-value":
            this.val(newValue);
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.parent();
        const clear = container.find(".input-clear-button");
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        clear.off(Metro2.events.click);
        container.off(Metro2.events.click, "button, input");
        element2.off(Metro2.events.blur);
        element2.off(Metro2.events.focus);
        element2.off(Metro2.events.change);
        Metro2.getPlugin(this.calendar, "calendar").destroy();
        if (o2.label) {
          container.prev("label").remove();
        }
        container.remove();
      }
    });
    $5(document).on(Metro2.events.click, ".overlay.for-calendar-picker", function() {
      $5(this).remove();
      $5(".calendar-for-picker.open").removeClass("open open-up");
    });
    $5(document).on(Metro2.events.click, () => {
      $5(".calendar-picker .calendar").removeClass("open open-up");
    });
  })(Metro, Dom);

  // source/components/carousel/carousel.js
  (function(Metro2, $5) {
    "use strict";
    const effects = [
      "slide",
      "slide-v",
      "fade",
      "switch",
      "zoom",
      "swirl"
    ];
    let CarouselDefaultConfig = {
      carouselDeferred: 0,
      autoStart: false,
      width: "100%",
      height: "16/9",
      // 3/4, 21/9
      effect: effects[0],
      effectFunc: "linear",
      direction: "left",
      //left, right
      duration: 300,
      period: 5e3,
      stopOnMouse: true,
      controls: true,
      controlsOnMouse: false,
      controlsOutside: false,
      controlPrev: "&larr;",
      controlNext: "&rarr;",
      bullets: true,
      bulletsStyle: "square",
      // square, circle, rect, diamond
      bulletsSize: "default",
      // default, mini, small, large
      bulletsPosition: "default",
      // default, left, right
      clsCarousel: "",
      clsSlides: "",
      clsSlide: "",
      clsControls: "",
      clsControlNext: "",
      clsControlPrev: "",
      clsBullets: "",
      clsBullet: "",
      clsBulletOn: "",
      clsThumbOn: "",
      onStop: Metro2.noop,
      onStart: Metro2.noop,
      onPlay: Metro2.noop,
      onSlideClick: Metro2.noop,
      onBulletClick: Metro2.noop,
      onThumbClick: Metro2.noop,
      onMouseEnter: Metro2.noop,
      onMouseLeave: Metro2.noop,
      onNextClick: Metro2.noop,
      onPrevClick: Metro2.noop,
      onSlideShow: Metro2.noop,
      onSlideHide: Metro2.noop,
      onCarouselCreate: Metro2.noop
    };
    Metro2.carouselSetup = function(options) {
      CarouselDefaultConfig = $5.extend({}, CarouselDefaultConfig, options);
    };
    if (typeof globalThis["metroCarouselSetup"] !== "undefined") {
      Metro2.carouselSetup(globalThis["metroCarouselSetup"]);
    }
    Metro2.Component("carousel", {
      init: function(options, elem) {
        this._super(elem, options, CarouselDefaultConfig, {
          height: 0,
          width: 0,
          slides: [],
          current: null,
          currentIndex: null,
          dir: "left",
          interval: false,
          isAnimate: false,
          id: Metro2.utils.elementId("carousel")
        });
        return this;
      },
      _create: function() {
        const element2 = this.element, o2 = this.options;
        const slides = element2.find(".slide");
        let slides_container = element2.find(".slides");
        this.dir = this.options.direction;
        element2.addClass("carousel").addClass(o2.clsCarousel);
        element2.css({
          maxWidth: o2.width
        });
        if (o2.controlsOutside === true) {
          element2.addClass("controls-outside");
        }
        if (slides_container.length === 0) {
          slides_container = $5("<div>").addClass("slides").appendTo(element2);
          slides.appendTo(slides_container);
        }
        slides.addClass(o2.clsSlides);
        if (slides.length > 0) {
          this._createSlides();
          this._createControls();
          this._createBullets();
          this._createEvents();
          this._resize();
          if (o2.controlsOnMouse === true) {
            element2.find("[class*=carousel-switch]").fadeOut(0);
            element2.find(".carousel-bullets").fadeOut(0);
          }
          if (o2.autoStart === true) {
            this._start();
          } else {
            this._fireEvent("slide-show", {
              current: this.slides[this.currentIndex][0],
              prev: void 0
            });
          }
        }
        this._fireEvent("carousel-create", {
          element: element2
        });
      },
      _start: function() {
        const that = this, element2 = this.element, o2 = this.options;
        let period = o2.period;
        const current = this.slides[this.currentIndex];
        if (current.data("period") !== void 0) {
          period = current.data("period");
        }
        if (this.slides.length <= 1) {
          return;
        }
        if (this.interval === false) this.interval = setTimeout(function run() {
          const t = o2.direction === "left" ? "next" : "prior";
          that._slideTo(t, true);
        }, period);
        this._fireEvent("start", {
          element: element2
        });
      },
      _stop: function() {
        clearInterval(this.interval);
        this.interval = false;
      },
      _resize: function() {
        const element2 = this.element, o2 = this.options;
        const width = element2.outerWidth();
        let height;
        let medias = [];
        if (["16/9", "21/9", "4/3"].indexOf(o2.height) > -1) {
          height = Metro2.utils.aspectRatioH(width, o2.height);
        } else {
          if (String(o2.height).indexOf("@") > -1) {
            medias = o2.height.substring(1).toArray("|");
            $5.each(medias, function() {
              const media = this.toArray(",");
              if (globalThis.matchMedia(media[0]).matches) {
                if (["16/9", "21/9", "4/3"].indexOf(media[1]) > -1) {
                  height = Metro2.utils.aspectRatioH(width, media[1]);
                } else {
                  height = parseInt(media[1]);
                }
              }
            });
          } else {
            height = parseInt(o2.height);
          }
        }
        element2.css({
          height
        });
      },
      _createSlides: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const slides = element2.find(".slide");
        $5.each(slides, function(i3) {
          const slide = $5(this);
          if (slide.data("cover") !== void 0) {
            slide.css({
              backgroundImage: "url(" + slide.data("cover") + ")"
            });
          }
          if (i3 !== 0) {
            switch (o2.effect) {
              case "switch":
              case "slide":
                slide.css("left", "100%");
                break;
              case "slide-v":
                slide.css("top", "100%");
                break;
              case "fade":
              case "zoom":
              case "swirl":
                slide.css("opacity", "0");
                break;
            }
          } else {
            slide.addClass("active-slide");
          }
          slide.addClass(o2.clsSlide);
          that.slides.push(slide);
        });
        this.currentIndex = 0;
        this.current = this.slides[this.currentIndex];
      },
      _createControls: function() {
        const element2 = this.element, o2 = this.options;
        let next, prev;
        if (o2.controls === false) {
          return;
        }
        next = $5("<span>").addClass("carousel-switch-next").addClass(o2.clsControls).addClass(o2.clsControlNext).html(`<div></div>`);
        prev = $5("<span>").addClass("carousel-switch-prev").addClass(o2.clsControls).addClass(o2.clsControlPrev).html(`<div></div>`);
        if (o2.controlNext) {
          next.children("div").html(o2.controlNext);
        }
        if (o2.controlPrev) {
          prev.children("div").html(o2.controlPrev);
        }
        next.appendTo(element2);
        prev.appendTo(element2);
      },
      _createBullets: function() {
        const element2 = this.element, o2 = this.options;
        let bullets, i3;
        if (o2.bullets === false) {
          return;
        }
        bullets = $5("<div>").addClass("carousel-bullets").addClass(o2.bulletsSize + "-size").addClass("bullet-style-" + o2.bulletsStyle).addClass(o2.clsBullets);
        if (o2.bulletsPosition === "default" || o2.bulletsPosition === "center") {
          bullets.addClass("flex-justify-center");
        } else if (o2.bulletsPosition === "left") {
          bullets.addClass("flex-justify-start");
        } else {
          bullets.addClass("flex-justify-end");
        }
        for (i3 = 0; i3 < this.slides.length; i3++) {
          const bullet = $5("<span>").addClass("carousel-bullet").addClass(o2.clsBullet).data("slide", i3);
          if (i3 === 0) {
            bullet.addClass("bullet-on").addClass(o2.clsBulletOn);
          }
          bullet.appendTo(bullets);
        }
        bullets.appendTo(element2);
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.click, ".carousel-bullet", function() {
          const bullet = $5(this);
          if (that.isAnimate === false) {
            that._slideToSlide(bullet.data("slide"));
            that._fireEvent("bullet-click", {
              bullet
            });
          }
        });
        element2.on(Metro2.events.click, ".carousel-switch-next", function() {
          if (that.isAnimate === false) {
            that._slideTo("next", false);
            that._fireEvent("next-click", {
              button: this
            });
          }
        });
        element2.on(Metro2.events.click, ".carousel-switch-prev", function() {
          if (that.isAnimate === false) {
            that._slideTo("prev", false);
            that._fireEvent("prev-click", {
              button: this
            });
          }
        });
        if (o2.stopOnMouse === true && o2.autoStart === true) {
          element2.on(Metro2.events.enter, function() {
            that._stop();
            that._fireEvent("mouse-enter", {
              element: element2
            }, false, true);
          });
          element2.on(Metro2.events.leave, function() {
            that._start();
            that._fireEvent("mouse-leave", {
              element: element2
            }, false, true);
          });
        }
        if (o2.controlsOnMouse === true) {
          element2.on(Metro2.events.enter, function() {
            element2.find("[class*=carousel-switch]").fadeIn();
            element2.find(".carousel-bullets").fadeIn();
          });
          element2.on(Metro2.events.leave, function() {
            element2.find("[class*=carousel-switch]").fadeOut();
            element2.find(".carousel-bullets").fadeOut();
          });
        }
        element2.on(Metro2.events.click, ".slide", function() {
          const slide = $5(this);
          that._fireEvent("slide-click", {
            slide
          });
        });
        $5(globalThis).on(Metro2.events.resize, function() {
          that._resize();
        }, { ns: this.id });
      },
      _slideToSlide: function(index) {
        const element2 = this.element, o2 = this.options;
        let current, next, to2;
        if (this.slides[index] === void 0) {
          return;
        }
        if (this.currentIndex === index) {
          return;
        }
        to2 = index > this.currentIndex ? "next" : "prev";
        current = this.slides[this.currentIndex];
        next = this.slides[index];
        this.currentIndex = index;
        this._effect(current, next, o2.effect, to2);
        element2.find(".carousel-bullet").removeClass("bullet-on").removeClass(o2.clsBulletOn);
        element2.find(".carousel-bullet:nth-child(" + (this.currentIndex + 1) + ")").addClass("bullet-on").addClass(o2.clsBulletOn);
      },
      _slideTo: function(to2, interval) {
        const element2 = this.element, o2 = this.options;
        let current, next;
        if (to2 === void 0) {
          to2 = "next";
        }
        current = this.slides[this.currentIndex];
        if (to2 === "next") {
          this.currentIndex++;
          if (this.currentIndex >= this.slides.length) {
            this.currentIndex = 0;
          }
        } else {
          this.currentIndex--;
          if (this.currentIndex < 0) {
            this.currentIndex = this.slides.length - 1;
          }
        }
        next = this.slides[this.currentIndex];
        this._effect(current, next, o2.effect, to2, interval);
        element2.find(".carousel-bullet").removeClass("bullet-on").removeClass(o2.clsBulletOn);
        element2.find(".carousel-bullet:nth-child(" + (this.currentIndex + 1) + ")").addClass("bullet-on").addClass(o2.clsBulletOn);
      },
      _effect: function(current, next, effect, to2, interval) {
        const that = this, o2 = this.options;
        let duration = o2.duration;
        let func, effectFunc = o2.effectFunc;
        let period = o2.period;
        const run = function(f5, c3, n2, o3) {
          Metro2.Effects[f5](c3[0], n2[0], o3);
        };
        if (next.data("duration") !== void 0) {
          duration = next.data("duration");
        }
        if (next.data("effectFunc") !== void 0) {
          effectFunc = next.data("effectFunc");
        }
        if (effect === "switch") {
          duration = 0;
        }
        current.stop(true);
        next.stop(true);
        this.isAnimate = true;
        setTimeout(function() {
          that.isAnimate = false;
        }, duration + 100);
        if (effect === "slide") {
          func = to2 === "next" ? "slideLeft" : "slideRight";
        } else if (effect === "slide-v") {
          func = to2 === "next" ? "slideUp" : "slideDown";
        } else {
          func = effect;
        }
        if (!effects.includes(effect)) {
          func = "switch";
        }
        run(func, current, next, { duration, ease: effectFunc });
        current.removeClass("active-slide");
        next.addClass("active-slide");
        setTimeout(function() {
          that._fireEvent("slide-show", {
            current: next[0],
            prev: current[0]
          });
        }, duration);
        setTimeout(function() {
          that._fireEvent("slide-hide", {
            current: current[0],
            next: next[0]
          });
        }, duration);
        if (interval === true) {
          if (next.data("period") !== void 0) {
            period = next.data("period");
          }
          this.interval = setTimeout(function run2() {
            const t = o2.direction === "left" ? "next" : "prior";
            that._slideTo(t, true);
          }, period);
        }
      },
      toSlide: function(index) {
        this._slideToSlide(index);
      },
      next: function() {
        this._slideTo("next");
      },
      prev: function() {
        this._slideTo("prev");
      },
      stop: function() {
        clearInterval(this.interval);
        this._fireEvent("stop");
      },
      play: function() {
        this._start();
        this._fireEvent("play");
      },
      setEffect: function(effect) {
        const element2 = this.element, o2 = this.options;
        const slides = element2.find(".slide");
        if (!effects.includes(effect)) return;
        o2.effect = effect;
        slides.removeStyleProperty("transform").css({
          top: 0,
          left: 0
        });
      },
      changeAttribute: function(attributeName, newValue) {
        if (attributeName === "data-effect") {
          this.setEffect(newValue);
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        element2.off(Metro2.events.click, ".carousel-bullet");
        element2.off(Metro2.events.click, ".carousel-switch-next");
        element2.off(Metro2.events.click, ".carousel-switch-prev");
        if (o2.stopOnMouse === true && o2.autoStart === true) {
          element2.off(Metro2.events.enter);
          element2.off(Metro2.events.leave);
        }
        if (o2.controlsOnMouse === true) {
          element2.off(Metro2.events.enter);
          element2.off(Metro2.events.leave);
        }
        element2.off(Metro2.events.click, ".slide");
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/charms/charms.js
  ((Metro2, $5) => {
    "use strict";
    let CharmsDefaultConfig = {
      charmsDeferred: 0,
      position: "right",
      opacity: 1,
      clsCharms: "",
      onCharmCreate: Metro2.noop,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onToggle: Metro2.noop
    };
    Metro2.charmsSetup = (options) => {
      CharmsDefaultConfig = $5.extend({}, CharmsDefaultConfig, options);
    };
    if (typeof globalThis.metroCharmsSetup !== "undefined") {
      Metro2.charmsSetup(globalThis.metroCharmsSetup);
    }
    Metro2.Component("charms", {
      init: function(options, elem) {
        this._super(elem, options, CharmsDefaultConfig, {
          origin: {
            background: ""
          }
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("charm-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("charms").addClass(`${o2.position}-side`).addClass(o2.clsCharms);
        this.origin.background = element2.css("background-color");
        element2.css({
          backgroundColor: Farbe.Routines.toRGBA(Metro2.utils.getStyleOne(element2, "background-color"), o2.opacity)
        });
      },
      _createEvents: () => {
      },
      open: function() {
        const element2 = this.element;
        element2.addClass("open");
        this._fireEvent("open");
      },
      close: function() {
        const element2 = this.element;
        element2.removeClass("open");
        this._fireEvent("close");
      },
      toggle: function() {
        const element2 = this.element;
        if (element2.hasClass("open") === true) {
          this.close();
        } else {
          this.open();
        }
        this._fireEvent("toggle");
      },
      opacity: function(v4) {
        const element2 = this.element;
        const o2 = this.options;
        if (v4 === void 0) {
          return o2.opacity;
        }
        const opacity = Math.abs(Number.parseFloat(v4));
        if (opacity < 0 || opacity > 1) {
          return;
        }
        o2.opacity = opacity;
        element2.css({
          backgroundColor: Farbe.Routines.toRGBA(Metro2.utils.getStyleOne(element2, "background-color"), opacity)
        });
      },
      changeOpacity: function() {
        const element2 = this.element;
        this.opacity(element2.attr("data-opacity"));
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-opacity":
            this.changeOpacity();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2.charms = {
      check: (el) => {
        if (Metro2.utils.isMetroObject(el, "charms") === false) {
          console.warn("Element is not a charms component");
          return false;
        }
        return true;
      },
      isOpen: function(el) {
        if (this.check(el) === false) return;
        return $5(el).hasClass("open");
      },
      open: function(el) {
        if (this.check(el) === false) return;
        Metro2.getPlugin(el, "charms").open();
      },
      close: function(el) {
        if (this.check(el) === false) return;
        Metro2.getPlugin(el, "charms").close();
      },
      toggle: function(el) {
        if (this.check(el) === false) return;
        Metro2.getPlugin(el, "charms").toggle();
      },
      closeAll: () => {
        $5("[data-role*=charms]").each(function() {
          Metro2.getPlugin(this, "charms").close();
        });
      },
      opacity: function(el, opacity) {
        if (this.check(el) === false) return;
        Metro2.getPlugin(el, "charms").opacity(opacity);
      }
    };
  })(Metro, Dom);

  // source/components/dropdown/dropdown.js
  (function(Metro2, $5) {
    "use strict";
    const participants = `[data-role-dropmenu], [data-role-dropdown]`;
    const toggleImage = `<svg class="dropdown-caret" aria-hidden="true" width="16" height="16" viewBox="0 0 24 24"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path></svg>`;
    let DropdownDefaultConfig = {
      dropdownDeferred: 0,
      dropFilter: null,
      toggleElement: null,
      align: "left",
      noClose: false,
      duration: 50,
      openMode: "auto",
      openFunc: "show",
      closeFunc: "hide",
      height: "auto",
      onDrop: Metro2.noop,
      onUp: Metro2.noop,
      onDropdownCreate: Metro2.noop
    };
    Metro2.dropdownSetup = function(options) {
      DropdownDefaultConfig = $5.extend({}, DropdownDefaultConfig, options);
    };
    if (typeof globalThis["metroDropdownSetup"] !== "undefined") {
      Metro2.dropdownSetup(globalThis["metroDropdownSetup"]);
    }
    Metro2.Component("dropdown", {
      init: function(options, elem) {
        this._super(elem, options, DropdownDefaultConfig, {
          toggle: null,
          displayOrigin: null,
          isOpen: false,
          level: 0
        });
        return this;
      },
      _create: function() {
        const that = this, element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("dropdown-create", {
          element: element2
        });
        if (element2.hasClass("open")) {
          element2.removeClass("open");
          setTimeout(function() {
            that.open(true);
          }, 0);
        }
      },
      _toggle: function() {
        const element2 = this.element;
        let toggle = element2.siblings(".menu-toggle, .dropdown-toggle, a");
        if (toggle.length === 0) {
          toggle = element2.prev();
          if (toggle.length === 0) {
            throw new Error("Menu toggle not found");
          }
        }
        return toggle[0];
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        const level = element2.parents("[data-role-dropdown]").length;
        let toggle;
        if (o2.openMode === "up") {
          element2.addClass("drop-up");
        }
        toggle = o2.toggleElement ? $5(o2.toggleElement) : $5(this._toggle());
        if (toggle.length) {
          toggle.append(toggleImage);
        }
        this.displayOrigin = Metro2.utils.getStyleOne(element2, "display");
        if (o2.height !== "auto") {
          element2.css({
            "height": o2.height,
            "overflow-y": "auto"
          });
        }
        element2.css("display", "none");
        this.toggle = toggle;
        this.level = level;
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const toggle = this.toggle, parent2 = element2.parent();
        toggle.on(Metro2.events.click, function(e2) {
          $5(".active-container").removeClass("active-container");
          if (element2.css("display") !== "none" && !element2.hasClass("keep-open")) {
            that.close(true, element2);
          } else {
            $5(participants).each(function(i3, el) {
              if (!element2.parents("[data-role-dropdown]").is(el) && !$5(el).hasClass("keep-open") && $5(el).css("display") !== "none") {
                if (!Metro2.utils.isValue(o2.dropFilter)) {
                  that.close(true, el);
                } else {
                  if ($5(el).closest(o2.dropFilter).length > 0) {
                    that.close(true, el);
                  }
                }
              }
            });
            if (element2.hasClass("horizontal")) {
              element2.css({
                "visibility": "hidden",
                "display": "block"
              });
              let children_width = 0;
              $5.each(element2.children("li"), function() {
                children_width += $5(this).outerWidth(true);
              });
              element2.css({
                "visibility": "visible",
                "display": "none"
              });
              element2.css("width", children_width + 2);
            }
            that.open(false, element2);
            parent2.addClass("active-container");
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        if (o2.noClose === true) {
          element2.addClass("keep-open").on(Metro2.events.click, function(e2) {
            e2.stopPropagation();
          });
        }
        $5(element2).find("li.disabled a").on(Metro2.events.click, function(e2) {
          e2.preventDefault();
        });
      },
      _close: function(el, immediate) {
        el = $5(el);
        const dropdown = Metro2.getPlugin(el, "dropdown");
        const toggle = dropdown.toggle;
        const options = dropdown.options;
        let func = options.closeFunc;
        toggle.removeClass("active-toggle").removeClass("active-control");
        dropdown.element.parent().removeClass("active-container");
        if (immediate) {
          func = "hide";
        }
        el[func](immediate ? 0 : options.duration, function() {
          dropdown._fireEvent("close");
          dropdown._fireEvent("up");
          if (options.openMode === "auto") {
            dropdown.element.removeClass("drop-up drop-as-dialog");
          }
        });
        this.isOpen = false;
      },
      _open: function(el, immediate) {
        const dropdown = Metro2.getPlugin(el, "dropdown");
        const options = dropdown.options;
        const func = options.openFunc;
        dropdown.toggle.addClass("active-toggle").addClass("active-control");
        dropdown.element.parent().addClass("active-container");
        dropdown.element[func](immediate ? 0 : options.duration, function() {
          const _el = this, $el = $5(this);
          let wOut = Metro2.utils.viewportOutByWidth(_el);
          let hOut = Metro2.utils.viewportOutByHeight(_el);
          if (options.openMode === "auto") {
            if (hOut) {
              $el.addClass("drop-up");
            }
            if (wOut) {
              $el.addClass("place-right");
            }
            if (Metro2.utils.viewportOut(_el)) {
              $el.removeClass("drop-up place-right").addClass("drop-as-dialog");
            }
          }
          dropdown._fireEvent("open");
          dropdown._fireEvent("drop");
        });
        this.isOpen = true;
      },
      close: function(immediate, el) {
        this._close(el || this.element, immediate);
      },
      open: function(immediate, el) {
        this._open(el || this.element, immediate);
      },
      toggle: function() {
        if (this.isOpen)
          this.close();
        else
          this.open();
      },
      changeAttribute: function() {
      },
      destroy: function() {
        this.toggle.off(Metro2.events.click);
      }
    });
    $5(document).on(Metro2.events.click, function() {
      $5(participants).each(function() {
        const el = $5(this);
        if (el.hasClass("keep-open") || el.hasClass("stay-open") || el.hasClass("ignore-document-click")) return;
        const dd = Metro2.getPlugin(el, "dropdown");
        const dm = Metro2.getPlugin(el, "dropmenu");
        if (dd) {
          dd.close();
        }
        if (dm) {
          dm.close();
        }
      });
    });
  })(Metro, Dom);

  // source/components/select/select.js
  (function(Metro2, $5) {
    "use strict";
    let SelectDefaultConfig = {
      id: "",
      label: "",
      size: "normal",
      selectDeferred: 0,
      clearButton: false,
      clearButtonIcon: "\u274C",
      usePlaceholder: false,
      placeholder: "",
      addEmptyValue: false,
      emptyValue: "",
      duration: 0,
      prepend: "",
      append: "",
      filterPlaceholder: "",
      filter: false,
      dropHeight: 200,
      dropWidth: null,
      dropFullSize: false,
      openMode: "auto",
      showGroupName: false,
      shortTag: true,
      // tag with name max width 120px
      source: null,
      sourceMethod: "GET",
      sourceType: "json",
      filterSource: null,
      filterThreshold: 500,
      clsSelect: "",
      clsSelectInput: "",
      clsPrepend: "",
      clsAppend: "",
      clsOption: "",
      clsOptionActive: "",
      clsOptionGroup: "",
      clsDropList: "",
      clsDropContainer: "",
      clsSelectedItem: "",
      clsSelectedItemAction: "",
      clsLabel: "",
      clsGroupName: "",
      clsFilterInput: "",
      onClear: Metro2.noop,
      onChange: Metro2.noop,
      onUp: Metro2.noop,
      onDrop: Metro2.noop,
      onItemSelect: Metro2.noop,
      onItemDeselect: Metro2.noop,
      onSelectCreate: Metro2.noop,
      onData: (f5) => f5
    };
    Metro2.selectSetup = function(options) {
      SelectDefaultConfig = $5.extend({}, SelectDefaultConfig, options);
    };
    if (typeof globalThis["metroSelectSetup"] !== "undefined") {
      Metro2.selectSetup(globalThis["metroSelectSetup"]);
    }
    Metro2.Component("select", {
      init: function(options, elem) {
        this._super(elem, options, SelectDefaultConfig, {
          list: null,
          placeholder: null,
          observer: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createSelect();
        this._createEvents();
        this._fireEvent("select-create", {
          element: element2
        });
      },
      _setPlaceholder: function() {
        const element2 = this.element, o2 = this.options;
        const input = element2.siblings(".select-input");
        if (o2.usePlaceholder === true && (!Metro2.utils.isValue(element2.val()) || element2.val() == o2.emptyValue)) {
          input.html(o2.placeholder || this.strings.label_select_more);
        }
      },
      _addTag: function(val, data) {
        const element2 = this.element, o2 = this.options;
        let tag, tagSize, container = element2.closest(".select");
        let html = "<span class='title'>" + val + "</span>";
        tag = $5("<div>").addClass("tag").addClass(o2.shortTag ? "short-tag" : "").addClass(o2.clsSelectedItem).html(html).data("option", data);
        $5("<span>").addClass("action unselect-option").addClass(o2.clsSelectedItemAction).html("&times;").appendTo(tag);
        if (container.hasClass("input-large")) {
          tagSize = "large";
        } else if (container.hasClass("input-small")) {
          tagSize = "small";
        }
        tag.addClass(tagSize);
        return tag;
      },
      _addOption: function(item, parent2, input, multiple, group) {
        const option = $5(item);
        let l3, a3;
        const element2 = this.element, o2 = this.options;
        let html = Metro2.utils.isValue(option.attr("data-template")) ? option.attr("data-template").replace("$1", item.text) : item.text;
        const displayValue = option.attr("data-display");
        l3 = $5("<li>").addClass(o2.clsOption).data("option", item).attr("data-text", item.text).attr("data-value", item.value ? item.value : "");
        a3 = $5("<a>").html(html);
        const optionIcon = option.attr("data-icon");
        if (optionIcon) {
          a3.prepend($5("<span>").addClass("icon").html(optionIcon));
        }
        if (displayValue) {
          l3.attr("data-display", displayValue);
          html = displayValue;
        }
        l3.addClass(item.className);
        l3.data("group", group);
        if (option.is(":disabled")) {
          l3.addClass("disabled");
        }
        if (option.is(":selected")) {
          let g4 = "";
          if (o2.showGroupName && group) {
            g4 = `&nbsp;<span class='selected-item__group-name ${o2.clsGroupName}'>${group}</span>`;
          }
          if (multiple) {
            l3.addClass("d-none");
            input.append(this._addTag(a3.html() + g4, l3));
          } else {
            html = a3.html() + g4;
            element2.val(item.value);
            input.html(html);
            element2.fire("change", {
              val: item.value
            });
            l3.addClass("active");
          }
        }
        l3.append(a3).appendTo(parent2);
      },
      _addOptionGroup: function(item, parent2, input, multiple) {
        const that = this, o2 = this.options;
        const group = $5(item);
        $5("<li>").html(item.label).addClass("group-title").addClass(o2.clsOptionGroup).appendTo(parent2);
        $5.each(group.children(), function() {
          that._addOption(this, parent2, input, multiple, item.label);
        });
      },
      _createOptions: function() {
        const that = this, element2 = this.element, o2 = this.options, select = element2.parent();
        const list = select.find("ul").empty();
        const selected = element2.find("option[selected]").length > 0;
        const multiple = element2[0].multiple;
        const input = element2.siblings(".select-input");
        element2.siblings(".select-input").empty();
        if (o2.addEmptyValue === true) {
          element2.prepend(
            $5(
              "<option " + (!selected ? "selected" : "") + " value='" + o2.emptyValue + "' class='d-none'></option>"
            )
          );
        }
        $5.each(element2.children(), function() {
          if (this.tagName === "OPTION") {
            that._addOption(this, list, input, multiple, null);
          } else if (this.tagName === "OPTGROUP") {
            that._addOptionGroup(this, list, input, multiple);
          }
        });
      },
      _createSelect: async function() {
        const element2 = this.element, o2 = this.options;
        const container = element2.wrap("<label>");
        const multiple = element2[0].multiple;
        const select_id = Hooks.useId(container[0]);
        const buttons = $5("<div>").addClass("button-group");
        let input, drop_container, drop_container_input, list, filter_input, dropdown_toggle;
        const checkboxID = Metro2.utils.elementId("select-focus-trigger");
        const checkbox = $5("<input type='checkbox'>").addClass("select-focus-trigger").attr("id", checkboxID);
        this.placeholder = $5("<span>").addClass("placeholder").html(o2.placeholder);
        container.attr("id", o2.id ? o2.id : select_id).attr("for", checkboxID);
        container[0].className = Metro2.utils.classNames(
          element2[0].className,
          "input-" + o2.size,
          "select",
          o2.clsSelect
        );
        dropdown_toggle = $5("<span>").addClass("dropdown-toggle");
        dropdown_toggle.appendTo(container);
        if (multiple) {
          container.addClass("multiple");
        }
        buttons.appendTo(container);
        checkbox.appendTo(container);
        input = $5("<div>").addClass("select-input").addClass(o2.clsSelectInput).attr("name", "__" + select_id + "__");
        drop_container = $5("<div>").addClass("drop-container").addClass(o2.clsDropContainer);
        if (o2.dropFullSize === false) {
          if (o2.dropWidth) {
            drop_container.css({
              width: +o2.dropWidth
            });
          }
        } else {
          container.addClass("drop-full-size");
        }
        drop_container_input = $5("<div>").appendTo(drop_container);
        list = $5("<ul>").addClass("option-list").addClass(o2.clsDropList).css({
          "max-height": o2.dropHeight
        });
        filter_input = $5(
          `<input type='text' data-role='input' data-clear-button-icon="${o2.clearButtonIcon}">`
        ).attr("placeholder", o2.filterPlaceholder || this.strings.label_filter + "...").appendTo(drop_container_input);
        filter_input.addClass(o2.clsFilterInput);
        container.append(input);
        container.append(drop_container);
        drop_container.append(drop_container_input);
        if (o2.filter !== true) {
          drop_container_input.hide();
        }
        drop_container.append(list);
        if (o2.source) {
          await this.fetch(o2.source, {
            method: o2.sourceMethod || "GET",
            headers: {
              "Content-Type": `application/${o2.sourceType || "json"}`
            }
          });
        }
        this._createOptions();
        this._setPlaceholder();
        this._createDroppable(drop_container);
        this.list = list;
        if (o2.clearButton === true && !element2[0].readOnly) {
          const clearButton = $5("<button>").addClass("button input-clear-button").addClass(o2.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(buttons);
        } else {
          buttons.addClass("d-none");
        }
        if (o2.prepend !== "" && !multiple) {
          const prepend = $5("<div>").html(o2.prepend);
          prepend.addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
        }
        if (o2.append !== "" && !multiple) {
          const append = $5("<div>").html(o2.append);
          append.addClass("append").addClass(o2.clsAppend).appendTo(container);
        }
        if (element2.attr("dir") === "rtl") {
          container.addClass("rtl").attr("dir", "rtl");
        }
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(container);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            label.attr("for", checkboxID);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.observer = new MutationObserver(this._updateSelect.bind(this));
        this.observer.observe(element2[0], {
          childList: true,
          subtree: true
        });
      },
      _createDroppable: function(drop_container) {
        const that = this, o2 = this.options;
        const filter_input = drop_container.find("input");
        const container = this.element.closest(".select");
        const dropdown_toggle = drop_container.siblings(".dropdown-caret");
        const list = drop_container.find("ul");
        Metro2.makePlugin(drop_container, "dropdown", {
          dropFilter: ".select",
          duration: o2.duration,
          toggleElement: [container],
          openMode: o2.openMode,
          onDrop: function() {
            let dropped, target;
            dropdown_toggle.addClass("active-toggle");
            dropped = $5(".select .drop-container");
            $5.each(dropped, function() {
              const drop = $5(this);
              if (drop.is(drop_container)) {
                return;
              }
              const dataDrop = Metro2.getPlugin(drop, "dropdown");
              if (dataDrop && dataDrop.close) {
                dataDrop.close();
              }
            });
            filter_input.val("").trigger(Metro2.events.keyup);
            target = list.find("li.active").length > 0 ? $5(list.find("li.active")[0]) : void 0;
            if (target !== void 0) {
              list[0].scrollTop = target.position().top - (list.height() - target.height()) / 2;
            }
            that._fireEvent("drop", {
              list: list[0]
            });
          },
          onUp: function() {
            dropdown_toggle.removeClass("active-toggle");
            that._fireEvent("up", {
              list: list[0]
            });
          }
        });
      },
      _updateSelect: function(mutation) {
        for (let record of mutation) {
          if (record.type === "childList") {
            if (record.addedNodes.length || record.removedNodes.length) {
              this._createOptions();
            }
          }
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const container = element2.closest(".select");
        const drop_container = container.find(".drop-container");
        const input = element2.siblings(".select-input");
        const filter_input = drop_container.find("input");
        const list = drop_container.find("ul");
        const clearButton = container.find(".input-clear-button");
        const checkbox = container.find(".select-focus-trigger");
        checkbox.on("focus", function() {
          container.addClass("focused");
        });
        checkbox.on("blur", function() {
          container.removeClass("focused");
        });
        clearButton.on(Metro2.events.click, function(e2) {
          element2.val(o2.emptyValue);
          if (element2[0].multiple) {
            list.find("li").removeClass("d-none");
          }
          input.clear();
          that._setPlaceholder();
          e2.preventDefault();
          e2.stopPropagation();
          that._fireEvent("clear");
          that._fireEvent("change", {
            selected: that.getSelected()
          });
        });
        element2.on(Metro2.events.change, function() {
          that._setPlaceholder();
        });
        container.on(Metro2.events.click, function() {
          $5(".focused").removeClass("focused");
          container.addClass("focused");
        });
        input.on(Metro2.events.click, function() {
          $5(".focused").removeClass("focused");
          container.addClass("focused");
        });
        list.on(Metro2.events.click, "li", function(e2) {
          if ($5(this).hasClass("group-title")) {
            e2.preventDefault();
            e2.stopPropagation();
            return;
          }
          const leaf = $5(this);
          const displayValue = leaf.attr("data-display");
          const val = leaf.data("value");
          const group = leaf.data("group");
          let html = displayValue ? displayValue : leaf.children("a").html();
          let selected;
          const option = leaf.data("option");
          const options = element2.find("option");
          if (o2.showGroupName && group) {
            html += "&nbsp;<span class='selected-item__group-name " + o2.clsGroupName + "'>" + group + "</span>";
          }
          if (element2[0].multiple) {
            leaf.addClass("d-none");
            input.append(that._addTag(html, leaf));
          } else {
            list.find("li.active").removeClass("active").removeClass(o2.clsOptionActive);
            leaf.addClass("active").addClass(o2.clsOptionActive);
            input.html(html);
            Metro2.getPlugin(drop_container, "dropdown").close();
          }
          $5.each(options, function() {
            if (this === option) {
              this.selected = true;
            }
          });
          that._fireEvent("item-select", {
            val,
            option,
            leaf: leaf[0]
          });
          selected = that.getSelected();
          that._fireEvent("change", {
            selected
          });
        });
        input.on("click", ".tag .action", function(e2) {
          const item = $5(this).closest(".tag");
          const leaf = item.data("option");
          const option = leaf.data("option");
          let selected;
          leaf.removeClass("d-none");
          $5.each(element2.find("option"), function() {
            if (this === option) {
              this.selected = false;
            }
          });
          item.remove();
          that._fireEvent("item-deselect", {
            option
          });
          selected = that.getSelected();
          that._fireEvent("change", {
            selected
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
        const filter_input_change = Hooks.useDebounce(async (e2) => {
          const element3 = this.element, o3 = this.options;
          const list2 = this.list;
          const filter = e2.target.value.toLowerCase();
          const filterSource = `${o3.filterSource}${filter}`;
          if (o3.filterSource) {
            await this.fetch(filterSource, {
              method: o3.sourceMethod || "GET",
              headers: {
                "Content-Type": `application/${o3.sourceType || "json"}`
              }
            }, true);
          } else {
            const li = list2.find("li");
            let i3, a3, t;
            for (i3 = 0; i3 < li.length; i3++) {
              if ($5(li[i3]).hasClass("group-title")) continue;
              a3 = li[i3].getElementsByTagName("a")[0];
              t = a3.innerHTML || a3.innerText;
              if (t.toLowerCase().includes(filter)) {
                li[i3].style.display = "";
              } else {
                li[i3].style.display = "none";
              }
            }
          }
        }, o2.filterThreshold);
        filter_input.on(Metro2.events.keyup, filter_input_change.bind(this));
        filter_input.on(Metro2.events.click, function(e2) {
          e2.preventDefault();
          e2.stopPropagation();
        });
        drop_container.on(Metro2.events.click, function(e2) {
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _clearOptions: function() {
        this.element.clear();
        this.list.clear();
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.closest(".select").addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.closest(".select").removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      reset: function(to_default) {
        const element2 = this.element;
        const options = element2.find("option");
        const select = element2.closest(".select");
        let selected;
        $5.each(options, function() {
          this.selected = !Metro2.utils.isNull(to_default) ? this.defaultSelected : false;
        });
        this.list.find("li").remove();
        select.find(".select-input").html("");
        this._createOptions();
        selected = this.getSelected();
        this._fireEvent("change", {
          selected
        });
      },
      getSelected: function() {
        const element2 = this.element;
        const result = [];
        element2.find("option").each(function() {
          if (this.selected) result.push(this.value);
        });
        return result;
      },
      val: function(val) {
        const that = this, element2 = this.element, o2 = this.options;
        const input = element2.siblings(".select-input");
        const options = element2.find("option");
        const list_items = this.list.find("li");
        const result = [];
        const multiple = !!element2.attr("multiple");
        let option;
        let i3, html, list_item, option_value, selected, group;
        if (Metro2.utils.isNull(val)) {
          $5.each(options, function() {
            if (this.selected) result.push(this.value);
          });
          return multiple ? result : result[0];
        }
        $5.each(options, function() {
          this.selected = false;
        });
        list_items.removeClass("active").removeClass(o2.clsOptionActive);
        input.html("");
        if (Array.isArray(val) === false) {
          val = [val];
        }
        $5.each(val, function() {
          for (i3 = 0; i3 < options.length; i3++) {
            option = options[i3];
            html = Metro2.utils.isValue(option.getAttribute("data-template")) ? option.getAttribute("data-template").replace("$1", option.text) : option.text;
            if ("" + option.value === "" + this) {
              option.selected = true;
              break;
            }
          }
          for (i3 = 0; i3 < list_items.length; i3++) {
            list_item = $5(list_items[i3]);
            group = list_item.data("group");
            option_value = list_item.attr("data-value");
            if ("" + option_value === "" + this) {
              if (o2.showGroupName && group) {
                html += "&nbsp;<span class='selected-item__group-name'>" + group + "</span>";
              }
              if (multiple) {
                list_item.addClass("d-none");
                input.append(that._addTag(html, list_item));
              } else {
                list_item.addClass("active").addClass(o2.clsOptionActive);
                input.html(html);
              }
              break;
            }
          }
        });
        selected = this.getSelected();
        this._fireEvent("change", {
          selected
        });
      },
      options: function(op, selected, delimiter) {
        return this.data(op, selected, delimiter);
      },
      data: function(op, selected, delimiter) {
        const element2 = this.element;
        let option_group, _selected;
        const _delimiter = delimiter || ",";
        if (typeof selected === "string") {
          _selected = selected.toArray(_delimiter).map(function(v4) {
            return isNaN(v4) ? v4 : +v4;
          });
        } else if (Array.isArray(selected)) {
          _selected = selected.slice().map(function(v4) {
            return isNaN(v4) ? v4 : +v4;
          });
        } else {
          _selected = [];
        }
        this.observer.disconnect();
        element2.empty();
        if (typeof op === "string") {
          element2.html(op);
        } else if (Metro2.utils.isObject2(op)) {
          $5.each(op, function(key, val) {
            if (Metro2.utils.isObject2(val)) {
              option_group = $5("<optgroup label=''>").attr("label", key).appendTo(element2);
              $5.each(val, function(key2, val2) {
                const op2 = $5("<option>").attr("value", key2).text(val2).appendTo(option_group);
                if (_selected.indexOf(+key2) > -1) {
                  op2.prop("selected", true);
                }
              });
            } else {
              const op2 = $5("<option>").attr("value", key).text(val).appendTo(element2);
              if (_selected.indexOf(key) > -1) {
                op2.prop("selected", true);
              }
            }
          });
        }
        this._createOptions();
        this.observer.observe(element2[0], {
          childList: true,
          subtree: true
        });
        return this;
      },
      addOption: function(val, title, selected) {
        const element2 = this.element;
        const option = $5("<option>").attr("value", val).text(title ? title : val);
        element2.append(option);
        if (selected) {
          if (element2[0].multiple) {
          } else {
            element2.find("option").prop("selected", false);
          }
          option.prop("selected", true);
        }
        return this;
      },
      addOptions: function(values) {
        const that = this;
        if (!values) {
          return this;
        }
        this.observer.disconnect();
        if (Array.isArray(values)) {
          $5.each(values, function() {
            const o2 = this;
            if (Metro2.utils.isObject2(o2)) {
              that.addOption(o2.val, o2.title, o2.selected);
            } else {
              that.addOption(o2);
            }
          });
        } else if (Metro2.utils.isObject2(values)) {
          $5.each(values, function(key, val) {
            that.addOption(key, val);
          });
        }
        this._createOptions();
        this.observer.observe(element[0], {
          childList: true,
          subtree: true
        });
        return this;
      },
      removeOption: function(val) {
        const element2 = this.element;
        const options = element2.find("option");
        options.each(function() {
          const $el = $5(this);
          if ($el.attr("value") == val) {
            $el.remove();
          }
        });
        this._createOptions();
        return this;
      },
      removeOptions: function(values) {
        const element2 = this.element;
        const options = element2.find("option");
        if (!values || !Array.isArray(values)) {
          return this;
        }
        options.each(function() {
          const $el = $5(this);
          const val = $el.attr("value");
          if (values.indexOf(val) > -1) {
            $el.remove();
          }
        });
        this._createOptions();
        return this;
      },
      fetch: async function(source, options, clearOptions = false) {
        const element2 = this.element, o2 = this.options;
        const _options = Object.assign({
          method: "GET",
          headers: {
            "Content-Type": `application/${o2.sourceType}`
          }
        }, options);
        const result = await fetch(source, _options);
        if (result.ok === false) {
          return;
        }
        if (clearOptions) {
          this._clearOptions();
        }
        let data = o2.sourceType === "json" ? await result.json() : await result.text();
        data = Metro2.utils.exec(o2.onData, [data], element2[0]);
        $5.each(data, function() {
          const option = $5("<option>").attr("value", this.value).html(this.text);
          if (this.icon) {
            option.attr("data-icon", this.icon);
          }
          option.appendTo(element2);
        });
      },
      changeAttribute: function(attributeName) {
        if (attributeName === "disabled") {
          this.toggleState();
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        const container = element2.closest(".select");
        const drop_container = container.find(".drop-container");
        const input = element2.siblings(".select-input");
        const filter_input = drop_container.find("input");
        const list = drop_container.find("ul");
        const clearButton = container.find(".input-clear-button");
        container.off(Metro2.events.click);
        container.off(Metro2.events.click, ".input-clear-button");
        input.off(Metro2.events.click);
        filter_input.off(Metro2.events.blur);
        filter_input.off(Metro2.events.focus);
        list.off(Metro2.events.click, "li");
        filter_input.off(Metro2.events.keyup);
        drop_container.off(Metro2.events.click);
        clearButton.off(Metro2.events.click);
        drop_container.data("dropdown").destroy();
        if (o2.label) {
          container.prev("label").remove();
        }
        container.remove();
      }
    });
    $5(document).on(
      Metro2.events.click,
      function() {
        $5(".select").removeClass("focused");
      },
      { ns: "blur-select-elements" }
    );
  })(Metro, Dom);

  // source/components/input/input.js
  (function(Metro2, $5) {
    "use strict";
    let InputDefaultConfig = {
      inputDeferred: 0,
      label: "",
      autocomplete: null,
      autocompleteUrl: null,
      autocompleteUrlMethod: "GET",
      autocompleteUrlKey: null,
      autocompleteDivider: ",",
      autocompleteListHeight: 200,
      history: false,
      historyPreset: "",
      historyDivider: "|",
      preventSubmit: false,
      defaultValue: "",
      size: "default",
      prepend: "",
      append: "",
      searchButton: false,
      clearButton: true,
      revealButton: true,
      randomButton: false,
      clearButtonIcon: "\u274C",
      revealButtonIcon: "\u{1F440}",
      searchButtonIcon: "\u{1F50D}",
      randomButtonIcon: "\u{1F3B2}",
      customButtons: [],
      searchButtonClick: "submit",
      randomSymbols: "0123456789;abcdefghijklmnopqrstuvwxyz;ABCDEFGHIJKLMNOPQRSTUVWXYZ;<>!?@#$%^&*()_+",
      randomLength: 12,
      prependOptions: "",
      prependOptionsSep: ",",
      appendOptions: "",
      appendOptionsSep: ",",
      badge: null,
      clsComponent: "",
      clsInput: "",
      clsPrepend: "",
      clsAppend: "",
      clsClearButton: "",
      clsRevealButton: "",
      clsCustomButton: "",
      clsSearchButton: "",
      clsRandomButton: "",
      clsLabel: "",
      onAutocompleteSelect: Metro2.noop,
      onHistoryChange: Metro2.noop,
      onHistoryUp: Metro2.noop,
      onHistoryDown: Metro2.noop,
      onClearClick: Metro2.noop,
      onRevealClick: Metro2.noop,
      onSearchButtonClick: Metro2.noop,
      onEnterClick: Metro2.noop,
      onInputCreate: Metro2.noop
    };
    Metro2.inputSetup = function(options) {
      InputDefaultConfig = $5.extend({}, InputDefaultConfig, options);
    };
    if (typeof globalThis["metroInputSetup"] !== "undefined") {
      Metro2.inputSetup(globalThis["metroInputSetup"]);
    }
    Metro2.Component("input", {
      init: function(options, elem) {
        this._super(elem, options, InputDefaultConfig, {
          history: [],
          historyIndex: -1,
          autocomplete: [],
          prependOptionsList: null,
          appendOptionsList: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("input-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const container = element2.wrap("<div>").addClass("input " + element2[0].className);
        let buttons, clearButton, revealButton, searchButton, randomButton;
        if (Metro2.utils.isValue(o2.historyPreset)) {
          $5.each(o2.historyPreset.toArray(o2.historyDivider), function() {
            that.history.push(this);
          });
          that.historyIndex = that.history.length - 1;
        }
        if (element2.attr("type") === void 0) {
          element2.attr("type", "text");
        }
        buttons = $5("<div>").addClass("button-group").appendTo(container);
        if (!Metro2.utils.isValue(element2.val().trim())) {
          element2.val(o2.defaultValue);
        }
        if (o2.clearButton === true && !element2[0].readOnly) {
          clearButton = $5("<button>").addClass("button input-clear-button").addClass(o2.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon).attr("title", this.strings.label_clear_input);
          clearButton.appendTo(buttons);
        }
        if (element2.attr("type") === "password" && o2.revealButton === true) {
          revealButton = $5("<button>").addClass("button input-reveal-button").addClass(o2.clsRevealButton).attr("tabindex", -1).attr("type", "button").html(o2.revealButtonIcon).attr("title", this.strings.label_reveal_password);
          revealButton.appendTo(buttons);
        }
        if (o2.searchButton === true) {
          searchButton = $5("<button>").addClass("button input-search-button").addClass(o2.clsSearchButton).attr("tabindex", -1).attr("type", o2.searchButtonClick === "submit" ? "submit" : "button").html(o2.searchButtonIcon).attr("title", this.strings.label_search_input);
          searchButton.appendTo(buttons);
        }
        if (o2.randomButton === true) {
          randomButton = $5("<button>").addClass("button input-random-button").addClass(o2.clsRandomButton).attr("tabindex", -1).attr("type", "button").html(o2.randomButtonIcon).attr("title", this.strings.label_generate_random);
          randomButton.appendTo(buttons);
        }
        let opt2, ul;
        if (o2.prepend) {
          $5("<div>").html(o2.prepend).addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
        }
        if (o2.prependOptions) {
          opt2 = $5("<div>").addClass("prepend-options").appendTo(container);
          opt2.append(ul = $5("<select data-role='select'>").addClass("options-list"));
          o2.prependOptions.toArray(o2.prependOptionsSep).forEach(function(item) {
            $5("<option>").attr("value", item).html(item).appendTo(ul);
          });
          this.prependOptionsList = ul;
        }
        if (o2.append) {
          $5("<div>").html(o2.append).addClass("append").addClass(o2.clsAppend).appendTo(container);
        }
        if (o2.appendOptions) {
          opt2 = $5("<div>").addClass("append-options").appendTo(container);
          opt2.append(ul = $5("<select data-role='select'>").addClass("options-list"));
          o2.appendOptions.toArray(o2.appendOptionsSep).forEach(function(item) {
            $5("<option>").attr("value", item).html(item).appendTo(ul);
          });
          this.appendOptionsList = ul;
        }
        const customButtons = Metro2.utils.isObject(o2.customButtons);
        if (Array.isArray(customButtons)) {
          $5.each(customButtons, function() {
            const item = this;
            const btn = $5("<button>");
            btn.addClass("button input-custom-button").addClass(o2.clsCustomButton).addClass(item.cls).attr("tabindex", -1).attr("type", "button").html(item.text);
            if (item.attr && typeof item.attr === "object") {
              $5.each(item.attr, function(k4, v4) {
                btn.attr(Str.dashedName(k4), v4);
              });
            }
            if (item.onclick) btn.on("click", () => {
              item.onclick.apply(btn, [element2.valueOf(), element2]);
            });
            btn.appendTo(buttons);
          });
        }
        if (Metro2.utils.isValue(element2.attr("data-exclaim"))) {
          container.attr("data-exclaim", element2.attr("data-exclaim"));
        }
        if (element2.attr("dir") === "rtl") {
          container.addClass("rtl").attr("dir", "rtl");
        }
        element2[0].className = "";
        container.addClass(o2.clsComponent);
        element2.addClass(o2.clsInput);
        if (o2.size !== "default") {
          container.css({
            width: o2.size
          });
        }
        if (!Metro2.utils.isNull(o2.autocomplete) || !Metro2.utils.isNull(o2.autocompleteUrl)) {
          $5("<div>").addClass("autocomplete-list").css({
            maxHeight: o2.autocompleteListHeight,
            display: "none"
          }).appendTo(container);
        }
        if (Metro2.utils.isValue(o2.autocomplete)) {
          const autocomplete_obj = Metro2.utils.isObject(o2.autocomplete);
          if (autocomplete_obj !== false) {
            this.autocomplete = autocomplete_obj;
          } else {
            this.autocomplete = o2.autocomplete.toArray(o2.autocompleteDivider);
          }
        }
        if (Metro2.utils.isValue(o2.autocompleteUrl)) {
          fetch(o2.autocompleteUrl, {
            method: o2.autocompleteUrlMethod
          }).then(function(response) {
            return response.text();
          }).then(function(data) {
            let newData = [];
            try {
              newData = JSON.parse(data);
              if (o2.autocompleteUrlKey) {
                newData = newData[o2.autocompleteUrlKey];
              }
            } catch (e2) {
              newData = data.split("\n");
            }
            that.autocomplete = that.autocomplete.concat(newData);
          });
        }
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(container);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            element2.id(id);
            label.attr("for", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (o2.badge) {
          container.append($5("<div>").addClass("badge").html(o2.badge));
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.component = container;
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const container = element2.closest(".input");
        const autocompleteList = container.find(".autocomplete-list");
        container.on(Metro2.events.click, ".input-clear-button", function() {
          const curr = element2.val();
          element2.val(Metro2.utils.isValue(o2.defaultValue) ? o2.defaultValue : "").fire("clear").fire("change").fire("keyup").focus();
          if (autocompleteList.length > 0) {
            autocompleteList.css({
              display: "none"
            });
          }
          that._fireEvent("clear-click", {
            prev: curr
          });
        });
        container.on(Metro2.events.click, ".input-reveal-button", function() {
          if (element2.attr("type") === "password") {
            element2.attr("type", "text");
          } else {
            element2.attr("type", "password");
          }
          that._fireEvent("reveal-click", {
            val: element2.val()
          });
        });
        container.on(Metro2.events.click, ".input-search-button", function() {
          if (o2.searchButtonClick !== "submit") {
            console.log("Search button clicked");
            that._fireEvent("search-button-click", {
              val: that.val(),
              button: this
            });
          } else {
            if (this.form) this.form.submit();
          }
        });
        container.on(Metro2.events.click, ".input-random-button", function() {
          const val = that._generateRandomValue();
          element2.val(val).fire("change").fire("keyup").focus();
          that._fireEvent("random-click", {
            val
          });
        });
        element2.on(Metro2.events.keyup, function(e2) {
          const val = element2.val().trim();
          if (o2.history && e2.keyCode === Metro2.keyCode.ENTER && val !== "") {
            element2.val("");
            that.history.push(val);
            that.historyIndex = that.history.length - 1;
            that._fireEvent("history-change", {
              val,
              history: that.history,
              historyIndex: that.historyIndex
            });
            if (o2.preventSubmit === true) {
              e2.preventDefault();
            }
          }
          if (o2.history && e2.keyCode === Metro2.keyCode.UP_ARROW) {
            that.historyIndex--;
            if (that.historyIndex >= 0) {
              element2.val("");
              element2.val(that.history[that.historyIndex]);
              that._fireEvent("history-down", {
                val: element2.val(),
                history: that.history,
                historyIndex: that.historyIndex
              });
            } else {
              that.historyIndex = 0;
            }
            e2.preventDefault();
          }
          if (o2.history && e2.keyCode === Metro2.keyCode.DOWN_ARROW) {
            that.historyIndex++;
            if (that.historyIndex < that.history.length) {
              element2.val("");
              element2.val(that.history[that.historyIndex]);
              that._fireEvent("history-up", {
                val: element2.val(),
                history: that.history,
                historyIndex: that.historyIndex
              });
            } else {
              that.historyIndex = that.history.length - 1;
            }
            e2.preventDefault();
          }
        });
        element2.on(Metro2.events.keydown, function(e2) {
          if (e2.keyCode === Metro2.keyCode.ENTER) {
            that._fireEvent("enter-click", {
              val: element2.val()
            });
          }
        });
        element2.on(Metro2.events.blur, function() {
          container.removeClass("focused");
        });
        element2.on(Metro2.events.focus, function() {
          container.addClass("focused");
        });
        element2.on(Metro2.events.input, function() {
          const val = this.value.toLowerCase();
          that._drawAutocompleteList(val);
        });
        container.on(Metro2.events.click, ".autocomplete-list .item", function() {
          const val = $5(this).attr("data-autocomplete-value");
          element2.val(val);
          autocompleteList.css({
            display: "none"
          });
          element2.trigger("change");
          that._fireEvent("autocomplete-select", {
            value: val
          });
        });
      },
      _generateRandomValue: function() {
        const o2 = this.options;
        const groups = o2.randomSymbols.split(";");
        const symbolsPerGroup = Math.round(o2.randomLength / groups.length);
        let val = [];
        for (const g4 of groups) {
          const symbols = g4.split("");
          const len = symbols.length;
          for (let i3 = 0; i3 < symbolsPerGroup; i3++) {
            val.push(symbols[Math.floor(Math.random() * len)]);
          }
        }
        return val.shuffle().join("");
      },
      _drawAutocompleteList: function(val) {
        const that = this, element2 = this.element;
        const container = element2.closest(".input");
        const autocompleteList = container.find(".autocomplete-list");
        let items;
        if (autocompleteList.length === 0) {
          return;
        }
        autocompleteList.html("");
        items = this.autocomplete.filter(function(item) {
          return item.toLowerCase().indexOf(val) > -1;
        });
        autocompleteList.css({
          display: items.length > 0 ? "block" : "none"
        });
        $5.each(items, function() {
          const v4 = this;
          let index = v4.toLowerCase().indexOf(val), content;
          const item = $5("<div>").addClass("item").attr("data-autocomplete-value", v4);
          if (index === 0) {
            content = "<strong>" + v4.substring(0, val.length) + "</strong>" + v4.substring(val.length);
          } else {
            content = v4.substring(0, index) + "<strong>" + v4.substring(index, val.length) + "</strong>" + v4.substring(index + val.length);
          }
          item.html(content).appendTo(autocompleteList);
          that._fireEvent("draw-autocomplete-item", {
            item
          });
        });
      },
      getHistory: function() {
        return this.history;
      },
      getHistoryIndex: function() {
        return this.historyIndex;
      },
      setHistoryIndex: function(val) {
        this.historyIndex = val >= this.history.length ? this.history.length - 1 : val;
      },
      setHistory: function(history2, append) {
        const that = this, o2 = this.options;
        if (Metro2.utils.isNull(history2)) return;
        if (!Array.isArray(history2) && typeof history2 === "string") {
          history2 = history2.toArray(o2.historyDivider);
        }
        if (append === true) {
          $5.each(history2, function() {
            that.history.push(this);
          });
        } else {
          this.history = history2;
        }
        this.historyIndex = this.history.length - 1;
      },
      clear: function() {
        this.element.val("");
      },
      toDefault: function() {
        this.element.val(Metro2.utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      setAutocompleteList: function(l3) {
        const autocomplete_list = Metro2.utils.isObject(l3);
        if (autocomplete_list !== false) {
          this.autocomplete = autocomplete_list;
        } else if (typeof l3 === "string") {
          this.autocomplete = l3.toArray(this.options.autocompleteDivider);
        }
      },
      val: function(v4, splitter = ";") {
        const element2 = this.element, o2 = this.options;
        if (!Metro2.utils.isValue(v4)) {
          let val2 = element2.val();
          if (o2.prependOptions) {
            val2 = this.prependOptionsList.val() + val2;
          }
          if (o2.appendOptions) {
            val2 = val2 + this.appendOptionsList.val();
          }
          return val2;
        }
        const groups = v4.split(splitter);
        let prepend = "", append = "", val;
        if (o2.prependOptions) {
          prepend = groups.shift();
          Metro2.getPlugin(this.prependOptionsList, "select").val(prepend);
          console.log(prepend);
        }
        if (o2.appendOptions) {
          append = groups.pop();
          Metro2.getPlugin(this.appendOptionsList, "select").val(append);
        }
        val = groups.join("");
        element2.val(val);
      },
      prependOptionsVal: function(v4) {
        if (!this.options.prependOptions) {
          return;
        }
        if (!Metro2.utils.isValue(v4)) {
          this.prependOptionsList.val();
        }
        this.prependOptionsList.val(v4);
      },
      appendOptionsVal: function(v4) {
        if (!this.options.appendOptions) {
          return;
        }
        if (!Metro2.utils.isValue(v4)) {
          return this.appendOptionsList.val();
        }
        this.appendOptionsList.val(v4);
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        const parent2 = element2.parent();
        const clearBtn = parent2.find(".input-clear-button");
        const revealBtn = parent2.find(".input-reveal-button");
        const customBtn = parent2.find(".input-custom-button");
        if (clearBtn.length > 0) {
          clearBtn.off(Metro2.events.click);
        }
        if (revealBtn.length > 0) {
          revealBtn.off(Metro2.events.start);
          revealBtn.off(Metro2.events.stop);
        }
        if (customBtn.length > 0) {
          clearBtn.off(Metro2.events.click);
        }
        element2.off(Metro2.events.blur);
        element2.off(Metro2.events.focus);
        if (o2.label) {
          parent2.prev("label").remove();
        }
        parent2.remove();
      }
    });
    $5(document).on(Metro2.events.click, function() {
      $5(".input .autocomplete-list").hide();
    });
  })(Metro, Dom);

  // source/components/chat/chat.js
  ((Metro2, $5) => {
    "use strict";
    let ChatDefaultConfig = {
      chatDeferred: 0,
      inputTimeFormat: null,
      timeFormat: "D MMM hh:mm A",
      name: "John Doe",
      avatar: "<span>\u{1F466}</span>",
      welcome: null,
      welcomeAvatar: "<span>\u{1F47D}</span>",
      title: null,
      width: "100%",
      height: "auto",
      messages: null,
      sendButtonTitle: "",
      sendButtonIcon: "",
      readonly: false,
      clsChat: "",
      clsName: "",
      clsTime: "",
      clsInput: "",
      clsSendButton: "",
      clsMessageLeft: "default",
      clsMessageRight: "default",
      onMessage: Metro2.noop,
      onSend: Metro2.noop,
      onSendButtonClick: Metro2.noop,
      onChatCreate: Metro2.noop
    };
    Metro2.chatSetup = (options) => {
      ChatDefaultConfig = $5.extend({}, ChatDefaultConfig, options);
    };
    if (typeof globalThis.metroChatSetup !== "undefined") {
      Metro2.chatSetup(globalThis.metroChatSetup);
    }
    Metro2.Component("chat", {
      init: function(options, elem) {
        this._super(elem, options, ChatDefaultConfig, {
          input: null,
          classes: "primary secondary success alert warning yellow info dark light".split(" "),
          lastMessage: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("chat-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const customButtons = [
          {
            html: `${o2.sendButtonTitle || this.strings.label_send}${o2.sendButtonIcon}`,
            cls: `${o2.clsSendButton} js-chat-send-button`,
            onclick: o2.onSendButtonClick
          }
        ];
        element2.addClass("chat").addClass(o2.clsChat);
        element2.css({
          width: o2.width,
          height: o2.height
        });
        if (Metro2.utils.isValue(o2.title)) {
          $5("<div>").addClass("title").html(o2.title).appendTo(element2);
        }
        const messages = $5("<div>").addClass("messages");
        messages.appendTo(element2);
        const messageInput = $5("<div>").addClass("message-input").appendTo(element2);
        const input = $5("<input type='text'>").addClass("chat-input");
        input.appendTo(messageInput);
        setTimeout(() => {
          Metro2.makePlugin(input[0], "input", {
            customButtons,
            clsInput: o2.clsInput
          });
        });
        if (o2.welcome) {
          this.add({
            text: o2.welcome,
            time: datetime(),
            position: "left",
            name: "Chat Bot",
            avatar: o2.welcomeAvatar
          });
        }
        if (Metro2.utils.isValue(o2.messages) && typeof o2.messages === "string") {
          o2.messages = Metro2.utils.isObject(o2.messages);
        }
        if (!Metro2.utils.isNull(o2.messages) && typeof o2.messages === "object" && Metro2.utils.objectLength(o2.messages) > 0) {
          $5.each(o2.messages, function() {
            that.add(this);
          });
        }
        element2.find(".message-input")[o2.readonly ? "addClass" : "removeClass"]("disabled");
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const send = () => {
          const input = element2.find(".chat-input input");
          const msg = `${input.val()}`;
          if (msg.trim() === "") {
            return false;
          }
          const m4 = {
            id: Metro2.utils.elementId("chat-message"),
            name: o2.name,
            avatar: o2.avatar,
            text: msg,
            position: "right",
            time: datetime()
          };
          this.add(m4);
          input.val("");
          this._fireEvent("send", {
            msg: m4
          });
          input.focus();
        };
        element2.on(Metro2.events.click, ".js-chat-send-button", () => {
          send();
        });
        element2.on(Metro2.events.keyup, ".chat-input > input", (e2) => {
          if (e2.keyCode === Metro2.keyCode.ENTER) {
            send();
          }
        });
      },
      add: function(msg) {
        const element2 = this.element;
        const o2 = this.options;
        const locale = this.locale;
        let message;
        let sender;
        let item;
        let avatar;
        let text;
        const messages = element2.find(".messages");
        const messageDate = o2.inputTimeFormat ? Datetime.from(msg.time, o2.inputTimeFormat, locale) : datetime(msg.time);
        message = $5("<div>").addClass("message").addClass(msg.position).appendTo(messages);
        item = $5("<div>").addClass("message-item").appendTo(message);
        if (Metro2.utils.isUrl(msg.avatar) || msg.avatar.includes("data:image")) {
          avatar = $5("<img>").attr("src", msg.avatar).attr("alt", msg.avatar).addClass("message-avatar").appendTo(item);
        } else if (msg.avatar) {
          const _el = $5(msg.avatar);
          if (_el.length) {
            avatar = _el.addClass("message-avatar").appendTo(item);
          } else {
            avatar = $5("<span>").addClass("message-avatar").html(msg.avatar).appendTo(item);
          }
        }
        text = $5("<div>").addClass("message-text").append($5("<div>").addClass("message-text-inner").html(Str.escapeHtml(msg.text))).appendTo(item);
        const time = $5("<div>").addClass("message-time").addClass(o2.clsTime).text(messageDate.format(o2.timeFormat)).appendTo(text);
        sender = $5("<div>").addClass("message-sender").addClass(o2.clsName).text(msg.name).appendTo(text);
        if (Metro2.utils.isValue(msg.id)) {
          message.attr("id", msg.id);
        }
        if (msg.position === "left" && Metro2.utils.isValue(o2.clsMessageLeft)) {
          text.addClass(o2.clsMessageLeft);
        }
        if (msg.position === "right" && Metro2.utils.isValue(o2.clsMessageRight)) {
          text.addClass(o2.clsMessageRight);
        }
        if (this.lastMessage && this.lastMessage.position === msg.position) {
          text.addClass("--next");
          avatar.visible(false);
          sender.hide();
        }
        this._fireEvent("message", {
          msg,
          el: {
            message,
            sender,
            time,
            item,
            avatar,
            text
          }
        });
        messages.animate({
          draw: {
            scrollTop: messages[0].scrollHeight
          },
          dur: 1e3
        });
        this.lastMessage = msg;
        return this;
      },
      addMessages: function(messages) {
        const that = this;
        let _messages = messages;
        if (Metro2.utils.isValue(_messages) && typeof _messages === "string") {
          _messages = Metro2.utils.isObject(_messages);
        }
        if (typeof _messages === "object" && Metro2.utils.objectLength(_messages) > 0) {
          $5.each(_messages, function() {
            that.add(this);
          });
        }
        return this;
      },
      delMessage: function(id) {
        const element2 = this.element;
        element2.find(".messages").find(`#${id}`).remove();
        return this;
      },
      updMessage: function(msg) {
        const element2 = this.element;
        const message = element2.find(".messages").find(`#${msg.id}`);
        const o2 = this.options;
        const locale = this.locale;
        if (message.length === 0) return this;
        const messageDate = o2.inputTimeFormat ? Datetime.from(msg.time, o2.inputTimeFormat, locale) : datetime(msg.time);
        message.find(".message-text-inner").html(msg.text);
        message.find(".message-time").html(messageDate.format(o2.timeFormat));
        return this;
      },
      clear: function() {
        const element2 = this.element;
        const messages = element2.find(".messages");
        messages.html("");
        this.lastMessage = null;
      },
      toggleReadonly: function(readonly) {
        const element2 = this.element;
        const o2 = this.options;
        o2.readonly = typeof readonly === "undefined" ? !o2.readonly : readonly;
        element2.find(".message-input")[o2.readonly ? "addClass" : "removeClass"]("disabled");
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-readonly":
            this.toggleReadonly();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const sendButton = element2.find(".js-chat-send-button");
        const input = element2.find("input[type=text]");
        sendButton.off(Metro2.events.click);
        input.off(Metro2.events.keyup);
        return element2;
      }
    });
    Metro2.defaults.Chat = ChatDefaultConfig;
  })(Metro, Dom);

  // source/components/checkbox/checkbox.js
  ((Metro2, $5) => {
    "use strict";
    globalThis.CHECKBOX_STATE = {
      CHECKED: 1,
      UNCHECKED: -1,
      INDETERMINATE: 0
    };
    let CheckboxDefaultConfig = {
      checkboxDeferred: 0,
      state: CHECKBOX_STATE.UNCHECKED,
      threeState: false,
      prepend: "",
      append: "",
      caption: "",
      clsCheckbox: "",
      clsCaption: "",
      clsPrepend: "",
      clsAppend: "",
      onCheckboxCreate: Metro2.noop
    };
    Metro2.metroCheckboxSetup = (options) => {
      CheckboxDefaultConfig = $5.extend({}, CheckboxDefaultConfig, options);
    };
    if (typeof globalThis.metroCheckboxSetup !== "undefined") {
      Metro2.metroCheckboxSetup(globalThis.metroCheckboxSetup);
    }
    Metro2.Component("checkbox", {
      init: function(options, elem) {
        this._super(elem, options, CheckboxDefaultConfig, {
          origin: {
            className: ""
          },
          state: CHECKBOX_STATE.UNCHECKED
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        if (o2.threeState === false && o2.state === 0 || o2.state === "indeterminate") {
          o2.state = CHECKBOX_STATE.UNCHECKED;
        }
        if (o2.state === CHECKBOX_STATE.UNCHECKED || o2.state === "unchecked") {
          this.state = CHECKBOX_STATE.UNCHECKED;
        } else if (o2.state === 0 || o2.state === "indeterminate") {
          this.state = CHECKBOX_STATE.INDETERMINATE;
        } else {
          this.state = CHECKBOX_STATE.CHECKED;
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("checkbox-create");
      },
      _indeterminate: function(v4 = true) {
        const element2 = this.element;
        element2[0].indeterminate = v4;
        element2.attr("data-indeterminate", v4);
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.wrap("<label>").addClass("checkbox").addClass(o2.clsCheckbox);
        element2.attr("type", "checkbox");
        if (o2.prepend) {
          container.prepend($5("<span>").addClass("caption-prepend").addClass(o2.clsPrepend).addClass(o2.clsCaption).html(o2.prepend));
        }
        if (o2.append) {
          container.append($5("<span>").addClass("caption-append").addClass(o2.clsAppend).addClass(o2.clsCaption).html(o2.append));
        }
        if (element2.attr("readonly") !== void 0) {
          element2.on("click", (e2) => {
            e2.preventDefault();
          });
        }
        if (this.elem.checked && this.state !== CHECKBOX_STATE.INDETERMINATE) {
          this.state = true;
        }
        this._drawState();
      },
      _drawState: function() {
        const elem = this.elem;
        this._indeterminate(false);
        elem.checked = this.state !== CHECKBOX_STATE.UNCHECKED;
        if (this.state === CHECKBOX_STATE.INDETERMINATE) {
          this._indeterminate(true);
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.on("click", () => {
          this.state++;
          if (this.state === 0 && o2.threeState === false) {
            this.state = 1;
          }
          if (this.state === 2) {
            this.state = -1;
          }
          this._drawState();
        });
      },
      check: function() {
        this.setCheckState(CHECKBOX_STATE.CHECKED);
      },
      uncheck: function() {
        this.setCheckState(CHECKBOX_STATE.UNCHECKED);
      },
      indeterminate: function() {
        this.setCheckState(CHECKBOX_STATE.INDETERMINATE);
      },
      setCheckState: function(state2) {
        if (state2 === -1 || state2 === "unchecked") {
          this.state = CHECKBOX_STATE.UNCHECKED;
        } else if (state2 === 0 || state2 === "indeterminate") {
          this.state = CHECKBOX_STATE.INDETERMINATE;
        } else {
          this.state = CHECKBOX_STATE.CHECKED;
        }
        this._drawState();
        return this;
      },
      getCheckState: function(asString = false) {
        if (!asString) {
          return this.state;
        }
        switch (this.state) {
          case -1:
            return "unchecked";
          case 0:
            return "indeterminate";
          case 1:
            return "checked";
        }
      },
      toggle: function() {
        this.state++;
        if (this.state === 2) {
          this.state = -1;
        }
        this._drawState();
      },
      changeAttribute: (attr, newVal) => {
        const changeState = function(val) {
          this.toggle(val);
        };
        switch (attr) {
          case "data-state":
            changeState(newVal);
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off("click");
        element2.parent().remove();
      }
    });
  })(Metro, Dom);

  // source/components/clock/clock.js
  ((Metro2, $5) => {
    "use strict";
    let ClockDefaultConfig = {
      clockDeferred: 0,
      show: "row",
      showTime: true,
      showDate: true,
      dateFormat: "DD.MM.YYYY",
      timeFormat: "HH:mm",
      divider: "&nbsp;&nbsp;",
      twoLines: false,
      onTick: Metro2.noop,
      onSecond: Metro2.noop,
      onClockCreate: Metro2.noop
    };
    Metro2.clockSetup = (options) => {
      ClockDefaultConfig = $5.extend({}, ClockDefaultConfig, options);
    };
    if (typeof globalThis.metroClockSetup !== "undefined") {
      Metro2.clockSetup(globalThis.metroClockSetup);
    }
    Metro2.Component("clock", {
      init: function(options, elem) {
        this._super(elem, options, ClockDefaultConfig, {
          _clockInterval: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("clock");
        if (o2.show === "column") {
          element2.addClass("show-column");
        }
        this._fireEvent("clock-create", {
          element: element2
        });
        this._tick();
        this._clockInterval = setInterval(() => {
          this._tick();
        }, 500);
        this._secondInterval = setInterval(() => {
          this._second();
        }, 1e3);
      },
      _second: function() {
        const timestamp = /* @__PURE__ */ new Date();
        this._fireEvent("second", {
          timestamp
        });
      },
      _tick: function() {
        const element2 = this.element;
        const o2 = this.options;
        const timestamp = datetime();
        let result = "";
        const date = timestamp.format(o2.dateFormat);
        const time = timestamp.format(o2.timeFormat);
        if (o2.showTime) {
          result = `<span class="clock-time">${time}</span>`;
        }
        if (o2.showDate) {
          result += `<span class="clock-date">${date}</span>`;
        }
        element2.html(result);
        this._fireEvent("tick", {
          timestamp
        });
      },
      changeAttribute: function(attr, val) {
        switch (attr) {
          case "data-date-format":
            this.options.dateFormat = val;
            break;
          case "data-time-format":
            this.options.timeFormat = val;
            break;
          case "data-show-date":
            this.options.showDate = JSON.parse(val);
            break;
          case "data-show-time":
            this.options.showTime = JSON.parse(val);
            break;
          case "data-divider":
            this.options.divider = val;
            break;
          case "data-two-lines":
            this.options.twoLines = JSON.parse(val);
            break;
        }
        this._tick();
      },
      destroy: function() {
        clearInterval(this._clockInterval);
        this._clockInterval = null;
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/collapse/collapse.js
  (function(Metro2, $5) {
    "use strict";
    var CollapseDefaultConfig = {
      collapseDeferred: 0,
      collapsed: false,
      toggleElement: false,
      duration: 100,
      onExpand: Metro2.noop,
      onCollapse: Metro2.noop,
      onCollapseCreate: Metro2.noop
    };
    Metro2.collapseSetup = function(options) {
      CollapseDefaultConfig = $5.extend({}, CollapseDefaultConfig, options);
    };
    if (typeof globalThis["metroCollapseSetup"] !== "undefined") {
      Metro2.collapseSetup(globalThis["metroCollapseSetup"]);
    }
    Metro2.Component("collapse", {
      init: function(options, elem) {
        this._super(elem, options, CollapseDefaultConfig, {
          toggle: null
        });
        return this;
      },
      _create: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var toggle;
        toggle = o2.toggleElement !== false ? $5(o2.toggleElement) : element2.siblings(".collapse-toggle").length > 0 ? element2.siblings(".collapse-toggle") : element2.siblings("a:nth-child(1)");
        if (o2.collapsed === true || element2.attr("collapsed") === true) {
          element2.hide(0);
        }
        toggle.on(Metro2.events.click, function(e2) {
          if (element2.css("display") !== "none" && !element2.hasClass("keep-open")) {
            that._close(element2);
          } else {
            that._open(element2);
          }
          if (["INPUT"].indexOf(e2.target.tagName) === -1) {
            e2.preventDefault();
          }
          e2.stopPropagation();
        });
        this.toggle = toggle;
        this._fireEvent("collapse-create", {
          element: element2
        });
      },
      _close: function(el, immediate) {
        var elem = $5(el);
        var collapsed = elem.data("collapsed");
        if (collapsed) {
          return;
        }
        var dropdown = Metro2.getPlugin(elem[0], "collapse");
        var options = dropdown.options;
        var func = immediate ? "show" : "slideUp";
        var dur = immediate ? 0 : options.duration;
        this.toggle.removeClass("active-toggle");
        elem[func](dur, function() {
          el.trigger("onCollapse", null, el);
          el.data("collapsed", true);
          el.addClass("collapsed");
          dropdown._fireEvent("collapse");
        });
      },
      _open: function(el, immediate) {
        var elem = $5(el);
        var collapsed = elem.data("collapsed");
        if (!collapsed) {
          return;
        }
        var dropdown = Metro2.getPlugin(elem[0], "collapse");
        var options = dropdown.options;
        var func = immediate ? "show" : "slideDown";
        var dur = immediate ? 0 : options.duration;
        this.toggle.addClass("active-toggle");
        elem[func](dur, function() {
          el.trigger("onExpand", null, el);
          el.data("collapsed", false);
          el.removeClass("collapsed");
          dropdown._fireEvent("expand");
        });
      },
      collapse: function(immediate) {
        this._close(this.element, immediate);
      },
      expand: function(immediate) {
        this._open(this.element, immediate);
      },
      close: function(immediate) {
        this._close(this.element, immediate);
      },
      open: function(immediate) {
        this._open(this.element, immediate);
      },
      isCollapsed: function() {
        return this.element.data("collapsed");
      },
      toggleState: function() {
        var element2 = this.element;
        if (element2.attr("collapsed") === true || element2.data("collapsed") === true) {
          this.collapse();
        } else {
          this.expand();
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "collapsed":
          case "data-collapsed":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        this.toggle.off(Metro2.events.click);
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/radio/radio.js
  (function(Metro2, $5) {
    "use strict";
    let RadioDefaultConfig = {
      radioDeferred: 0,
      prepend: "",
      append: "",
      caption: "",
      clsRadio: "",
      clsCaption: "",
      clsPrepend: "",
      clsAppend: "",
      onRadioCreate: Metro2.noop
    };
    Metro2.metroRadioSetup = function(options) {
      RadioDefaultConfig = $5.extend({}, RadioDefaultConfig, options);
    };
    if (typeof globalThis["metroRadioSetup"] !== "undefined") {
      Metro2.metroRadioSetup(globalThis["metroRadioSetup"]);
    }
    Metro2.Component("radio", {
      init: function(options, elem) {
        this._super(elem, options, RadioDefaultConfig, {
          origin: {
            className: ""
          }
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("radio-create");
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        const container = element2.wrap("<label>").addClass("radio").addClass(o2.clsCheckbox);
        element2.attr("type", "radio");
        if (o2.prepend) {
          container.prepend($5("<span>").addClass("caption-prepend").addClass(o2.clsPrepend).addClass(o2.clsCaption).html(o2.prepend));
        }
        if (o2.append) {
          container.append($5("<span>").addClass("caption-append").addClass(o2.clsAppend).addClass(o2.clsCaption).html(o2.append));
        }
        if (element2.attr("readonly")) {
          element2.on("click", function(e2) {
            e2.preventDefault();
          });
        }
        if (this.elem.checked) {
          this.state = true;
        }
        this._drawState();
      },
      _drawState: function() {
      },
      _createEvents: function() {
        const element2 = this.element, o2 = this.options;
        const that = this;
        element2.on("click", function() {
          that._drawState();
        });
      },
      check: function() {
        this.setCheckState(CHECKBOX_STATE.CHECKED);
      },
      uncheck: function() {
        this.setCheckState(CHECKBOX_STATE.UNCHECKED);
      },
      setCheckState: function(state2 = true) {
        this.elem.checked = state2;
        this._drawState();
        return this;
      },
      getCheckState: function(asString = false) {
        const state2 = this.elem.checked;
        if (!asString) {
          return state2;
        }
        switch (this.state) {
          case false:
            return "unchecked";
          case true:
            return "checked";
        }
      },
      toggle: function() {
        this.elem.checked = !this.elem.checked;
        this._drawState();
      },
      changeAttribute: function(attr, newVal) {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off("click");
        element2.parent().remove();
      }
    });
  })(Metro, Dom);

  // source/components/color-selector/color-selector.js
  (function(Metro2, $5) {
    "use strict";
    const supportedColorTypes = "hex, rgb, rgba, hsl, hsla, hsv, cmyk";
    let ColorSelectorDefaultConfig = {
      defaultSwatches: "#FFFFFF,#000000,#FFFB0D,#0532FF,#FF9300,#00F91A,#FF2700,#686868,#EE5464,#D27AEE,#5BA8C4,#E64AA9,#1ba1e2,#6a00ff,#bebebe,#f8f8f8",
      userColors: null,
      returnValueType: "hex",
      returnAsString: true,
      showValues: supportedColorTypes,
      showAsString: null,
      showUserColors: true,
      controller: null,
      addUserColorTitle: null,
      userColorsTitle: null,
      hslMode: "percent",
      showAlphaChannel: true,
      inputThreshold: 300,
      initColor: null,
      readonlyInput: false,
      clsSelector: "",
      clsSwatches: "",
      clsSwatch: "",
      clsValue: "",
      clsLabel: "",
      clsInput: "",
      clsUserColorButton: "",
      clsUserColors: "",
      clsUserColorsTitle: "",
      clsUserColor: "",
      onSelectColor: Metro2.noop,
      onColorSelectorCreate: Metro2.noop
    };
    Metro2.colorSelectorSetup = function(options) {
      ColorSelectorDefaultConfig = $5.extend({}, ColorSelectorDefaultConfig, options);
    };
    if (typeof globalThis["metroColorSelectorSetup"] !== "undefined") {
      Metro2.colorSelectorSetup(globalThis["metroColorSelectorSetup"]);
    }
    Metro2.Component("color-selector", {
      init: function(options, elem) {
        this._super(elem, options, ColorSelectorDefaultConfig, {
          // define instance vars here
          id: Metro2.utils.elementId("color-selector"),
          defaultSwatches: [],
          showValues: [],
          userColors: [],
          showAsString: [],
          hue: 0,
          saturation: 0,
          lightness: 1,
          alpha: 1,
          hsl: null,
          hsla: null,
          hsv: null,
          rgb: null,
          rgba: null,
          cmyk: null,
          hex: null,
          inputInterval: null,
          controller: null
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        if (Metro2.utils.isValue(o2.defaultSwatches))
          this.defaultSwatches = o2.defaultSwatches.toArray(",").map(function(el) {
            return el.toUpperCase();
          });
        if (Metro2.utils.isValue(o2.showValues)) this.showValues = o2.showValues.toArray(",");
        if (Metro2.utils.isValue(o2.userColors))
          this.userColors = o2.userColors.toArray(",").map(function(el) {
            return el.toUpperCase();
          });
        if (Metro2.utils.isValue(o2.showAsString)) this.showAsString = o2.showAsString.toArray(",");
        this._createStructure();
        this._createEvents();
        this._setColorValues();
        this._fireEvent("color-selector-create");
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options, strings = this.strings;
        let colorBox, row, swatches, map, value, inputs, radios, userColorsActions, hueCanvas, shadeCanvas, hueCursor, shadeCursor, colorBlock, alphaCanvas, alphaCursor;
        element2.addClass("color-selector").addClass(o2.clsSelector);
        element2.append(colorBox = $5("<div>").addClass("color-box"));
        colorBox.append(row = $5("<div>").addClass("row"));
        row.append(swatches = $5("<div>").addClass("default-swatches").addClass(o2.clsSwatches));
        $5.each(this.defaultSwatches, function() {
          swatches.append(
            $5("<button>").attr("data-color", this).attr("type", "button").addClass("swatch").addClass(o2.clsSwatch).css("background-color", this)
          );
        });
        colorBox.append(row = $5("<div>").addClass("row"));
        row.append(map = $5("<div>").addClass("color-map"));
        map.append(shadeCursor = $5("<button>").attr("type", "button").addClass("cursor color-cursor dragging"));
        map.append(shadeCanvas = $5("<canvas>").addClass("color-canvas"));
        row.append(map = $5("<div>").addClass("hue-map"));
        map.append(hueCursor = $5("<button>").attr("type", "button").addClass("cursor hue-cursor dragging"));
        map.append(hueCanvas = $5("<canvas>").addClass("hue-canvas"));
        row.append(map = $5("<div>").addClass("alpha-map"));
        map.append(alphaCursor = $5("<button>").attr("type", "button").addClass("cursor alpha-cursor dragging"));
        map.append(alphaCanvas = $5("<canvas>").addClass("alpha-canvas"));
        colorBox.append(row = $5("<div>").addClass("row color-values-block"));
        row.append(value = $5("<div>").addClass("color-value-hex"));
        value.append($5("<input type='radio' name='returnType' value='hex' checked>").addClass("check-color-value-hex"));
        value.append(colorBlock = $5("<div>").addClass("color-block as-string color-hex"));
        colorBlock.append($5("<input type='text' data-prepend='HEX:'>").addClass("input-small value-hex"));
        row.append(value = $5("<div>").addClass("color-value-rgb"));
        value.append($5("<input type='radio' name='returnType' value='rgb'>").addClass("check-color-value-rgb"));
        value.append(colorBlock = $5("<div>").addClass("color-block color-rgb"));
        colorBlock.append($5("<input type='text' data-prepend='R:'>").addClass("input-small value-r"));
        colorBlock.append($5("<input type='text' data-prepend='G:'>").addClass("input-small value-g"));
        colorBlock.append($5("<input type='text' data-prepend='B:'>").addClass("input-small value-b"));
        value.append(colorBlock = $5("<div>").addClass("color-block as-string color-rgb"));
        colorBlock.append($5("<input type='text' data-prepend='RGB:'>").addClass("input-small value-rgb"));
        if (this.showAsString.indexOf("rgb") > -1) {
          value.find(".value-r,.value-g,.value-b").parent().hide();
        } else {
          value.find(".value-rgb").parent().hide();
        }
        row.append(value = $5("<div>").addClass("color-value-rgba"));
        value.append($5("<input type='radio' name='returnType' value='rgba'>").addClass("check-color-value-rgba"));
        value.append(colorBlock = $5("<div>").addClass("color-block color-rgba"));
        colorBlock.append($5("<input type='text' data-prepend='R:'>").addClass("input-small value-r"));
        colorBlock.append($5("<input type='text' data-prepend='G:'>").addClass("input-small value-g"));
        colorBlock.append($5("<input type='text' data-prepend='B:'>").addClass("input-small value-b"));
        colorBlock.append($5("<input type='text' data-prepend='A:'>").addClass("input-small value-a"));
        value.append(colorBlock = $5("<div>").addClass("color-block as-string color-rgba"));
        colorBlock.append($5("<input type='text' data-prepend='RGBA:'>").addClass("input-small value-rgba"));
        if (this.showAsString.indexOf("rgba") > -1) {
          value.find(".value-r,.value-g,.value-b,.value-a").parent().hide();
        } else {
          value.find(".value-rgba").parent().hide();
        }
        row.append(value = $5("<div>").addClass("color-value-hsl"));
        value.append($5("<input type='radio' name='returnType' value='hsl'>").addClass("check-color-value-hsl"));
        value.append(colorBlock = $5("<div>").addClass("color-block color-hsl"));
        colorBlock.append($5("<input type='text' data-prepend='H:'>").addClass("input-small value-h"));
        colorBlock.append($5("<input type='text' data-prepend='S:'>").addClass("input-small value-s"));
        colorBlock.append($5("<input type='text' data-prepend='L:'>").addClass("input-small value-l"));
        value.append(colorBlock = $5("<div>").addClass("color-block as-string color-hsl"));
        colorBlock.append($5("<input type='text' data-prepend='HSL:'>").addClass("input-small value-hsl"));
        if (this.showAsString.indexOf("hsl") > -1) {
          value.find(".value-h,.value-s,.value-l").parent().hide();
        } else {
          value.find(".value-hsl").parent().hide();
        }
        row.append(value = $5("<div>").addClass("color-value-hsla"));
        value.append($5("<input type='radio' name='returnType' value='hsla'>").addClass("check-color-value-hsla"));
        value.append(colorBlock = $5("<div>").addClass("color-block color-hsla"));
        colorBlock.append($5("<input type='text' data-prepend='H:'>").addClass("input-small value-h"));
        colorBlock.append($5("<input type='text' data-prepend='S:'>").addClass("input-small value-s"));
        colorBlock.append($5("<input type='text' data-prepend='L:'>").addClass("input-small value-l"));
        colorBlock.append($5("<input type='text' data-prepend='A:'>").addClass("input-small value-a"));
        value.append(colorBlock = $5("<div>").addClass("color-block as-string color-hsla"));
        colorBlock.append($5("<input type='text' data-prepend='HSLA:'>").addClass("input-small value-hsla"));
        if (this.showAsString.indexOf("hsla") > -1) {
          value.find(".value-h,.value-s,.value-l,.value-a").parent().hide();
        } else {
          value.find(".value-hsla").parent().hide();
        }
        row.append(value = $5("<div>").addClass("color-value-hsv"));
        value.append($5("<input type='radio' name='returnType' value='hsv'>").addClass("check-color-value-hsl"));
        value.append(colorBlock = $5("<div>").addClass("color-block color-hsv"));
        colorBlock.append($5("<input type='text' data-prepend='H:'>").addClass("input-small value-h"));
        colorBlock.append($5("<input type='text' data-prepend='S:'>").addClass("input-small value-s"));
        colorBlock.append($5("<input type='text' data-prepend='V:'>").addClass("input-small value-v"));
        value.append(colorBlock = $5("<div>").addClass("color-block as-string color-hsv"));
        colorBlock.append($5("<input type='text' data-prepend='HSV:'>").addClass("input-small value-hsv"));
        if (this.showAsString.indexOf("hsv") > -1) {
          value.find(".value-h,.value-s,.value-v").parent().hide();
        } else {
          value.find(".value-hsv").parent().hide();
        }
        row.append(value = $5("<div>").addClass("color-value-cmyk"));
        value.append($5("<input type='radio' name='returnType' value='cmyk'>").addClass("check-color-value-cmyk"));
        value.append(colorBlock = $5("<div>").addClass("color-block color-cmyk"));
        colorBlock.append($5("<input type='text' data-prepend='C:'>").addClass("input-small value-c"));
        colorBlock.append($5("<input type='text' data-prepend='M:'>").addClass("input-small value-m"));
        colorBlock.append($5("<input type='text' data-prepend='Y:'>").addClass("input-small value-y"));
        colorBlock.append($5("<input type='text' data-prepend='K:'>").addClass("input-small value-k"));
        value.append(colorBlock = $5("<div>").addClass("color-block as-string color-cmyk"));
        colorBlock.append($5("<input type='text' data-prepend='CMYK:'>").addClass("input-small value-cmyk"));
        if (this.showAsString.indexOf("cmyk") > -1) {
          value.find(".value-s,.value-m,.value-y,.value-k").parent().hide();
        } else {
          value.find(".value-cmyk").parent().hide();
        }
        colorBox.append(row = $5("<div>").addClass("row user-colors-css-container"));
        row.append(
          $5("<div>").addClass("user-colors-title").addClass(o2.clsUserColorsTitle).html(o2.userColorsTitle || strings["label_user_colors"])
        );
        row.append($5("<div>").addClass("user-colors").addClass(o2.clsUserColors));
        row.append(userColorsActions = $5("<div>").addClass("user-colors-actions"));
        userColorsActions.append(
          $5("<button>").addClass("button add-button").addClass(o2.clsUserColorButton).html("<span class='user-swatch'></span><span>" + (o2.addUserColorTitle || strings["label_add_user_color"]) + "</span>")
        );
        inputs = colorBox.find("input[type=text]");
        Metro2.makePlugin(inputs, "input", {
          clearButton: false,
          clsPrepend: o2.clsLabel,
          clsComponent: o2.clsInput
        });
        inputs.addClass(o2.clsValue);
        if (o2.readonlyInput) {
          inputs.attr("readonly", true);
        }
        radios = colorBox.find("input[type=radio]").each(function() {
          $5(this).attr("name", that.id + "-returnType");
        });
        radios.each(function() {
          if ($5(this).val() === o2.returnValueType) {
            this.checked = true;
          }
        });
        Metro2.makePlugin(radios, "radio");
        $5.each(supportedColorTypes.toArray(","), function() {
          if (that.showValues.indexOf(this) === -1) element2.find(".color-value-" + this).hide();
        });
        if (!o2.showUserColors) {
          element2.find(".user-colors-css-container").hide();
        }
        if (!o2.showAlphaChannel) {
          element2.addClass("no-alpha-channel");
          $5.each(["rgba", "hsla"], function() {
            element2.find(".color-value-" + this).hide();
          });
        }
        this._fillUserColors();
        this.hueCanvas = hueCanvas;
        this.hueCursor = hueCursor;
        this.shadeCanvas = shadeCanvas;
        this.shadeCursor = shadeCursor;
        this.alphaCanvas = alphaCanvas;
        this.alphaCursor = alphaCursor;
        this._createShadeCanvas();
        this._createHueCanvas();
        this._createAlphaCanvas();
        this._setColorValues();
        this._updateCursorsColor();
        if (o2.initColor && Farbe.Routines.isColor(o2.initColor)) {
          this._colorToPos(typeof o2.initColor === "string" ? Farbe.Routines.parse(o2.initColor) : o2.initColor);
        }
        this.controller = o2.controller ? $5(o2.controller) : null;
      },
      _createShadeCanvas: function(color) {
        const canvas = this.shadeCanvas[0];
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!color) color = "#f00";
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const whiteGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        whiteGradient.addColorStop(0, "#fff");
        whiteGradient.addColorStop(1, "transparent");
        ctx.fillStyle = whiteGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const blackGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        blackGradient.addColorStop(0, "transparent");
        blackGradient.addColorStop(1, "#000");
        ctx.fillStyle = blackGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      },
      _createHueCanvas: function() {
        const canvas = this.hueCanvas[0];
        const ctx = canvas.getContext("2d");
        const hueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        hueGradient.addColorStop(0, "hsl(0,100%,50%)");
        hueGradient.addColorStop(0.17, "hsl(298.8, 100%, 50%)");
        hueGradient.addColorStop(0.33, "hsl(241.2, 100%, 50%)");
        hueGradient.addColorStop(0.5, "hsl(180, 100%, 50%)");
        hueGradient.addColorStop(0.67, "hsl(118.8, 100%, 50%)");
        hueGradient.addColorStop(0.83, "hsl(61.2,100%,50%)");
        hueGradient.addColorStop(1, "hsl(360,100%,50%)");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = hueGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      },
      _createAlphaCanvas: function() {
        const canvas = this.alphaCanvas[0];
        const ctx = canvas.getContext("2d");
        const alphaGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        const startColor = new Farbe.Primitives.HSLA(this.hue, 1, 0.5, 1).toString(), endColor = "rgba(0,0,0,0)";
        alphaGradient.addColorStop(0, startColor);
        alphaGradient.addColorStop(1, endColor);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = alphaGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      },
      _updateHueCursor: function(y3) {
        this.hueCursor.css({
          top: y3
        });
      },
      _updateAlphaCursor: function(y3) {
        this.alphaCursor.css({
          top: y3
        });
      },
      _getHueColor: function(pageY) {
        const canvas = this.hueCanvas;
        const offset = canvas.offset();
        const height = canvas.height();
        let y3, percent, color, hue;
        y3 = pageY - offset.top;
        if (y3 > height) y3 = height;
        if (y3 < 0) y3 = 0;
        percent = y3 / height;
        hue = 360 - 360 * percent;
        if (hue === 360) hue = 0;
        color = "hsl(" + hue + ", 100%, 50%)";
        this.hue = hue;
        this._createShadeCanvas(color);
        this._createAlphaCanvas();
        this._updateHueCursor(y3);
        this._updateCursorsColor();
        this._setColorValues();
      },
      _getAlphaValue: function(pageY) {
        const canvas = this.alphaCanvas;
        const offset = canvas.offset();
        const height = canvas.height();
        let y3, percent;
        y3 = pageY - offset.top;
        if (y3 > height) y3 = height;
        if (y3 < 0) y3 = 0;
        percent = 1 - y3 / height;
        this.alpha = percent.toFixed(2);
        this._updateAlphaCursor(y3);
        this._updateCursorsColor();
        this._setColorValues();
      },
      _getShadeColor: function(pageX, pageY) {
        const canvas = this.shadeCanvas;
        const offset = canvas.offset();
        const width = canvas.width();
        const height = canvas.height();
        let x4 = pageX - offset.left;
        let y3 = pageY - offset.top;
        if (x4 > width) x4 = width;
        if (x4 < 0) x4 = 0;
        if (y3 > height) y3 = height;
        if (y3 < 0) y3 = 0.1;
        const xRatio = x4 / width * 100;
        const yRatio = y3 / height * 100;
        const hsvValue = 1 - yRatio / 100;
        const hsvSaturation = xRatio / 100;
        let lightness = hsvValue / 2 * (2 - hsvSaturation);
        let saturation = hsvValue * hsvSaturation / (1 - Math.abs(2 * lightness - 1));
        if (isNaN(lightness)) {
          lightness = 0;
        }
        if (isNaN(saturation)) {
          saturation = 0;
        }
        this.lightness = lightness;
        this.saturation = saturation;
        this._updateShadeCursor(x4, y3);
        this._updateCursorsColor();
        this._setColorValues();
      },
      _updateCursorsColor: function() {
        this.shadeCursor.css({
          backgroundColor: Farbe.Routines.toHEX(new Farbe.Primitives.HSL(this.hue, this.saturation, this.lightness))
        });
        this.hueCursor.css({
          backgroundColor: Farbe.Routines.toHEX(new Farbe.Primitives.HSL(this.hue, 1, 0.5))
        });
        this.alphaCursor.css({
          backgroundColor: Farbe.Routines.toRGBA(new Farbe.Primitives.HSL(this.hue, 1, 0.5), this.alpha).toString()
        });
      },
      _updateShadeCursor: function(x4, y3) {
        this.shadeCursor.css({
          top: y3,
          left: x4
        });
      },
      _colorToPos: function(color) {
        const shadeCanvasRect = this.shadeCanvas[0].getBoundingClientRect();
        const hueCanvasRect = this.hueCanvas[0].getBoundingClientRect();
        const alphaCanvasRect = this.alphaCanvas[0].getBoundingClientRect();
        const hsl = Farbe.Routines.toHSL(color);
        const hsla = Farbe.Routines.toHSLA(color);
        const hsv = Farbe.Routines.toHSV(color);
        const x4 = shadeCanvasRect.width * hsv.s;
        const y3 = shadeCanvasRect.height * (1 - hsv.v);
        const hueY = hueCanvasRect.height - hsl.h / 360 * hueCanvasRect.height;
        const alphaY = (1 - hsla.a) * alphaCanvasRect.height;
        this.hue = hsl.h;
        this.saturation = hsl.s;
        this.lightness = hsl.l;
        this.alpha = hsla.a;
        this._updateHueCursor(hueY);
        this._updateShadeCursor(x4, y3);
        this._updateAlphaCursor(alphaY);
        this._updateCursorsColor();
        this._createShadeCanvas("hsl(" + this.hue + ", 100%, 50%)");
        this._createAlphaCanvas();
        this._setColorValues();
      },
      _setColorValues: function() {
        const element2 = this.element, o2 = this.options;
        const hsl = new Farbe.Primitives.HSL(this.hue, this.saturation, this.lightness);
        const hsla = new Farbe.Primitives.HSLA(this.hue, this.saturation, this.lightness, this.alpha);
        const rgb = Farbe.Routines.toRGB(hsl);
        const rgba = Farbe.Routines.toRGBA(rgb, this.alpha);
        const hsv = Farbe.Routines.toHSV(hsl);
        const cmyk = Farbe.Routines.toCMYK(hsl);
        const hex = Farbe.Routines.toHEX(hsl);
        const controller = this.controller;
        const percent = o2.hslMode === "percent";
        this.hsl = hsl;
        this.hsla = hsla;
        this.hsv = hsv;
        this.rgb = rgb;
        this.rgba = rgba;
        this.hex = hex;
        this.cmyk = cmyk;
        element2.find(".color-value-hex .value-hex input").val(hex);
        element2.find(".color-value-rgb .value-r input").val(rgb.r);
        element2.find(".color-value-rgb .value-g input").val(rgb.g);
        element2.find(".color-value-rgb .value-b input").val(rgb.b);
        element2.find(".color-value-rgb .value-rgb input").val(rgb.toString());
        element2.find(".color-value-rgba .value-r input").val(rgba.r);
        element2.find(".color-value-rgba .value-g input").val(rgba.g);
        element2.find(".color-value-rgba .value-b input").val(rgba.b);
        element2.find(".color-value-rgba .value-a input").val(rgba.a);
        element2.find(".color-value-rgba .value-rgba input").val(rgba.toString());
        element2.find(".color-value-hsl .value-h input").val(hsl.h.toFixed(0));
        element2.find(".color-value-hsl .value-s input").val(percent ? Math.round(hsl.s * 100) + "%" : hsl.s.toFixed(4));
        element2.find(".color-value-hsl .value-l input").val(percent ? Math.round(hsl.l * 100) + "%" : hsl.l.toFixed(4));
        element2.find(".color-value-hsl .value-hsl input").val(hsl.toString());
        element2.find(".color-value-hsla .value-h input").val(hsla.h.toFixed(0));
        element2.find(".color-value-hsla .value-s input").val(percent ? Math.round(hsla.s * 100) + "%" : hsl.s.toFixed(4));
        element2.find(".color-value-hsla .value-l input").val(percent ? Math.round(hsla.l * 100) + "%" : hsl.l.toFixed(4));
        element2.find(".color-value-hsla .value-a input").val(hsla.a);
        element2.find(".color-value-hsla .value-hsla input").val(hsla.toString());
        element2.find(".color-value-hsv .value-h input").val(hsv.h.toFixed(0));
        element2.find(".color-value-hsv .value-s input").val(percent ? Math.round(hsv.s * 100) + "%" : hsv.s.toFixed(4));
        element2.find(".color-value-hsv .value-v input").val(percent ? Math.round(hsv.v * 100) + "%" : hsv.v.toFixed(4));
        element2.find(".color-value-hsv .value-hsv input").val(hsv.toString());
        element2.find(".color-value-cmyk .value-c input").val(cmyk.c.toFixed(0));
        element2.find(".color-value-cmyk .value-m input").val(cmyk.m.toFixed(0));
        element2.find(".color-value-cmyk .value-y input").val(cmyk.y.toFixed(0));
        element2.find(".color-value-cmyk .value-k input").val(cmyk.k.toFixed(0));
        element2.find(".color-value-cmyk .value-cmyk input").val(cmyk.toString());
        element2.find(".user-colors-actions .user-swatch").css({
          backgroundColor: hex
        });
        const value = this.getVal();
        if (controller && controller.length) {
          controller.val(value);
        }
        this._fireEvent("select-color", {
          color: value,
          primitive: {
            hsl: this.hsl,
            hsla: this.hsla,
            rgb: this.rgb,
            rgba: this.rgba,
            hsv: this.hsv,
            cmyk: this.cmyk,
            hex: this.hex
          }
        });
      },
      _clearInputInterval: function() {
        clearInterval(this.inputInterval);
        this.inputInterval = false;
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const hueMap = element2.find(".hue-map");
        const alphaMap = element2.find(".alpha-map");
        const shadeMap = element2.find(".color-map");
        const controller = this.controller;
        const colorValues = element2.find(".color-values-block input[type=text]");
        let onColorValuesChange = (e2) => {
          const input = $5(e2.target);
          const colorGroup = input.closest(".color-block");
          let colorType2, color, parts;
          if (colorGroup.hasClass("color-hex")) {
            colorType2 = "hex";
          } else if (colorGroup.hasClass("color-rgb")) {
            colorType2 = "rgb";
          } else if (colorGroup.hasClass("color-rgba")) {
            colorType2 = "rgba";
          } else if (colorGroup.hasClass("color-hsl")) {
            colorType2 = "hsl";
          } else if (colorGroup.hasClass("color-hsla")) {
            colorType2 = "hsla";
          } else if (colorGroup.hasClass("color-hsv")) {
            colorType2 = "hsv";
          } else if (colorGroup.hasClass("color-cmyk")) {
            colorType2 = "cmyk";
          }
          if (colorGroup.hasClass("as-string")) {
            color = input.val();
          } else {
            parts = [];
            $5.each(colorGroup.find("input"), function() {
              parts.push(this.value);
            });
            color = colorType2 + "(" + parts.join(", ") + ")";
          }
          if (color && Farbe.Routines.isColor(color)) {
            that.val(color);
          }
        };
        onColorValuesChange = Hooks.useDebounce(onColorValuesChange, o2.inputThreshold);
        colorValues.on(Metro2.events.inputchange, onColorValuesChange);
        if (controller && controller.length) {
          let onControllerChange = Hooks.useDebounce(() => {
            const val = controller.val();
            if (val && Farbe.Routines.isColor(val)) {
              that.val(val);
            }
          }, o2.inputThreshold);
          controller.on(Metro2.events.inputchange, onControllerChange);
        }
        alphaMap.on(
          Metro2.events.startAll,
          function(e2) {
            if (["hsla", "rgba"].includes(o2.returnValueType) === false) {
            }
            that._getAlphaValue(Metro2.utils.pageXY(e2).y);
            $5(document).on(
              Metro2.events.moveAll,
              function(e3) {
                e3.preventDefault();
                that._getAlphaValue(Metro2.utils.pageXY(e3).y);
              },
              { ns: that.id }
            );
            $5(document).on(
              Metro2.events.stopAll,
              function() {
                $5(document).off(Metro2.events.moveAll, {
                  ns: that.id
                });
                $5(document).off(Metro2.events.stopAll, {
                  ns: that.id
                });
              },
              { ns: that.id }
            );
          },
          { passive: true }
        );
        hueMap.on(
          Metro2.events.startAll,
          function(e2) {
            that._getHueColor(Metro2.utils.pageXY(e2).y);
            $5(document).on(
              Metro2.events.moveAll,
              function(e3) {
                e3.preventDefault();
                that._getHueColor(Metro2.utils.pageXY(e3).y);
              },
              { ns: that.id, passive: false }
            );
            $5(document).on(
              Metro2.events.stopAll,
              function() {
                $5(document).off(Metro2.events.moveAll, {
                  ns: that.id
                });
                $5(document).off(Metro2.events.stopAll, {
                  ns: that.id
                });
              },
              { ns: that.id }
            );
          },
          { passive: true }
        );
        shadeMap.on(
          Metro2.events.startAll,
          function(e2) {
            that._getShadeColor(Metro2.utils.pageXY(e2).x, Metro2.utils.pageXY(e2).y);
            $5(document).on(
              Metro2.events.moveAll,
              function(e3) {
                e3.preventDefault();
                that._getShadeColor(Metro2.utils.pageXY(e3).x, Metro2.utils.pageXY(e3).y);
              },
              { ns: that.id, passive: false }
            );
            $5(document).on(
              Metro2.events.stopAll,
              function() {
                $5(document).off(Metro2.events.moveAll, {
                  ns: that.id
                });
                $5(document).off(Metro2.events.stopAll, {
                  ns: that.id
                });
              },
              { ns: that.id }
            );
          },
          { passive: true }
        );
        element2.on("click", ".swatch", function() {
          that._colorToPos($5(this).attr("data-color"));
        });
        element2.on("click", ".add-button", function() {
          const color = Farbe.Routines.toHEX(new Farbe.Primitives.HSL(that.hue, that.saturation, that.lightness)).toUpperCase();
          if (that.userColors.includes(color)) {
            return;
          }
          that.userColors.push(color);
          element2.find(".user-colors").append(
            $5("<button>").attr("data-color", color).attr("type", "button").addClass("swatch user-swatch").css({
              backgroundColor: color
            })
          );
        });
        element2.find("input[type=radio]").on("click", function() {
          o2.returnValueType = $5(this).val();
          that._setColorValues();
        });
      },
      getVal: function() {
        const o2 = this.options;
        let res;
        switch (o2.returnValueType.toLowerCase()) {
          case "rgb":
            res = this.rgb;
            break;
          case "rgba":
            res = this.rgba;
            break;
          case "hsl":
            res = this.hsl;
            break;
          case "hsla":
            res = this.hsla;
            break;
          case "hsv":
            res = this.hsv;
            break;
          case "cmyk":
            res = this.cmyk;
            break;
          default:
            res = this.hex;
        }
        return o2.returnAsString ? res.toString() : res;
      },
      val: function(v4) {
        if (typeof v4 === "undefined") {
          return this.getVal();
        }
        const color = Farbe.Routines.parse(v4);
        this._colorToPos(color);
      },
      user: function(v4) {
        if (!Metro2.utils.isValue(v4)) {
          return this.userColors;
        }
        if (!Array.isArray(v4) && typeof v4 !== "string") {
          return;
        }
        if (typeof v4 === "string") {
          this.userColors = v4.toArray(",").map(function(el) {
            return el.toUpperCase();
          });
        } else {
          this.userColors = v4.map(function(el) {
            return el.toUpperCase();
          });
        }
        this._fillUserColors();
      },
      _fillUserColors: function() {
        const colors = this.element.find(".user-colors-css").clear();
        $5.each(this.userColors, function() {
          const color = this;
          colors.append(
            $5("<button>").attr("data-color", color).attr("type", "button").addClass("swatch user-swatch").css({
              backgroundColor: color
            })
          );
        });
      },
      changeAttribute: function(attr, newValue) {
        const o2 = this.options;
        if (attr === "data-return-value-type") {
          o2.returnValueType = newValue;
        }
        if (attr === "data-return-as-string") {
          o2.returnValueType = Metro2.utils.bool(newValue);
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
    Metro2.defaults.ColorSelector = ColorSelectorDefaultConfig;
  })(Metro, Dom);

  // source/components/color-picker/color-picker.js
  (function(Metro2, $5) {
    "use strict";
    let ColorPickerDefaultConfig = {
      defaultSwatches: "#FFFFFF,#000000,#FFFB0D,#0532FF,#FF9300,#00F91A,#FF2700,#686868,#EE5464,#D27AEE,#5BA8C4,#E64AA9,#1ba1e2,#6a00ff,#bebebe,#f8f8f8",
      duration: 100,
      prepend: "",
      append: "",
      label: "",
      clearButton: false,
      clearButtonIcon: "\u274C",
      pickerButtonIcon: "\u{1F3A8}",
      defaultValue: "rgba(0, 0, 0, 0)",
      openMode: "auto",
      resultType: "hex",
      inputThreshold: 500,
      onColorSelected: Metro2.noop,
      onColorPickerCreate: Metro2.noop
    };
    Metro2.colorPickerSetup = function(options) {
      ColorPickerDefaultConfig = $5.extend({}, ColorPickerDefaultConfig, options);
    };
    if (typeof globalThis["metroColorPickerSetup"] !== "undefined") {
      Metro2.colorPickerSetup(globalThis["metroColorPickerSetup"]);
    }
    Metro2.Component("color-picker", {
      init: function(options, elem) {
        this._super(
          elem,
          options,
          $5.extend(
            {},
            Metro2.defaults.ColorSelector,
            {
              showUserColors: false,
              showValues: ""
            },
            ColorPickerDefaultConfig
          ),
          {
            value: null,
            picker: null,
            colorSelector: null,
            colorSelectorBox: null,
            colorExample: null,
            inputInterval: null,
            isOpen: false
          }
        );
        return this;
      },
      _create: function() {
        const element2 = this.element, o2 = this.options;
        const current = element2.val();
        if (!Metro2.pluginExists("color-selector")) {
          throw new Error("Color selector component required!");
        }
        this.value = Farbe.Routines.isColor(current) ? current : Farbe.Routines.isColor(o2.defaultValue) ? o2.defaultValue : "rgba(0,0,0,0)";
        this._createStructure();
        this._createEvents();
        this._fireEvent("color-picker-create");
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const picker = element2.wrap($5("<div>").addClass("color-picker").addClass(element2[0].className));
        let buttons, colorExample, colorSelector, colorSelectorBox;
        colorExample = $5("<div>").addClass("color-example-box").insertBefore(element2);
        buttons = $5("<div>").addClass("buttons").appendTo(picker);
        buttons.append(
          $5("<button>").addClass("button color-picker-button").attr("tabindex", -1).attr("type", "button").html(o2.pickerButtonIcon)
        );
        if (o2.clearButton === true && !element2[0].readOnly) {
          buttons.append(
            $5("<button>").addClass("button input-clear-button").addClass(o2.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon)
          );
        }
        if (Metro2.utils.isValue(o2.prepend)) {
          picker.prepend($5("<div>").addClass("prepend").addClass(o2.clsPrepend).html(o2.prepend));
        }
        if (Metro2.utils.isValue(o2.append)) {
          picker.append($5("<div>").html(o2.append).addClass("append").addClass(o2.clsAppend));
        }
        colorSelectorBox = $5("<div>").addClass("color-selector-box").appendTo(picker);
        colorSelector = $5("<div>").appendTo(colorSelectorBox);
        this.picker = picker;
        this.colorExample = colorExample;
        this.colorSelector = colorSelector;
        this.colorSelectorBox = colorSelectorBox;
        Metro2.makePlugin(colorSelector, "color-selector", {
          defaultSwatches: o2.defaultSwatches,
          returnValueType: o2.resultType,
          returnAsString: true,
          showUserColors: false,
          showValues: "",
          controller: element2,
          showAlphaChannel: true,
          inputThreshold: o2.inputThreshold,
          initColor: this.value,
          readonlyInput: o2.readonlyInput,
          onSelectColor: (color) => {
            this.colorExample.css({
              backgroundColor: color
            });
          },
          onColorSelectorCreate: o2.onColorSelectorCreate
        });
        Metro2.makePlugin(colorSelectorBox, "dropdown", {
          dropFilter: ".color-picker",
          duration: o2.duration,
          toggleElement: [picker],
          checkDropUp: true,
          onDrop: function() {
            Metro2.getPlugin(colorSelector, "color-selector").val(that.value);
          }
        });
        element2[0].className = "";
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(picker);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        this._setColor();
      },
      _clearInputInterval: function() {
        clearInterval(this.inputInterval);
        this.inputInterval = false;
      },
      _setColor: function() {
        const colorExample = this.colorExample;
        let color = this.value;
        if (this.value.indexOf("cmyk") !== -1 || this.value.indexOf("hsv") !== -1) {
          color = Farbe.Routines.toHEX(this.value);
        }
        console.log(color);
        colorExample.css({
          backgroundColor: color
        });
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const picker = this.picker, colorSelector = this.colorSelector, colorSelectorBox = this.colorSelector;
        picker.on(Metro2.events.click, ".input-clear-button", function(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          element2.val(o2.defaultValue).trigger("change");
          Metro2.getPlugin(colorSelector, "color-selector").val(o2.defaultValue);
        });
        element2.on(Metro2.events.inputchange, function() {
          that.value = this.value;
          that._setColor();
        });
        colorSelectorBox.on(Metro2.events.click, function(e2) {
          e2.stopPropagation();
        });
      },
      val: function(v4) {
        if (arguments.length === 0 || !Metro2.utils.isValue(v4)) {
          return this.value;
        }
        if (!Farbe.Routines.isColor(v4)) {
          return;
        }
        this.value = v4;
        this.element.val(v4).trigger("change");
        this._setColor();
      },
      // changeAttribute: function(attr, newValue){
      // },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        const parent2 = element2.parent();
        if (o2.label) {
          parent2.prev("label").remove();
        }
        parent2.remove();
      }
    });
    $5(document).on(Metro2.events.click, function() {
      $5(".color-picker").removeClass("open");
    });
  })(Metro, Dom);

  // source/components/context-menu/context-menu.js
  (function(Metro2, $5) {
    Metro2["contextMenu"] = function(items = [], element2 = document) {
      function buildMenu(items2) {
        const menu = $5("<ul>").addClass("d-menu context-menu").css("display", "none");
        for (const item of items2) {
          if (item.type === "divider") {
            menu.append($5("<li>").addClass("divider"));
          } else {
            const li = $5("<li>").appendTo(menu);
            const an = $5("<a>").appendTo(li);
            if (item.icon) {
              an.append($5("<span>").addClass("icon").html(item.icon));
            }
            an.append($5("<span>").addClass("caption").html(item.text));
            an.href(item.href || "#");
            if (item.onclick) {
              an.on("click", (e2) => {
                Metro2.utils.exec(item.onclick, [e2, item]);
              });
            }
            if (item.attributes) {
              for (const [key, value] of Object.entries(item.attributes)) {
                an.attr(key, value);
              }
            }
            if (item.disabled) {
              an.prop("disabled", true);
            }
            if (item.items) {
              const sub = buildMenu(item.items);
              li.children("a").addClass("dropdown-toggle");
              li.append(sub);
              Metro2.makePlugin(sub, "dropdown", {});
            }
          }
        }
        return menu[0];
      }
      element2.context_menu = buildMenu(items);
      if (element2.nodeType === 1) {
        element2.append(element2.context_menu);
      } else {
        $5("body").append(element2.context_menu);
      }
      element2.oncontextmenu = function(e2) {
        e2.preventDefault();
        e2.stopPropagation();
        $5(".context-menu").hide();
        this.context_menu.style.left = e2.pageX + "px";
        this.context_menu.style.top = e2.pageY + "px";
        this.context_menu.style.display = "block";
      };
    };
    $5(document).on("click", function(e2) {
      $5(".context-menu").hide();
    });
  })(Metro, Dom);

  // source/components/cookie/cookie.js
  (function(Metro2, $5) {
    "use strict";
    var CookieDefaultConfig = {
      path: "/",
      expires: null,
      maxAge: null,
      domain: null,
      secure: false,
      samesite: null
    };
    Metro2.cookieSetup = function(options) {
      CookieDefaultConfig = $5.extend({}, CookieDefaultConfig, options);
    };
    if (typeof globalThis["metroCookieSetup"] !== "undefined") {
      Metro2.cookieSetup(globalThis["metroCookieSetup"]);
    }
    Metro2.cookie = {
      getCookies: function() {
        var a3 = document.cookie.toArray(";");
        var o2 = {};
        $5.each(a3, function() {
          var i3 = this.split("=");
          o2[i3[0]] = i3[1];
        });
        return o2;
      },
      getCookie: function(name2) {
        var cookieName = encodeURIComponent(name2) + "=";
        var cookies = document.cookie.toArray(";");
        var i3, cookie;
        for (i3 = 0; i3 < cookies.length; i3++) {
          cookie = cookies[i3];
          while (cookie.charAt(0) === " ") {
            cookie = cookie.substring(1, cookie.length);
          }
          if (cookie.indexOf(cookieName) === 0) {
            return decodeURIComponent(cookie.substring(cookieName.length, cookie.length));
          }
        }
        return null;
      },
      setCookie: function(name2, value, options) {
        var date;
        var cookieName = encodeURIComponent(name2);
        var cookieValue = encodeURIComponent(value);
        var opt2, a3 = [];
        if (options && typeof options !== "object") {
          date = /* @__PURE__ */ new Date();
          date.setTime(date.getTime() + parseInt(options));
          opt2 = $5.extend({}, CookieDefaultConfig, {
            expires: date.toUTCString()
          });
        } else {
          opt2 = $5.extend({}, CookieDefaultConfig, options);
        }
        $5.each(opt2, function(key, val) {
          if (key !== "secure" && val) {
            a3.push(Str.dashedName(key) + "=" + val);
          }
          if (key === "secure" && val === true) {
            a3.push("secure");
          }
        });
        document.cookie = cookieName + "=" + cookieValue + "; " + a3.join("; ");
      },
      delCookie: function(name2) {
        this.setCookie(name2, false, {
          maxAge: -1
        });
      }
    };
  })(Metro, Dom);

  // source/components/cookie-disclaimer/cookie-disclaimer.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var cookieDisclaimerDefaults = {
      name: "cookies_accepted",
      templateUrl: null,
      title: "",
      message: "",
      duration: "30days",
      clsContainer: "",
      clsMessage: "",
      clsButtons: "",
      clsAcceptButton: "",
      clsCancelButton: "",
      onAccept: Metro2.noop,
      onDecline: Metro2.noop
    };
    Metro2.cookieDisclaimer = {
      init: function(options) {
        var that = this, cookie = Metro2.cookie;
        this.options = $5.extend({}, cookieDisclaimerDefaults, options);
        this.disclaimer = $5("<div>");
        if (cookie.getCookie(this.options.name)) {
          return;
        }
        this.locale = $5("html").attr("lang") || "en";
        this.strings = $5.extend({}, Metro2.locales["en"], Metro2.locales[this.locale]);
        if (this.options.templateUrl) {
          fetch(this.options.templateUrl).then(Metro2.fetch.text).then(function(data) {
            that.create(data);
          });
        } else {
          this.create();
        }
      },
      create: function(html) {
        var cookie = Metro2.cookie;
        var o2 = this.options, wrapper = this.disclaimer, buttons;
        wrapper.addClass("cookie-disclaimer").addClass(o2.clsContainer);
        if (!html) {
          wrapper.html(
            $5("<div class='disclaimer-message'>").addClass(o2.clsMessage).html(`
                                <div class="disclaimer-title">${o2.title || this.strings.label_cookies_title}</div>
                                <div class="disclaimer-text">${o2.message || this.strings.label_cookies_text}</div>
                            `)
          );
        } else {
          wrapper.append(html);
        }
        buttons = $5("<div>").addClass("disclaimer-actions").addClass(o2.clsButtons).append($5("<button>").addClass("button cookie-accept-button").addClass(o2.clsAcceptButton).html(this.strings.label_accept)).append($5("<button>").addClass("button cookie-cancel-button").addClass(o2.clsCancelButton).html(this.strings.label_cancel));
        buttons.appendTo(wrapper);
        if (o2.customButtons) {
          $5.each(o2.customButtons, function() {
            var btn = $5("<button>").addClass("button cookie-custom-button").addClass(this.cls).html(this.text);
            btn.on("click", () => {
              Utils.exec(this.onclick);
            });
            btn.appendTo(buttons);
          });
        }
        wrapper.appendTo($5("body"));
        wrapper.on(Metro2.events.click, ".cookie-accept-button", function() {
          var dur = 0;
          var durations = ("" + o2.duration).toArray(" ");
          $5.each(durations, function() {
            var d3 = "" + this;
            if (d3.includes("day")) {
              dur += parseInt(d3) * 24 * 60 * 60 * 1e3;
            } else if (d3.includes("hour")) {
              dur += parseInt(d3) * 60 * 60 * 1e3;
            } else if (d3.includes("min")) {
              dur += parseInt(d3) * 60 * 1e3;
            } else if (d3.includes("sec")) {
              dur += parseInt(d3) * 1e3;
            } else {
              dur += parseInt(d3);
            }
          });
          cookie.setCookie(o2.name, true, dur);
          Utils.exec(o2.onAccept);
          wrapper.remove();
        });
        wrapper.on(Metro2.events.click, ".cookie-cancel-button", function() {
          Utils.exec(o2.onDecline);
          wrapper.remove();
        });
      }
    };
  })(Metro, Dom);

  // source/components/countdown/countdown.js
  (function(Metro2, $5) {
    "use strict";
    let CountdownDefaultConfig = {
      countdownDeferred: 0,
      stopOnBlur: true,
      animate: "none",
      ease: "linear",
      duration: 600,
      inputFormat: null,
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0,
      date: null,
      start: true,
      fontSize: 24,
      clsCountdown: "",
      clsPart: "",
      clsZero: "",
      clsAlarm: "",
      clsDays: "",
      clsHours: "",
      clsMinutes: "",
      clsSeconds: "",
      onAlarm: Metro2.noop,
      onTick: Metro2.noop,
      onZero: Metro2.noop,
      onBlink: Metro2.noop,
      onCountdownCreate: Metro2.noop
    };
    Metro2.countdownSetup = function(options) {
      CountdownDefaultConfig = $5.extend({}, CountdownDefaultConfig, options);
    };
    if (typeof globalThis["metroCountdownSetup"] !== "undefined") {
      Metro2.countdownSetup(globalThis["metroCountdownSetup"]);
    }
    Metro2.Component("countdown", {
      init: function(options, elem) {
        this._super(elem, options, CountdownDefaultConfig, {
          breakpoint: (/* @__PURE__ */ new Date()).getTime(),
          blinkInterval: null,
          tickInterval: null,
          zeroDaysFired: false,
          zeroHoursFired: false,
          zeroMinutesFired: false,
          zeroSecondsFired: false,
          fontSize: 0,
          current: {
            d: 0,
            h: 0,
            m: 0,
            s: 0
          },
          inactiveTab: false,
          id: Metro2.utils.elementId("countdown"),
          duration: 600
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        this.duration = +o2.duration <= 0 || +o2.duration >= 1e3 ? 1e3 : +o2.duration;
        this._build();
        this._createEvents();
      },
      _setBreakpoint: function() {
        const o2 = this.options;
        const dm = 864e5, hm = 36e5, mm = 6e4, sm = 1e3;
        this.breakpoint = datetime().time();
        if (o2.date) {
          this.breakpoint = (o2.inputFormat ? Datetime.from(o2.date, o2.inputFormat) : datetime(o2.date)).time();
        }
        if (parseInt(o2.days) > 0) {
          this.breakpoint += parseInt(o2.days) * dm;
        }
        if (parseInt(o2.hours) > 0) {
          this.breakpoint += parseInt(o2.hours) * hm;
        }
        if (parseInt(o2.minutes) > 0) {
          this.breakpoint += parseInt(o2.minutes) * mm;
        }
        if (parseInt(o2.seconds) > 0) {
          this.breakpoint += parseInt(o2.seconds) * sm;
        }
      },
      _build: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const parts = ["days", "hours", "minutes", "seconds"];
        const dm = 24 * 60 * 60 * 1e3;
        let delta_days;
        const now = datetime().time();
        let digit;
        const strings = this.strings;
        if (!element2.attr("id")) {
          element2.attr("id", Metro2.utils.elementId("countdown"));
        }
        element2.addClass("countdown").addClass(`animate-${o2.animate}`).addClass(o2.clsCountdown);
        element2.css("font-size", o2.fontSize);
        this._setBreakpoint();
        delta_days = Math.round((that.breakpoint - now) / dm);
        $5.each(parts, function() {
          const part = $5("<div>").addClass("part " + this).addClass(o2.clsPart).attr("data-label", strings[`label_${this}`]).appendTo(element2);
          if (this === "days") {
            part.addClass(o2.clsDays);
          }
          if (this === "hours") {
            part.addClass(o2.clsHours);
          }
          if (this === "minutes") {
            part.addClass(o2.clsMinutes);
          }
          if (this === "seconds") {
            part.addClass(o2.clsSeconds);
          }
          $5("<div>").addClass("digit").appendTo(part);
          $5("<div>").addClass("digit").appendTo(part);
          if (this === "days" && delta_days >= 100) {
            for (let i3 = 0; i3 < String(Math.round(delta_days / 100)).length; i3++) {
              $5("<div>").addClass("digit").appendTo(part);
            }
          }
        });
        digit = element2.find(".digit");
        digit.append($5("<span class='digit-placeholder'>").html("0"));
        digit.append($5("<span class='digit-value'>").html("0"));
        this._fireEvent("countdown-create", {
          element: element2
        });
        if (o2.start === true) {
          this.start();
        } else {
          this.tick();
        }
        this.fontSize = parseInt(element2.css("font-size"));
      },
      _createEvents: function() {
        const that = this;
        $5(document).on(
          "visibilitychange",
          function() {
            if (document.hidden) {
              that.pause();
            } else {
              that.resume();
            }
          },
          { ns: this.id }
        );
      },
      blink: function() {
        const element2 = this.element;
        element2.toggleClass("blink");
        this._fireEvent("blink", {
          time: this.current
        });
      },
      tick: function() {
        const element2 = this.element, o2 = this.options;
        const dm = 24 * 60 * 60, hm = 60 * 60, mm = 60, sm = 1;
        let left, now = datetime().time();
        let d3, h3, m4, s3;
        const days = element2.find(".days"), hours = element2.find(".hours"), minutes = element2.find(".minutes"), seconds = element2.find(".seconds");
        left = Math.floor((this.breakpoint - now) / 1e3);
        if (left <= -1) {
          this.stop();
          element2.addClass(o2.clsAlarm);
          this._fireEvent("alarm", {
            time: now
          });
          return;
        }
        d3 = Math.floor(left / dm);
        left -= d3 * dm;
        if (this.current.d !== d3) {
          this.current.d = d3;
          this.draw("days", d3);
        }
        if (d3 === 0) {
          if (this.zeroDaysFired === false) {
            this.zeroDaysFired = true;
            days.addClass(o2.clsZero);
            this._fireEvent("zero", {
              part: "days",
              value: days
            });
          }
        }
        h3 = Math.floor(left / hm);
        left -= h3 * hm;
        if (this.current.h !== h3) {
          this.current.h = h3;
          this.draw("hours", h3);
        }
        if (d3 === 0 && h3 === 0) {
          if (this.zeroHoursFired === false) {
            this.zeroHoursFired = true;
            hours.addClass(o2.clsZero);
            this._fireEvent("zero", {
              part: "hours",
              value: hours
            });
          }
        }
        m4 = Math.floor(left / mm);
        left -= m4 * mm;
        if (this.current.m !== m4) {
          this.current.m = m4;
          this.draw("minutes", m4);
        }
        if (d3 === 0 && h3 === 0 && m4 === 0) {
          if (this.zeroMinutesFired === false) {
            this.zeroMinutesFired = true;
            minutes.addClass(o2.clsZero);
            this._fireEvent("zero", {
              part: "minutes",
              value: minutes
            });
          }
        }
        s3 = Math.floor(left / sm);
        if (this.current.s !== s3) {
          this.current.s = s3;
          this.draw("seconds", s3);
        }
        if (d3 === 0 && h3 === 0 && m4 === 0 && s3 === 0) {
          if (this.zeroSecondsFired === false) {
            this.zeroSecondsFired = true;
            seconds.addClass(o2.clsZero);
            this._fireEvent("zero", {
              part: "seconds",
              value: seconds
            });
          }
        }
        this._fireEvent("tick", {
          days: d3,
          hours: h3,
          minutes: m4,
          seconds: s3
        });
      },
      draw: function(part, value) {
        const element2 = this.element, o2 = this.options;
        let digits, digits_length, digit_value, digit_current, digit;
        let len, i3, duration = this.duration;
        const fontSize = this.fontSize;
        const slideDigit = function(digit2, value2) {
          let digit_copy, height = digit2.height();
          digit2.siblings(".-old-digit").remove();
          digit_copy = digit2.clone().appendTo(digit2.parent());
          digit_copy.css({
            top: -1 * height + "px"
          });
          digit2.addClass("-old-digit").animate({
            draw: {
              top: height,
              opacity: 0
            },
            dur: duration,
            ease: o2.ease,
            onDone: function() {
              $5(this).remove();
            }
          });
          digit_copy.html(value2).animate({
            draw: {
              top: 0,
              opacity: [0, 1]
            },
            dur: duration,
            ease: o2.ease
          });
        };
        const fadeDigit = function(digit2, value2) {
          let digit_copy;
          digit2.siblings(".-old-digit").remove();
          digit_copy = digit2.clone().appendTo(digit2.parent());
          digit_copy.css({
            opacity: 0
          });
          digit2.addClass("-old-digit").animate({
            draw: {
              opacity: 0
            },
            dur: duration / 2,
            ease: o2.ease,
            onDone: function() {
              $5(this).remove();
            }
          });
          digit_copy.html(value2).animate({
            draw: {
              opacity: 1
            },
            dur: duration / 2,
            ease: o2.ease
          });
        };
        const zoomDigit = function(digit2, value2) {
          let digit_copy, height = element2.height(), fs = fontSize;
          digit2.siblings(".-old-digit").remove();
          digit_copy = digit2.clone().appendTo(digit2.parent());
          digit_copy.css({
            top: 0,
            left: 0,
            opacity: 1
          });
          digit2.addClass("-old-digit").animate({
            draw: {
              top: height,
              opacity: 0,
              fontSize: 0
            },
            dur: duration,
            ease: o2.ease,
            onDone: function() {
              $5(this).remove();
            }
          });
          digit_copy.html(value2).animate({
            draw: {
              top: 0,
              opacity: 1,
              fontSize: [0, fs]
            },
            dur: duration,
            ease: o2.ease
          });
        };
        value = "" + value;
        if (value.length === 1) {
          value = "0" + value;
        }
        len = value.length;
        digits = element2.find("." + part + " .digit:not(.-old-digit)");
        digits_length = digits.length;
        element2.find(".-old-digit").remove();
        for (i3 = 0; i3 < len; i3++) {
          digit = digits.eq(digits_length - 1).find(".digit-value");
          digit_value = Math.floor(parseInt(value) / Math.pow(10, i3)) % 10;
          digit_current = parseInt(digit.text());
          digits_length--;
          if (digit_current === digit_value) {
            continue;
          }
          switch (("" + o2.animate).toLowerCase()) {
            case "slide":
              slideDigit(digit, digit_value);
              break;
            case "fade":
              fadeDigit(digit, digit_value);
              break;
            case "zoom":
              zoomDigit(digit, digit_value);
              break;
            default:
              digit.html(digit_value);
          }
        }
      },
      start: function() {
        const that = this, element2 = this.element;
        if (element2.data("paused") === false) {
          return;
        }
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        element2.data("paused", false);
        this._setBreakpoint();
        this.tick();
        this.blinkInterval = setInterval(function() {
          that.blink();
        }, 500);
        this.tickInterval = setInterval(function() {
          that.tick();
        }, 1e3);
      },
      stop: function() {
        const element2 = this.element;
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        element2.data("paused", true);
        element2.find(".digit").html("0");
        this.current = {
          d: 0,
          h: 0,
          m: 0,
          s: 0
        };
      },
      pause: function() {
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        this.element.data("paused", true);
      },
      resume: function() {
        const that = this;
        this.element.data("paused", false);
        this.blinkInterval = setInterval(function() {
          that.blink();
        }, 500);
        this.tickInterval = setInterval(function() {
          that.tick();
        }, 1e3);
      },
      reset: function() {
        const that = this, element2 = this.element, o2 = this.options;
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        element2.find(".part").removeClass(o2.clsZero);
        const digit = element2.find(".digit").clear();
        digit.append($5("<span class='digit-placeholder'>").html("0"));
        digit.append($5("<span class='digit-value'>").html("0"));
        this._setBreakpoint();
        element2.data("paused", false);
        this.tick();
        this.blinkInterval = setInterval(function() {
          that.blink();
        }, 500);
        this.tickInterval = setInterval(function() {
          that.tick();
        }, 1e3);
      },
      resetWith: function(val) {
        const that = this, element2 = this.element, o2 = this.options;
        if (typeof val === "string") {
          element2.attr("data-date", val);
          o2.date = val;
        } else if (typeof val === "object") {
          const keys = ["days", "hours", "minutes", "seconds"];
          $5.each(keys, function(i3, v4) {
            if (Metro2.utils.isValue(val[v4])) {
              element2.attr("data-" + v4, val[v4]);
              o2[v4] = val[v4];
            }
          });
        }
        this.reset();
      },
      togglePlay: function() {
        if (this.element.attr("data-pause") === true) {
          this.pause();
        } else {
          this.start();
        }
      },
      isPaused: function() {
        return this.element.data("paused");
      },
      getBreakpoint: function(asDate) {
        return asDate === true ? new Date(this.breakpoint) : this.breakpoint;
      },
      getLeft: function() {
        const dm = 24 * 60 * 60 * 1e3, hm = 60 * 60 * 1e3, mm = 60 * 1e3, sm = 1e3;
        const now = (/* @__PURE__ */ new Date()).getTime();
        const left_seconds = Math.floor(this.breakpoint - now);
        return {
          days: Math.round(left_seconds / dm),
          hours: Math.round(left_seconds / hm),
          minutes: Math.round(left_seconds / mm),
          seconds: Math.round(left_seconds / sm)
        };
      },
      changeAttribute: function(attr, newVal) {
        switch (attr) {
          case "data-pause":
            this.togglePlay();
            break;
          case "data-duration":
            this.duration = +newVal <= 0 || +newVal >= 1e3 ? 600 : +newVal;
            break;
        }
      },
      destroy: function() {
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        $5(document).off("visibilitychange", { ns: this.id });
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/counter/counter.js
  (function(Metro2, $5) {
    "use strict";
    let CounterDefaultConfig = {
      startOnViewport: false,
      counterDeferred: 0,
      duration: 2e3,
      value: 0,
      from: 0,
      timeout: 0,
      delimiter: ",",
      prefix: "",
      suffix: "",
      size: 16,
      onStart: Metro2.noop,
      onStop: Metro2.noop,
      onTick: Metro2.noop,
      onCounterCreate: Metro2.noop
    };
    Metro2.counterSetup = function(options) {
      CounterDefaultConfig = $5.extend({}, CounterDefaultConfig, options);
    };
    if (typeof globalThis["metroCounterSetup"] !== "undefined") {
      Metro2.counterSetup(globalThis["metroCounterSetup"]);
    }
    Metro2.Component("counter", {
      init: function(options, elem) {
        this._super(elem, options, CounterDefaultConfig, {
          numbers: [],
          html: $5(elem).html(),
          started: false,
          id: Metro2.utils.elementId("counter")
        });
        return this;
      },
      _create: function() {
        this._createStruct();
        this._createEvents();
        this._fireEvent("counter-create");
      },
      _createStruct: function() {
        const element2 = this.element, elem = this.elem, o2 = this.options;
        this.elem.value = 0;
        element2.css("font-size", this.options.size);
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        if (o2.startOnViewport) {
          Hooks.useEvent({
            effect: () => {
              that.start();
            },
            target: that.elem,
            event: Hooks.EVENTS.VIEWPORT
          });
        }
      },
      start: function(val, from) {
        const that = this, elem = this.elem, o2 = this.options;
        if (Metro2.utils.isValue(from)) {
          o2.from = +from;
        }
        if (Metro2.utils.isValue(val)) {
          o2.value = +val;
        }
        this.started = true;
        const _from = o2.from;
        const _to = o2.value;
        this._fireEvent("start");
        $5.animate({
          el: elem,
          draw: {
            value: [_from, _to]
          },
          defer: o2.timeout,
          dur: o2.duration,
          onFrame: function() {
            that._fireEvent("tick", {
              value: this.value
            });
            this.innerHTML = o2.prefix + Number(this.value).format(0, 0, o2.delimiter) + o2.suffix;
          },
          onDone: function() {
            that._fireEvent("stop");
          }
        });
      },
      reset: function() {
        this.started = false;
        this.element.html(this.html);
      },
      changeAttribute: function(attr, val) {
        const o2 = this.options;
        if (attr === "data-value") {
          o2.value = +val;
        }
        if (attr === "data-from") {
          o2.from = +val;
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/cube/cube.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var CubeDefaultConfig = {
      cubeDeferred: 0,
      rules: null,
      color: null,
      flashColor: null,
      flashInterval: 1e3,
      numbers: false,
      offBefore: true,
      attenuation: 0.3,
      stopOnBlur: false,
      cells: 4,
      margin: 8,
      showAxis: false,
      axisStyle: "arrow",
      //line
      cellClick: false,
      autoRestart: 5e3,
      clsCube: "",
      clsCell: "",
      clsSide: "",
      clsSideLeft: "",
      clsSideRight: "",
      clsSideTop: "",
      clsSideLeftCell: "",
      clsSideRightCell: "",
      clsSideTopCell: "",
      clsAxis: "",
      clsAxisX: "",
      clsAxisY: "",
      clsAxisZ: "",
      custom: Metro2.noop,
      onTick: Metro2.noop,
      onCubeCreate: Metro2.noop
    };
    Metro2.cubeSetup = function(options) {
      CubeDefaultConfig = $5.extend({}, CubeDefaultConfig, options);
    };
    if (typeof globalThis["metroCubeSetup"] !== "undefined") {
      Metro2.cubeSetup(globalThis["metroCubeSetup"]);
    }
    Metro2.cubeDefaultRules = [
      {
        on: { "top": [16], "left": [4], "right": [1] },
        off: { "top": [13, 4], "left": [1, 16], "right": [13, 4] }
      },
      {
        on: { "top": [12, 15], "left": [3, 8], "right": [2, 5] },
        off: { "top": [9, 6, 3], "left": [5, 10, 15], "right": [14, 11, 8] }
      },
      {
        on: { "top": [11], "left": [7], "right": [6] },
        off: { "top": [1, 2, 5], "left": [9, 13, 14], "right": [15, 12, 16] }
      },
      {
        on: { "top": [8, 14], "left": [2, 12], "right": [9, 3] },
        off: { "top": [16], "left": [4], "right": [1] }
      },
      {
        on: { "top": [10, 7], "left": [6, 11], "right": [10, 7] },
        off: { "top": [12, 15], "left": [3, 8], "right": [2, 5] }
      },
      {
        on: { "top": [13, 4], "left": [1, 16], "right": [13, 4] },
        off: { "top": [11], "left": [7], "right": [6] }
      },
      {
        on: { "top": [9, 6, 3], "left": [5, 10, 15], "right": [14, 11, 8] },
        off: { "top": [8, 14], "left": [2, 12], "right": [9, 3] }
      },
      {
        on: { "top": [1, 2, 5], "left": [9, 13, 14], "right": [15, 12, 16] },
        off: { "top": [10, 7], "left": [6, 11], "right": [10, 7] }
      }
    ];
    Metro2.Component("cube", {
      init: function(options, elem) {
        this._super(elem, options, CubeDefaultConfig, {
          id: Utils.elementId("cube"),
          rules: null,
          interval: false,
          ruleInterval: false,
          running: false,
          intervals: []
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        if (o2.rules === null) {
          this.rules = Metro2.cubeDefaultRules;
        } else {
          this._parseRules(o2.rules);
        }
        this._createCube();
        this._createEvents();
        this._fireEvent("cube-create", {
          element: element2
        });
      },
      _parseRules: function(rules) {
        if (rules === void 0 || rules === null) {
          return false;
        }
        if (Utils.isObject(rules)) {
          this.rules = Utils.isObject(rules);
          return true;
        } else {
          try {
            this.rules = JSON.parse(rules);
            return true;
          } catch (err) {
            console.warn("Unknown or empty rules for cell flashing!");
            return false;
          }
        }
      },
      _createCube: function() {
        var element2 = this.element, o2 = this.options;
        var sides = ["left", "right", "top"];
        var id = Utils.elementId("cube");
        var cells_count = Math.pow(o2.cells, 2);
        element2.addClass("cube").addClass(o2.clsCube);
        if (!element2.attr("id")) {
          element2.attr("id", id);
        }
        this.id = element2.attr("id");
        this._createCssForFlashColor();
        this._createCssForCellSize();
        $5.each(sides, function() {
          var side, cell, i3;
          side = $5("<div>").addClass("side " + this + "-side").addClass(o2.clsSide).appendTo(element2);
          if (this === "left") {
            side.addClass(o2.clsSideLeft);
          }
          if (this === "right") {
            side.addClass(o2.clsSideRight);
          }
          if (this === "top") {
            side.addClass(o2.clsSideTop);
          }
          for (i3 = 0; i3 < cells_count; i3++) {
            cell = $5("<div>").addClass("cube-cell").addClass("cell-id-" + (i3 + 1)).addClass(o2.clsCell);
            cell.data("id", i3 + 1).data("side", this);
            cell.appendTo(side);
            if (o2.numbers === true) {
              cell.html(i3 + 1);
            }
          }
        });
        var cells = element2.find(".cube-cell");
        if (o2.color !== null) {
          if (Farbe.Routines.isColor(o2.color)) {
            cells.css({
              backgroundColor: o2.color,
              borderColor: o2.color
            });
          } else {
            cells.addClass(o2.color);
          }
        }
        var axis = ["x", "y", "z"];
        $5.each(axis, function() {
          var axis_name = this;
          var ax = $5("<div>").addClass("axis " + o2.axisStyle).addClass("axis-" + axis_name).addClass(o2.clsAxis);
          if (axis_name === "x") ax.addClass(o2.clsAxisX);
          if (axis_name === "y") ax.addClass(o2.clsAxisY);
          if (axis_name === "z") ax.addClass(o2.clsAxisZ);
          ax.appendTo(element2);
        });
        if (o2.showAxis === false) {
          element2.find(".axis").hide();
        }
        this._run();
      },
      _run: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var interval = 0;
        clearInterval(this.interval);
        element2.find(".cube-cell").removeClass("light");
        if (o2.custom !== Metro2.noop) {
          Utils.exec(o2.custom, [element2]);
        } else {
          element2.find(".cube-cell").removeClass("light");
          that._start();
          interval = Utils.isObject(this.rules) ? Utils.objectLength(this.rules) : 0;
          this.interval = setInterval(function() {
            that._start();
          }, interval * o2.flashInterval);
        }
      },
      _createCssForCellSize: function() {
        var element2 = this.element, o2 = this.options;
        var sheet = Metro2.sheet;
        var width;
        var cell_size;
        if (o2.margin === 8 && o2.cells === 4) {
          return;
        }
        width = parseInt(Utils.getStyleOne(element2, "width"));
        cell_size = Math.ceil((width / 2 - o2.margin * o2.cells * 2) / o2.cells);
        Utils.addCssRule(sheet, "#" + element2.attr("id") + " .side .cube-cell", "width: " + cell_size + "px!important; height: " + cell_size + "px!important; margin: " + o2.margin + "px!important;");
      },
      _createCssForFlashColor: function() {
        var element2 = this.element, o2 = this.options;
        var sheet = Metro2.sheet;
        var rule1;
        var rule2;
        var rules1 = [];
        var rules2 = [];
        var i3;
        if (o2.flashColor === null) {
          return;
        }
        rule1 = "0 0 10px " + Farbe.Routines.toRGBA(Farbe.Routines.parse(o2.flashColor), 1);
        rule2 = "0 0 10px " + Farbe.Routines.toRGBA(Farbe.Routines.parse(o2.flashColor), o2.attenuation);
        for (i3 = 0; i3 < 3; i3++) {
          rules1.push(rule1);
          rules2.push(rule2);
        }
        Utils.addCssRule(sheet, "@keyframes pulsar-cell-" + element2.attr("id"), "0%, 100% { box-shadow: " + rules1.join(",") + "} 50% { box-shadow: " + rules2.join(",") + " }");
        Utils.addCssRule(sheet, "#" + element2.attr("id") + " .side .cube-cell.light", "animation: pulsar-cell-" + element2.attr("id") + " 2.5s 0s ease-out infinite; background-color: " + o2.flashColor + "!important; border-color: " + o2.flashColor + "!important;");
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        $5(globalThis).on(Metro2.events.blur, function() {
          if (o2.stopOnBlur === true && that.running === true) {
            that._stop();
          }
        }, { ns: element2.attr("id") });
        $5(globalThis).on(Metro2.events.focus, function() {
          if (o2.stopOnBlur === true && that.running === false) {
            that._start();
          }
        }, { ns: element2.attr("id") });
        element2.on(Metro2.events.click, ".cube-cell", function() {
          if (o2.cellClick === true) {
            var cell = $5(this);
            cell.toggleClass("light");
          }
        });
      },
      _start: function() {
        var that = this, element2 = this.element;
        element2.find(".cube-cell").removeClass("light");
        this.running = true;
        $5.each(this.rules, function(index, rule) {
          that._execRule(index, rule);
        });
      },
      _stop: function() {
        this.running = false;
        clearInterval(this.interval);
        $5.each(this.intervals, function() {
          clearInterval(this);
        });
      },
      _tick: function(index, speed) {
        var that = this, o2 = this.options;
        if (speed === void 0) {
          speed = o2.flashInterval * index;
        }
        var interval = setTimeout(function() {
          that._fireEvent("tick", {
            index
          });
          clearInterval(interval);
          Utils.arrayDelete(that.intervals, interval);
        }, speed);
        this.intervals.push(interval);
      },
      _toggle: function(cell, func, time, speed) {
        var that = this;
        if (speed === void 0) {
          speed = this.options.flashInterval * time;
        }
        var interval = setTimeout(function() {
          cell[func === "on" ? "addClass" : "removeClass"]("light");
          clearInterval(interval);
          Utils.arrayDelete(that.intervals, interval);
        }, speed);
        this.intervals.push(interval);
      },
      start: function() {
        this._start();
      },
      stop: function() {
        this._stop();
      },
      toRule: function(index, speed) {
        var that = this, element2 = this.element, o2 = this.options;
        var rules = this.rules;
        if (rules === null || rules === void 0 || rules[index] === void 0) {
          return;
        }
        clearInterval(this.ruleInterval);
        this.ruleInterval = false;
        this.stop();
        element2.find(".cube-cell").removeClass("light");
        for (var i3 = 0; i3 <= index; i3++) {
          this._execRule(i3, rules[i3], speed);
        }
        if (Utils.isInt(o2.autoRestart) && o2.autoRestart > 0) {
          this.ruleInterval = setTimeout(function() {
            that._run();
          }, o2.autoRestart);
        }
      },
      _execRule: function(index, rule, speed) {
        var that = this, element2 = this.element;
        var sides = ["left", "right", "top"];
        this._tick(index, speed);
        $5.each(sides, function() {
          var side_class = "." + this + "-side";
          var side_name = this;
          var cells_on = rule["on"] && rule["on"][side_name] ? rule["on"][side_name] : false;
          var cells_off = rule["off"] && rule["off"][side_name] ? rule["off"][side_name] : false;
          if (cells_on !== false) $5.each(cells_on, function() {
            var cell_index = this;
            var cell = element2.find(side_class + " .cell-id-" + cell_index);
            that._toggle(cell, "on", index, speed);
          });
          if (cells_off !== false) $5.each(cells_off, function() {
            var cell_index = this;
            var cell = element2.find(side_class + " .cell-id-" + cell_index);
            that._toggle(cell, "off", index, speed);
          });
        });
      },
      rule: function(r2) {
        if (r2 === void 0) {
          return this.rules;
        }
        if (this._parseRules(r2) !== true) {
          return;
        }
        this.options.rules = r2;
        this.stop();
        this.element.find(".cube-cell").removeClass("light");
        this._run();
      },
      axis: function(show) {
        var func = show === true ? "show" : "hide";
        this.element.find(".axis")[func]();
      },
      changeRules: function() {
        var element2 = this.element, o2 = this.options;
        var rules = element2.attr("data-rules");
        if (this._parseRules(rules) !== true) {
          return;
        }
        this.stop();
        element2.find(".cube-cell").removeClass("light");
        o2.rules = rules;
        this._run();
      },
      changeAxisVisibility: function() {
        var element2 = this.element;
        var visibility = JSON.parse(element2.attr("data-show-axis")) === true;
        var func = visibility ? "show" : "hide";
        element2.find(".axis")[func]();
      },
      changeAxisStyle: function() {
        var element2 = this.element;
        var style = element2.attr("data-axis-style");
        element2.find(".axis").removeClass("arrow line no-style").addClass(style);
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-rules":
            this.changeRules();
            break;
          case "data-show-axis":
            this.changeAxisVisibility();
            break;
          case "data-axis-style":
            this.changeAxisStyle();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element;
        clearInterval(this.interval);
        this.interval = null;
        $5(globalThis).off(Metro2.events.blur, { ns: element2.attr("id") });
        $5(globalThis).off(Metro2.events.focus, { ns: element2.attr("id") });
        element2.off(Metro2.events.click, ".cube-cell");
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/custom-checkbox/custom-checkbox.js
  (function(Metro2, $5) {
    "use strict";
    let CustomCheckboxDefaultConfig = {
      customCheckboxDeferred: 0,
      stateOn: "\u2611",
      stateOff: "\u2610",
      captionOn: "",
      captionOff: "",
      captionPosition: "right",
      clsCustomCheckbox: "",
      clsIcon: "",
      clsIconOn: "",
      clsIconOff: "",
      clsCaption: "",
      clsCaptionOn: "",
      clsCaptionOff: "",
      onCustomCheckboxCreate: Metro2.noop
    };
    Metro2.customCheckboxSetup = function(options) {
      CustomCheckboxDefaultConfig = $5.extend({}, CustomCheckboxDefaultConfig, options);
    };
    if (typeof globalThis["metroCustomCheckboxSetup"] !== "undefined") {
      Metro2.customCheckboxSetup(globalThis["metroCustomCheckboxSetup"]);
    }
    Metro2.Component("custom-checkbox", {
      init: function(options, elem) {
        this._super(elem, options, CustomCheckboxDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element, o2 = this.options;
        const container = element2.wrap($5("<label>").addClass("custom-checkbox").addClass(o2.clsCustomCheckbox));
        const icon = $5("<span>").addClass("icon").addClass(o2.clsIcon).appendTo(container);
        element2.attr("type", "checkbox");
        if (element2.attr("readonly")) {
          element2.on("click", function(e2) {
            e2.preventDefault();
          });
        }
        if (o2.stateOn) {
          $5("<span>").addClass("state-on").addClass(o2.clsIconOn).html(o2.stateOn).appendTo(icon);
        }
        if (o2.stateOff) {
          $5("<span>").addClass("state-off").addClass(o2.clsIconOff).html(o2.stateOff).appendTo(icon);
        }
        if (o2.captionOn || o2.captionOff) {
          const caption = $5("<span>").addClass("caption").addClass(o2.clsCaption).appendTo(container);
          if (o2.captionOn) {
            $5("<span>").addClass("caption-state-on").addClass(o2.clsCaptionOn).html(o2.captionOn).appendTo(caption);
          }
          if (o2.captionOff) {
            $5("<span>").addClass("caption-state-off").addClass(o2.clsCaptionOff).html(o2.captionOff).appendTo(caption);
          }
        }
        if (o2.captionPosition === "left") {
          container.addClass("caption-left");
        }
        element2[0].className = "";
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this._fireEvent("customCheckbox-create");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      toggle: function(v4) {
        const element2 = this.element;
        if (!Metro2.utils.isValue(v4)) {
          element2.prop("checked", !Metro2.utils.bool(element2.prop("checked")));
        } else {
          element2.prop("checked", v4 === 1);
        }
        return this;
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/datepicker/datepicker.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var DatePickerDefaultConfig = {
      label: "",
      datepickerDeferred: 0,
      gmt: 0,
      format: "YYYY-MM-DD",
      inputFormat: null,
      value: null,
      distance: 3,
      month: true,
      day: true,
      year: true,
      minYear: null,
      maxYear: null,
      defaultYearDistance: 100,
      scrollSpeed: 4,
      copyInlineStyles: false,
      openMode: "auto",
      clsPicker: "",
      clsPart: "",
      clsMonth: "",
      clsDay: "",
      clsYear: "",
      clsLabel: "",
      clsButton: "",
      clsOkButton: "",
      clsCancelButton: "",
      okButtonIcon: "\u2713",
      cancelButtonIcon: "\u{10102}",
      onSet: Metro2.noop,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onScroll: Metro2.noop,
      onDatePickerCreate: Metro2.noop
    };
    Metro2.datePickerSetup = function(options) {
      DatePickerDefaultConfig = $5.extend({}, DatePickerDefaultConfig, options);
    };
    if (typeof globalThis["metroDatePickerSetup"] !== "undefined") {
      Metro2.datePickerSetup(globalThis["metroDatePickerSetup"]);
    }
    Metro2.Component("date-picker", {
      init: function(options, elem) {
        this._super(elem, options, DatePickerDefaultConfig, {
          picker: null,
          isOpen: false,
          value: datetime(),
          listTimer: {
            day: null,
            month: null,
            year: null
          }
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options, locale = this.locale;
        var date = datetime();
        if (o2.distance < 1) {
          o2.distance = 1;
        }
        if (Utils.isValue(element2.val())) {
          o2.value = element2.val();
        }
        if (Utils.isValue(o2.value)) {
          this.value = o2.inputFormat ? Datetime.from(o2.value, o2.inputFormat, locale) : datetime(o2.value);
        }
        if (o2.minYear === null) {
          o2.minYear = date.year() - o2.defaultYearDistance;
        }
        if (o2.maxYear === null) {
          o2.maxYear = date.year() + o2.defaultYearDistance;
        }
        this._createStructure();
        this._createEvents();
        this._set();
        this._fireEvent("datepicker-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options, locale = this.locale;
        var picker, month, day, year, i3, j4;
        var dateWrapper, selectWrapper, selectBlock, actionBlock;
        var id = Utils.elementId("datepicker");
        picker = $5("<div>").addClass("wheel-picker date-picker " + element2[0].className).addClass(o2.clsPicker);
        if (!picker.attr("id")) {
          picker.attr("id", id);
        }
        picker.insertBefore(element2);
        element2.appendTo(picker);
        if (o2.label) {
          var label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(picker);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        dateWrapper = $5("<div>").addClass("date-wrapper").appendTo(picker);
        if (o2.month === true) {
          month = $5("<div>").addClass("month").addClass(o2.clsPart).addClass(o2.clsMonth).appendTo(dateWrapper);
        }
        if (o2.day === true) {
          day = $5("<div>").addClass("day").addClass(o2.clsPart).addClass(o2.clsDay).appendTo(dateWrapper);
        }
        if (o2.year === true) {
          year = $5("<div>").addClass("year").addClass(o2.clsPart).addClass(o2.clsYear).appendTo(dateWrapper);
        }
        selectWrapper = $5("<div>").addClass("select-wrapper").appendTo(picker);
        selectBlock = $5("<div>").addClass("select-block").appendTo(selectWrapper);
        if (o2.month === true) {
          month = $5("<ul>").addClass("sel-month").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(month);
          for (i3 = 0; i3 < 12; i3++) {
            const month_name = Datetime.getLocale(locale).months[i3];
            $5("<li>").addClass("js-month-" + i3 + " js-month-real-" + month_name.toLowerCase()).html(month_name).data("value", i3).appendTo(month);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(month);
        }
        if (o2.day === true) {
          day = $5("<ul>").addClass("sel-day").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(day);
          for (i3 = 0; i3 < 31; i3++) {
            $5("<li>").addClass("js-day-" + i3 + " js-day-real-" + (i3 + 1)).html(i3 + 1).data("value", i3 + 1).appendTo(day);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(day);
        }
        if (o2.year === true) {
          year = $5("<ul>").addClass("sel-year").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(year);
          for (i3 = o2.minYear, j4 = 0; i3 <= o2.maxYear; i3++, j4++) {
            $5("<li>").addClass("js-year-" + j4 + " js-year-real-" + i3).html(i3).data("value", i3).appendTo(year);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(year);
        }
        selectBlock.height((o2.distance * 2 + 1) * 40);
        actionBlock = $5("<div>").addClass("action-block").appendTo(selectWrapper);
        $5("<button>").attr("type", "button").addClass("button action-today").addClass(o2.clsButton).addClass(o2.clsTodayButton).html(`<span class="caption">${this.strings.label_today}</span>`).appendTo(actionBlock);
        $5("<button>").attr("type", "button").addClass("button action-ok").addClass(o2.clsButton).addClass(o2.clsOkButton).html(`<span class="icon">${o2.okButtonIcon}</span>`).appendTo(actionBlock);
        $5("<button>").attr("type", "button").addClass("button action-cancel").addClass(o2.clsButton).addClass(o2.clsCancelButton).html(`<span class="icon">${o2.cancelButtonIcon}</span>`).appendTo(actionBlock);
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          for (i3 = 0; i3 < element2[0].style.length; i3++) {
            picker.css(element2[0].style[i3], element2.css(element2[0].style[i3]));
          }
        }
        if (element2.prop("disabled")) {
          picker.addClass("disabled");
        }
        this.picker = picker;
      },
      _createEvents: function() {
        var that = this, o2 = this.options;
        var picker = this.picker;
        picker.on("touchstart", ".select-block ul", function(e2) {
          if (e2.changedTouches) {
            return;
          }
          var target = this;
          var pageY = Utils.pageXY(e2).y;
          $5(document).on(
            "touchmove",
            function(e3) {
              target.scrollTop -= o2.scrollSpeed * (pageY > Utils.pageXY(e3).y ? -1 : 1);
              pageY = Utils.pageXY(e3).y;
            },
            { ns: picker.attr("id") }
          );
          $5(document).on(
            "touchend",
            function() {
              $5(document).off(Metro2.events.move, { ns: picker.attr("id") });
              $5(document).off(Metro2.events.stop, { ns: picker.attr("id") });
            },
            { ns: picker.attr("id") }
          );
        });
        picker.on(Metro2.events.click, function(e2) {
          if (that.isOpen === false) that.open();
          e2.stopPropagation();
        });
        picker.on(Metro2.events.click, ".action-ok", function(e2) {
          var m4, d3, y3;
          var sm = picker.find(".sel-month li.active"), sd = picker.find(".sel-day li.active"), sy = picker.find(".sel-year li.active");
          m4 = sm.length === 0 ? that.value.value.getMonth() : sm.data("value");
          d3 = sd.length === 0 ? that.value.value.getDate() : sd.data("value");
          y3 = sy.length === 0 ? that.value.value.getFullYear() : sy.data("value");
          that.value = datetime(y3, m4, d3);
          that._set();
          that.close();
          e2.preventDefault();
          e2.stopPropagation();
        });
        picker.on(Metro2.events.click, ".action-cancel", function(e2) {
          that.close();
          e2.preventDefault();
          e2.stopPropagation();
        });
        var scrollLatency = 150;
        $5.each(["month", "day", "year"], function() {
          var part = this, list = picker.find(".sel-" + part);
          const scrollFn = Hooks.useDebounce(function(e2) {
            var target, targetElement, scrollTop;
            that.listTimer[part] = null;
            target = Math.round(Math.ceil(list.scrollTop()) / 40);
            targetElement = list.find(".js-" + part + "-" + target);
            scrollTop = targetElement.position().top - o2.distance * 40;
            list.find(".active").removeClass("active");
            list[0].scrollTop = scrollTop;
            targetElement.addClass("active");
            Utils.exec(o2.onScroll, [targetElement, list, picker], list[0]);
          }, scrollLatency);
          list.on("scroll", scrollFn);
        });
        picker.on(Metro2.events.click, "ul li", function(e2) {
          const target = $5(this);
          const list = target.closest("ul");
          const scrollTop = target.position().top - o2.distance * 40;
          list.find(".active").removeClass("active");
          $5.animate({
            el: list[0],
            draw: {
              scrollTop
            },
            dur: 300
          });
          list[0].scrollTop = scrollTop;
          target.addClass("active");
          Utils.exec(o2.onScroll, [target, list, picker], list[0]);
        });
        picker.on(Metro2.events.click, ".action-today", function(e2) {
          const now = datetime();
          const month = now.month();
          const day = now.day();
          const year = now.year();
          picker.find(`.sel-month li.js-month-${month}`).click();
          picker.find(`.sel-day li.js-day-real-${day}`).click();
          picker.find(`.sel-year li.js-year-real-${year}`).click();
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _correct: function() {
        var m4 = this.value.month(), d3 = this.value.day(), y3 = this.value.year();
        this.value = datetime(y3, m4, d3);
      },
      _set: function() {
        var element2 = this.element, o2 = this.options;
        var picker = this.picker;
        var m4 = Datetime.getLocale(this.locale).months[this.value.month()], d3 = this.value.day(), y3 = this.value.year();
        if (o2.month === true) {
          picker.find(".month").html(m4);
        }
        if (o2.day === true) {
          picker.find(".day").html(d3);
        }
        if (o2.year === true) {
          picker.find(".year").html(y3);
        }
        element2.val(this.value.format(o2.format, this.locale)).trigger("change");
        this._fireEvent("set", {
          value: this.value.val(),
          elementValue: element2.val(),
          picker
        });
      },
      open: function() {
        var o2 = this.options;
        var picker = this.picker;
        var m4 = this.value.month(), d3 = this.value.day() - 1, y3 = this.value.year();
        var m_list, d_list, y_list;
        var select_wrapper = picker.find(".select-wrapper");
        $5.each($5(".date-picker"), function() {
          $5(this).find("input").each(function() {
            Metro2.getPlugin(this, "datepicker").close();
          });
        });
        select_wrapper.show(0);
        picker.find("li").removeClass("active");
        if (o2.openMode === "auto") {
          if (!Metro2.utils.inViewport(select_wrapper[0])) {
            select_wrapper.parent().addClass("drop-up-select");
          }
          if (!Metro2.utils.inViewport(select_wrapper[0])) {
            select_wrapper.parent().removeClass("drop-up-select");
            select_wrapper.parent().addClass("drop-as-dialog");
          }
        } else {
          if (o2.openMode === "dialog") {
            select_wrapper.parent().addClass("drop-as-dialog");
          } else if (o2.openMode === "up") {
            select_wrapper.parent().addClass("drop-up-select");
          }
        }
        if (o2.month === true) {
          m_list = picker.find(".sel-month");
          m_list.scrollTop(0).animate({
            draw: {
              scrollTop: m_list.find("li.js-month-" + m4).addClass("active").position().top - 40 * o2.distance
            },
            dur: 100
          });
        }
        if (o2.day === true) {
          d_list = picker.find(".sel-day");
          d_list.scrollTop(0).animate({
            draw: {
              scrollTop: d_list.find("li.js-day-" + d3).addClass("active").position().top - 40 * o2.distance
            },
            dur: 100
          });
        }
        if (o2.year === true) {
          y_list = picker.find(".sel-year");
          y_list.scrollTop(0).animate({
            draw: {
              scrollTop: y_list.find("li.js-year-real-" + y3).addClass("active").position().top - 40 * o2.distance
            },
            dur: 100
          });
        }
        this.isOpen = true;
        this._fireEvent("open", {
          value: this.value.val(),
          picker
        });
      },
      close: function() {
        var picker = this.picker, o2 = this.options;
        picker.find(".select-wrapper").hide(0);
        if (o2.openMode === "auto") {
          picker.find(".select-wrapper").parent().removeClass("drop-up-select drop-as-dialog");
        }
        this.isOpen = false;
        this._fireEvent("close", {
          value: this.value.val(),
          picker
        });
      },
      val: function(value) {
        var o2 = this.options;
        if (!Utils.isValue(value)) {
          return this.element.val();
        }
        this.value = o2.inputFormat ? Datetime.from(value, o2.inputFormat, this.locale) : datetime(value);
        this._set();
      },
      date: function(t, f5) {
        if (t === void 0) {
          return this.value.val();
        }
        try {
          this.value = Datetime.from(t, f5, this.locale);
          this._set();
        } catch (e2) {
          return false;
        }
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attr, newValue) {
        switch (attr) {
          case "disabled":
            this.toggleState();
            break;
          case "data-value":
            this.val(newValue);
            break;
          case "data-format":
            this.options.format = newValue;
            this._set();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element, picker = this.picker;
        $5.each(["moth", "day", "year"], function() {
          picker.find(".sel-" + this).off("scroll");
        });
        picker.off(Metro2.events.start, ".select-block ul");
        picker.off(Metro2.events.click);
        picker.off(Metro2.events.click, ".action-ok");
        picker.off(Metro2.events.click, ".action-cancel");
        return element2;
      }
    });
    $5(document).on(Metro2.events.click, function() {
      $5.each($5(".date-picker"), function() {
        $5(this).find("input").each(function() {
          Metro2.getPlugin(this, "datepicker").close();
        });
      });
    });
  })(Metro, Dom);

  // source/components/directive/directive.js
  (function(Metro2, $5) {
    "use strict";
    const note_icon = `
    <svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M8.75 3.5V2C8.75 1.59 8.41 1.25 8 1.25C7.59 1.25 7.25 1.59 7.25 2V3.56C7.5 3.53 7.73 3.5 8 3.5H8.75Z"/>
        <path d="M16.75 3.56V2C16.75 1.59 16.41 1.25 16 1.25C15.59 1.25 15.25 1.59 15.25 2V3.5H16C16.27 3.5 16.5 3.53 16.75 3.56Z"/>
        <path d="M16.75 3.56V5C16.75 5.41 16.41 5.75 16 5.75C15.59 5.75 15.25 5.41 15.25 5V3.5H8.75V5C8.75 5.41 8.41 5.75 8 5.75C7.59 5.75 7.25 5.41 7.25 5V3.56C4.3 3.83 3 5.73 3 8.5V17C3 20 4.5 22 8 22H16C19.5 22 21 20 21 17V8.5C21 5.73 19.7 3.83 16.75 3.56ZM12 16.75H8C7.59 16.75 7.25 16.41 7.25 16C7.25 15.59 7.59 15.25 8 15.25H12C12.41 15.25 12.75 15.59 12.75 16C12.75 16.41 12.41 16.75 12 16.75ZM16 11.75H8C7.59 11.75 7.25 11.41 7.25 11C7.25 10.59 7.59 10.25 8 10.25H16C16.41 10.25 16.75 10.59 16.75 11C16.75 11.41 16.41 11.75 16 11.75Z"/>
    </svg>
    `;
    const info_icon = `
    <svg width="800px" height="800px" viewBox="-160 0 512 512" xmlns="http://www.w3.org/2000/svg">
        <path d="M20 424.229h20V279.771H20c-11.046 0-20-8.954-20-20V212c0-11.046 8.954-20 20-20h112c11.046 0 20 8.954 20 20v212.229h20c11.046 0 20 8.954 20 20V492c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20v-47.771c0-11.046 8.954-20 20-20zM96 0C56.235 0 24 32.235 24 72s32.235 72 72 72 72-32.235 72-72S135.764 0 96 0z"/>
    </svg>
    `;
    const warning_icon = `
    <svg height="800px" width="800px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 294.995 294.995" xml:space="preserve">
        <path d="M291.874,248.279L165.605,26.526c-4.007-7.037-10.776-11.26-18.107-11.26s-14.101,4.202-18.107,11.239L3.121,248.238 c-3.979,6.989-4.164,15.013-0.493,21.326c3.67,6.313,10.663,10.165,18.705,10.165h252.329c8.042,0,15.035-3.852,18.705-10.165 C296.038,263.251,295.854,255.268,291.874,248.279z M146.665,86.229c9.665,0,17.5,7.835,17.5,17.5v63c0,9.665-7.835,17.5-17.5,17.5 c-9.665,0-17.5-7.835-17.5-17.5v-63C129.165,94.064,137,86.229,146.665,86.229z M147.498,204.005c9.665,0,17.5,7.835,17.5,17.5 c0,9.665-7.835,17.5-17.5,17.5c-9.665,0-17.5-7.835-17.5-17.5C129.998,211.84,137.833,204.005,147.498,204.005z"/>
    </svg>
    `;
    const caution_icon = `
    <svg height="800px" width="800px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512"  xml:space="preserve">
        <path class="st0" d="M387.317,0.005H284.666h-57.332h-102.65L0,124.688v102.67v57.294v102.67l124.684,124.674h102.65h57.332
            h102.651L512,387.321v-102.67v-57.294v-102.67L387.317,0.005z M255.45,411.299c-19.082,0-34.53-15.467-34.53-34.549
            c0-19.053,15.447-34.52,34.53-34.52c19.082,0,34.53,15.467,34.53,34.52C289.98,395.832,274.532,411.299,255.45,411.299z
             M283.414,278.692c0,15.448-12.516,27.964-27.964,27.964c-15.458,0-27.964-12.516-27.964-27.964l-6.566-135.368
            c0-19.072,15.447-34.54,34.53-34.54c19.082,0,34.53,15.467,34.53,34.54L283.414,278.692z"/>
    </svg>
    `;
    const tip_icon = `
    <svg height="800px" width="800px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 256 256" xml:space="preserve">
        <path d="M216.2,92.5c-5.2-5.3-13.8-5.4-19-0.1L157.8,134l-0.3,0.3c-25.5,0.1-46.2,16.8-46.2,37.3h-5.8c0-23.6,23.1-42.8,51.6-43.1
            l-0.1-19.4c0,0-0.1-85.4-0.1-85.5c-0.7-5.8-5.6-10.3-11.7-10.3c-6.5,0-11.7,5.3-11.7,11.7c0,0.2,0,72.9,0,72.9l-5.2,0.2l-0.1-81.2
            c0-6.5-5.3-11.7-11.8-11.7s-11.7,5.3-11.7,11.8v81h-5.6l0.1-63.6c0-6.5-5.3-11.7-11.8-11.7S75.7,28,75.7,34.4V98h-5.2l0.1-34.2
            c0-6.5-5.3-11.7-11.8-11.7s-11.7,5.3-11.7,11.8c0,108.4,0,108.4,0,111c0,13.2,6.8,24.4,16.2,28.1v48.4h0.2v0.4l81.2-0.4v-51.1
            c2.5-0.9,5.1-2,7.6-3.3c15.4-7.9,26.1-20.3,29.5-32.5c2.9-4.3,36.8-56.2,36.8-56.2C221.4,103.7,220.6,96.9,216.2,92.5z"/>
    </svg>  
    `;
    const success_icon = `
        <svg width="800px" height="800px" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
          <path d="M24,2A22,22,0,1,0,46,24,21.9,21.9,0,0,0,24,2ZM35.4,18.4l-14,14a1.9,1.9,0,0,1-2.8,0l-5.9-5.9a2.2,2.2,0,0,1-.4-2.7,2,2,0,0,1,3.1-.2L20,28.2,32.6,15.6a2,2,0,0,1,2.8,2.8Z"/>
        </svg>    
    `;
    const icons = {
      note: note_icon,
      info: info_icon,
      warning: warning_icon,
      caution: caution_icon,
      tip: tip_icon,
      success: success_icon
    };
    let DirectiveDefaultConfig = {
      directive: "note",
      showIcon: true,
      title: "default",
      style: 1,
      // default - 1, vue style - 2, 3 
      onDirectiveCreate: Metro2.noop
    };
    Metro2.directiveSetup = function(options) {
      DirectiveDefaultConfig = $5.extend({}, DirectiveDefaultConfig, options);
    };
    if (typeof globalThis["metroDirectiveSetup"] !== "undefined") {
      Metro2.directiveSetup(globalThis["metroDirectiveSetup"]);
    }
    Metro2.Component("directive", {
      init: function(options, elem) {
        this._super(elem, options, DirectiveDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        const that = this, element2 = this.element, o2 = this.options;
        this._createStructure();
        this._createEvents();
        this._fireEvent("directive-create");
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const directive = element2.wrap("<div>").addClass("directive").addClass(`directive-style-${o2.style}`).addClass(`directive-${o2.directive}`);
        const title = $5("<div>").addClass("directive-title").html(o2.title === "default" ? this.strings[`label_${o2.directive.toLowerCase()}`].toUpperCase() : o2.title);
        if (o2.showIcon) {
          title.prepend($5("<span>").addClass("icon").html(icons[o2.directive]));
        }
        directive.prepend(title);
        this.component = directive;
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/donut/donut.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var DonutDefaultConfig = {
      donutDeferred: 0,
      size: 100,
      hole: 0.8,
      value: 0,
      background: "transparent",
      color: "",
      stroke: "#d1d8e7",
      fill: "#49649f",
      fontSize: 0,
      total: 100,
      cap: "%",
      showText: true,
      showValue: false,
      animate: 0,
      onChange: Metro2.noop,
      onDrawValue: function(v4) {
        return v4;
      },
      onDonutCreate: Metro2.noop
    };
    Metro2.donutSetup = function(options) {
      DonutDefaultConfig = $5.extend({}, DonutDefaultConfig, options);
    };
    if (typeof globalThis["metroDonutSetup"] !== "undefined") {
      Metro2.donutSetup(globalThis["metroDonutSetup"]);
    }
    Metro2.Component("donut", {
      init: function(options, elem) {
        this._super(elem, options, DonutDefaultConfig, {
          value: 0,
          animation_change_interval: null
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        element2.addClass("donut");
        this._setElementSize();
        this._draw();
        this._addEvents();
        this.val(o2.value);
        this._fireEvent("donut-create", {
          element: element2
        });
      },
      _setElementSize: function() {
        var element2 = this.element, o2 = this.options;
        var width = o2.size;
        element2.css({
          width,
          background: o2.background
        });
        element2.css({
          height: element2.width()
        });
      },
      _draw: function() {
        var element2 = this.element, o2 = this.options;
        var html = "";
        var radius = element2.width() / 2;
        var r2 = radius * (1 - (1 - o2.hole) / 2);
        var width = radius * (1 - o2.hole);
        var transform = "rotate(-90 " + radius + "," + radius + ")";
        var fontSize = o2.fontSize === 0 ? r2 * o2.hole * 0.6 : o2.fontSize;
        html += "<svg>";
        html += "   <circle class='donut-back' r='" + r2 + "px' cx='" + radius + "px' cy='" + radius + "px' transform='" + transform + "' fill='none' stroke='" + o2.stroke + "' stroke-width='" + width + "'/>";
        html += "   <circle class='donut-fill' r='" + r2 + "px' cx='" + radius + "px' cy='" + radius + "px' transform='" + transform + "' fill='none' stroke='" + o2.fill + "' stroke-width='" + width + "'/>";
        if (o2.showText === true)
          html += "   <text class='donut-title' x='" + radius + "px' y='" + radius + "px' dy='" + fontSize / 3 + "px' text-anchor='middle' fill='" + (o2.color !== "" ? o2.color : o2.fill) + "' font-size='" + fontSize + "px'></text>";
        html += "</svg>";
        element2.html(html);
      },
      _addEvents: function() {
        var that = this;
        $5(globalThis).on("resize", function() {
          that._setElementSize();
          that._draw();
          that.val(that.value);
        });
      },
      _setValue: function(v4) {
        var element2 = this.element, o2 = this.options;
        var fill = element2.find(".donut-fill");
        var title = element2.find(".donut-title");
        var radius = element2.width() / 2;
        var r2 = radius * (1 - (1 - o2.hole) / 2);
        var circumference = Math.round(2 * Math.PI * r2);
        var title_value = o2.showValue ? v4 : Utils.percent(o2.total, v4, true);
        var fill_value = Math.round(+v4 * circumference / o2.total);
        var sda = fill.attr("stroke-dasharray");
        if (typeof sda === "undefined") {
          sda = 0;
        } else {
          sda = +sda.split(" ")[0];
        }
        var delta = fill_value - sda;
        fill.animate({
          draw: function(t, p3) {
            $5(this).attr("stroke-dasharray", sda + delta * p3 + " " + circumference);
          },
          dur: o2.animate
        });
        title.html(Metro2.utils.exec(o2.onDrawValue, [title_value + o2.cap]));
      },
      val: function(v4) {
        var o2 = this.options;
        if (v4 === void 0) {
          return this.value;
        }
        if (parseInt(v4) < 0 || parseInt(v4) > o2.total) {
          return false;
        }
        this._setValue(v4);
        this.value = v4;
        this._fireEvent("change", {
          value: this.value
        });
      },
      setColor: function(obj) {
        var validKeys = ["background", "fill", "stroke", "color"];
        var that = this;
        $5.each(obj, function(key, val) {
          if (validKeys.indexOf(key) !== -1) {
            that.options[key] = val;
          }
        });
        this._draw();
        this.val(this.value);
        return this;
      },
      changeValue: function() {
        this.val(this.element.attr("data-value"));
      },
      changeAttribute: function(attr, val) {
        switch (attr) {
          case "data-value":
            this.changeValue();
            break;
          case "data-background":
            this.setColor({ background: val });
            break;
          case "data-fill":
            this.setColor({ fill: val });
            break;
          case "data-stroke":
            this.setColor({ stroke: val });
            break;
          case "data-color":
            this.setColor({ color: val });
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/double-select-box/double-select-box.js
  (function(Metro2, $5) {
    "use strict";
    var DoubleSelectBoxDefaultConfig = {
      height: "auto",
      multiSelect: false,
      moveRightIcon: "&rsaquo;",
      moveRightAllIcon: "&raquo;",
      moveLeftIcon: "&lsaquo;",
      moveLeftAllIcon: "&laquo;",
      clsBox: "",
      clsMoveButton: "",
      clsMoveRightButton: "",
      clsMoveRightAllButton: "",
      clsMoveLeftButton: "",
      clsMoveLeftAllButton: "",
      clsListLeft: "",
      clsListRight: "",
      onDoubleSelectBoxCreate: Metro2.noop
    };
    Metro2.doubleSelectBoxSetup = function(options) {
      DoubleSelectBoxDefaultConfig = $5.extend({}, DoubleSelectBoxDefaultConfig, options);
    };
    if (typeof globalThis["metroDoubleSelectBoxSetup"] !== "undefined") {
      Metro2.doubleSelectBoxSetup(globalThis["metroDoubleSelectBoxSetup"]);
    }
    Metro2.Component("double-select-box", {
      init: function(options, elem) {
        this._super(elem, options, DoubleSelectBoxDefaultConfig, {
          // define instance vars here
          select1: null,
          select2: null,
          list1: null,
          list2: null
        });
        return this;
      },
      _create: function() {
        var that = this, element2 = this.element, o2 = this.options;
        if (element2.children("select").length !== 2) {
          throw new Error("Component DoubleSelectBox required two select elements!");
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("double-select-box-create");
      },
      _drawList: function() {
        var that = this;
        this.list1.clear();
        this.select1.find("option").each(function(i3, option) {
          const $op = $5(option);
          const icon = $op.attr("data-icon");
          let html = $op.attr("data-template") ? $op.attr("data-template").replace(/\$1/g, $op.text()) : $op.text();
          if (icon) {
            html = $5("<span>").addClass("icon").append(icon).outerHTML() + html;
          }
          that.list1.append(
            $5("<li>").html(html).attr("data-value", option.value).data("option", option)
          );
        });
        this.list2.clear();
        this.select2.find("option").each(function(i3, option) {
          const $op = $5(option);
          const icon = $op.attr("data-icon");
          let html = $op.attr("data-template") ? $op.attr("data-template").replace(/\$1/g, $op.text()) : $op.text();
          if (icon) {
            html = $5("<span>").addClass("icon").append(icon).outerHTML() + html;
          }
          that.list2.append(
            $5("<li>").html(html).attr("data-value", option.value).data("option", option)
          );
        });
      },
      _createStructure: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var selects = element2.children("select");
        var select1 = selects.eq(0);
        var select2 = selects.eq(1);
        var controls = $5("<div>").addClass("controls").insertBefore(select2);
        var list1, list2;
        element2.addClass("double-select-box").addClass(o2.clsBox).css({
          height: o2.height
        });
        selects.prop("multiple", true);
        controls.append(
          $5([
            $5("<button>").attr("type", "button").addClass("button square small --move-right").addClass(o2.clsMoveButton).addClass(o2.clsMoveRightButton).html(`<span class="icon">${o2.moveRightIcon}</span>`),
            $5("<button>").attr("type", "button").addClass("button square small --move-right-all").addClass(o2.clsMoveButton).addClass(o2.clsMoveRightAllButton).html(`<span class="icon">${o2.moveRightAllIcon}</span>`),
            $5("<button>").attr("type", "button").addClass("button square small --move-left-all").addClass(o2.clsMoveButton).addClass(o2.clsMoveLeftAllButton).html(`<span class="icon">${o2.moveLeftAllIcon}</span>`),
            $5("<button>").attr("type", "button").addClass("button square small --move-left").addClass(o2.clsMoveButton).addClass(o2.clsMoveLeftButton).html(`<span class="icon">${o2.moveLeftIcon}</span>`)
          ])
        );
        list1 = $5("<ul>").addClass("--list1").addClass(o2.clsListLeft).insertBefore(select1);
        list2 = $5("<ul>").addClass("--list2").addClass(o2.clsListRight).insertBefore(select2);
        this.select1 = select1;
        this.select2 = select2;
        this.list1 = list1;
        this.list2 = list2;
        this._drawList();
      },
      _moveItems: function(items, targets) {
        $5.each(items, function() {
          var $item = $5(this);
          var option = $item.data("option");
          $5(option).appendTo(targets[0]);
          $item.removeClass("active").appendTo(targets[1]);
        });
      },
      _move: function(dir, scope) {
        var that = this;
        if (scope === "selected") {
          if (dir === "ltr") {
            that._moveItems(this.list1.find("li.active"), [that.select2, that.list2]);
          } else {
            that._moveItems(this.list2.find("li.active"), [that.select1, that.list1]);
          }
        } else {
          if (dir === "ltr") {
            that._moveItems(this.list1.find("li"), [that.select2, that.list2]);
          } else {
            that._moveItems(this.list2.find("li"), [that.select1, that.list1]);
          }
        }
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var items = element2.find("li");
        items.on("click", function() {
          var $el = $5(this);
          if (o2.multiSelect === false) {
            that.list1.find("li").removeClass("active");
            that.list2.find("li").removeClass("active");
          }
          $el.addClass("active");
        });
        items.on("dblclick", function() {
          var $el = $5(this);
          var dir = $el.parent().hasClass("--list1") ? "ltr" : "rtl";
          var scope = "selected";
          that.list1.find("li").removeClass("active");
          that.list2.find("li").removeClass("active");
          $el.addClass("active");
          that._move(dir, scope);
        });
        element2.on("click", "button", function() {
          var btn = $5(this);
          if (btn.hasClass("--move-right")) {
            that._move("ltr", "selected");
          } else if (btn.hasClass("--move-right-all")) {
            that._move("ltr", "all");
          } else if (btn.hasClass("--move-left")) {
            that._move("rtl", "selected");
          } else if (btn.hasClass("--move-left-all")) {
            that._move("rtl", "all");
          } else {
            throw new Error("Pressed unregistered button!");
          }
        });
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/double-slider/double-slider.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var DoubleSliderDefaultConfig = {
      doublesliderDeferred: 0,
      roundValue: true,
      min: 0,
      max: 100,
      accuracy: 0,
      showMinMax: false,
      minMaxPosition: Metro2.position.BOTTOM,
      valueMin: null,
      valueMax: null,
      hint: false,
      hintAlways: false,
      hintPositionMin: Metro2.position.TOP,
      hintPositionMax: Metro2.position.TOP,
      hintMaskMin: "$1",
      hintMaskMax: "$1",
      target: null,
      size: 0,
      clsSlider: "",
      clsBackside: "",
      clsComplete: "",
      clsMarker: "",
      clsMarkerMin: "",
      clsMarkerMax: "",
      clsHint: "",
      clsHintMin: "",
      clsHintMax: "",
      clsMinMax: "",
      clsMin: "",
      clsMax: "",
      onStart: Metro2.noop,
      onStop: Metro2.noop,
      onMove: Metro2.noop,
      onChange: Metro2.noop,
      onChangeValue: Metro2.noop,
      onFocus: Metro2.noop,
      onBlur: Metro2.noop,
      onDoubleSliderCreate: Metro2.noop
    };
    Metro2.doubleSliderSetup = function(options) {
      DoubleSliderDefaultConfig = $5.extend({}, DoubleSliderDefaultConfig, options);
    };
    if (typeof globalThis["metroDoubleSliderSetup"] !== "undefined") {
      Metro2.doubleSliderSetup(globalThis["metroDoubleSliderSetup"]);
    }
    Metro2.Component("double-slider", {
      init: function(options, elem) {
        this._super(elem, options, DoubleSliderDefaultConfig, {
          slider: null,
          valueMin: null,
          valueMax: null,
          keyInterval: false,
          id: Utils.elementId("slider")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        this.valueMin = Utils.isValue(o2.valueMin) ? +o2.valueMin : +o2.min;
        this.valueMax = Utils.isValue(o2.valueMax) ? +o2.valueMax : +o2.max;
        this._createSlider();
        this._createEvents();
        this.val(this.valueMin, this.valueMax);
        this._fireEvent("double-slider-create", {
          element: element2
        });
      },
      _createSlider: function() {
        var element2 = this.element, o2 = this.options;
        var slider_wrapper = $5("<div>").addClass("slider-wrapper");
        var slider = $5("<div>").addClass("slider").addClass(o2.clsSlider).addClass(this.elem.className);
        var backside = $5("<div>").addClass("backside").addClass(o2.clsBackside);
        var complete = $5("<div>").addClass("complete").addClass(o2.clsComplete);
        var markerMin = $5("<button>").attr("type", "button").addClass("marker marker-min").addClass(o2.clsMarker).addClass(o2.clsMarkerMin);
        var markerMax = $5("<button>").attr("type", "button").addClass("marker marker-max").addClass(o2.clsMarker).addClass(o2.clsMarkerMax);
        var hintMin = $5("<div>").addClass("hint hint-min").addClass(o2.hintPositionMin + "-side").addClass(o2.clsHint).addClass(o2.clsHintMin);
        var hintMax = $5("<div>").addClass("hint hint-max").addClass(o2.hintPositionMax + "-side").addClass(o2.clsHint).addClass(o2.clsHintMax);
        var i3;
        if (o2.size > 0) {
          slider.outerWidth(o2.size);
        }
        slider.insertBefore(element2);
        element2.appendTo(slider);
        slider_wrapper.insertBefore(slider);
        slider.appendTo(slider_wrapper);
        backside.appendTo(slider);
        complete.appendTo(slider);
        markerMin.appendTo(slider);
        markerMax.appendTo(slider);
        hintMin.appendTo(markerMin);
        hintMax.appendTo(markerMax);
        if (o2.hintAlways === true) {
          $5([hintMin, hintMax]).css({
            display: "block"
          }).addClass("permanent-hint");
        }
        if (o2.showMinMax === true) {
          var min_max_wrapper = $5("<div>").addClass("slider-min-max").addClass(o2.clsMinMax);
          $5("<span>").addClass("slider-text-min").addClass(o2.clsMin).html(`${o2.min}`).appendTo(min_max_wrapper);
          $5("<span>").addClass("slider-text-max").addClass(o2.clsMax).html(`${o2.max}`).appendTo(min_max_wrapper);
          if (o2.minMaxPosition === Metro2.position.TOP) {
            min_max_wrapper.insertBefore(slider);
          } else {
            min_max_wrapper.insertAfter(slider);
          }
        }
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          for (i3 = 0; i3 < element2[0].style.length; i3++) {
            slider.css(element2[0].style[i3], element2.css(element2[0].style[i3]));
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.slider = slider;
      },
      _createEvents: function() {
        var that = this, slider = this.slider, o2 = this.options;
        var marker = slider.find(".marker");
        marker.on(Metro2.events.startAll, function() {
          var _marker = $5(this);
          var hint = _marker.find(".hint");
          _marker.addClass("active");
          if (o2.hint === true && o2.hintAlways !== true) {
            hint.fadeIn(300);
          }
          $5(document).on(Metro2.events.moveAll, function(e2) {
            that._move(e2);
            that._fireEvent("move", {
              min: that.valueMin,
              max: that.valueMax
            });
          }, { ns: that.id });
          $5(document).on(Metro2.events.stopAll, function() {
            slider.find(".marker").removeClass("active");
            $5(document).off(Metro2.events.moveAll, { ns: that.id });
            $5(document).off(Metro2.events.stopAll, { ns: that.id });
            if (o2.hintAlways !== true) {
              hint.fadeOut(300);
            }
            that._fireEvent("stop", {
              min: that.valueMin,
              max: that.valueMax
            });
          }, { ns: that.id });
          that._fireEvent("start", {
            min: that.valueMin,
            max: that.valueMax
          });
        });
        marker.on(Metro2.events.focus, function() {
          that._fireEvent("focus", {
            min: that.valueMin,
            max: that.valueMax
          });
        });
        marker.on(Metro2.events.blur, function() {
          that._fireEvent("blur", {
            min: that.valueMin,
            max: that.valueMax
          });
        });
        $5(globalThis).on(Metro2.events.resize, function() {
          that.val(that.valueMin, that.valueMax);
        }, { ns: that.id });
      },
      _convert: function(v4, how) {
        var slider = this.slider, o2 = this.options;
        var length = slider.outerWidth() - slider.find(".marker").outerWidth();
        switch (how) {
          case "pix2prc":
            return v4 * 100 / length;
          case "pix2val":
            return this._convert(v4, "pix2prc") * ((o2.max - o2.min) / 100) + o2.min;
          case "val2prc":
            return (v4 - o2.min) / ((o2.max - o2.min) / 100);
          case "prc2pix":
            return v4 / (100 / length);
          case "val2pix":
            return this._convert(this._convert(v4, "val2prc"), "prc2pix");
        }
        return 0;
      },
      _correct: function(value) {
        var res = value;
        var accuracy = this.options.accuracy;
        var min = this.options.min, max = this.options.max;
        var _dec = function(v4) {
          return v4 % 1 === 0 ? 0 : v4.toString().split(".")[1].length;
        };
        if (accuracy === 0 || isNaN(accuracy)) {
          return res;
        }
        res = Math.round(value / accuracy) * accuracy;
        if (res < min) {
          res = min;
        }
        if (res > max) {
          res = max;
        }
        return res.toFixed(_dec(accuracy));
      },
      _move: function(e2) {
        var target = this.slider.find(".marker.active");
        var isMin = target.hasClass("marker-min");
        var slider = this.slider;
        var offset = slider.offset(), marker_size = slider.find(".marker").outerWidth(), markerMin = slider.find(".marker-min"), markerMax = slider.find(".marker-max"), length = slider.outerWidth(), cPix, cStart, cStop;
        cPix = Utils.pageXY(e2).x - offset.left - marker_size / 2;
        if (isMin) {
          cStart = 0;
          cStop = parseInt(markerMax.css("left")) - marker_size;
        } else {
          cStart = parseInt(markerMin.css("left")) + marker_size;
          cStop = length - marker_size;
        }
        if (cPix < cStart || cPix > cStop) {
          return;
        }
        this[isMin ? "valueMin" : "valueMax"] = this._correct(this._convert(cPix, "pix2val"));
        this._redraw();
      },
      _hint: function() {
        var that = this, o2 = this.options, slider = this.slider, hint = slider.find(".hint");
        hint.each(function() {
          var _hint = $5(this);
          var isMin = _hint.hasClass("hint-min");
          var _mask = isMin ? o2.hintMaskMin : o2.hintMaskMax;
          var value = +(isMin ? that.valueMin : that.valueMax) || 0;
          _hint.text(_mask.replace("$1", value.toFixed(Utils.decCount(o2.accuracy))));
        });
      },
      _value: function() {
        var element2 = this.element, o2 = this.options;
        var v1 = +this.valueMin || 0, v22 = +this.valueMax || 0;
        var value;
        if (o2.roundValue) {
          v1 = v1.toFixed(Utils.decCount(o2.accuracy));
          v22 = v22.toFixed(Utils.decCount(o2.accuracy));
        }
        value = [v1, v22].join(", ");
        if (element2[0].tagName === "INPUT") {
          element2.val(value);
        }
        if (o2.target !== null) {
          var target = $5(o2.target);
          if (target.length !== 0) {
            $5.each(target, function() {
              var t = $5(this);
              if (this.tagName === "INPUT") {
                t.val(value);
              } else {
                t.text(value);
              }
              t.trigger("change");
            });
          }
        }
        this._fireEvent("change-value", {
          val: value
        });
        this._fireEvent("change", {
          val: value
        });
      },
      _marker: function() {
        var slider = this.slider;
        var markerMin = slider.find(".marker-min");
        var markerMax = slider.find(".marker-max");
        var complete = slider.find(".complete");
        var marker_size = parseInt(Utils.getStyleOne(markerMin, "width"));
        var slider_visible = Utils.isVisible(slider);
        if (slider_visible) {
          $5([markerMin, markerMax]).css({
            "margin-top": 0,
            "margin-left": 0
          });
        }
        if (slider_visible) {
          markerMin.css("left", this._convert(this.valueMin, "val2pix"));
          markerMax.css("left", this._convert(this.valueMax, "val2pix"));
        } else {
          markerMin.css({
            "left": this._convert(this.valueMin, "val2prc") + "%",
            "margin-top": this._convert(this.valueMin, "val2prc") === 0 ? 0 : -1 * marker_size / 2
          });
          markerMax.css({
            "left": this._convert(this.valueMax, "val2prc") + "%",
            "margin-top": this._convert(this.valueMax, "val2prc") === 0 ? 0 : -1 * marker_size / 2
          });
        }
        complete.css({
          "left": this._convert(this.valueMin, "val2pix"),
          "width": this._convert(this.valueMax, "val2pix") - this._convert(this.valueMin, "val2pix")
        });
      },
      _redraw: function() {
        this._marker();
        this._value();
        this._hint();
      },
      val: function(vMin, vMax) {
        var o2 = this.options;
        if (!Utils.isValue(vMin) && !Utils.isValue(vMax)) {
          return [this.valueMin, this.valueMax];
        }
        if (vMin < o2.min) vMin = o2.min;
        if (vMax < o2.min) vMax = o2.min;
        if (vMin > o2.max) vMin = o2.max;
        if (vMax > o2.max) vMax = o2.max;
        this.valueMin = this._correct(vMin);
        this.valueMax = this._correct(vMax);
        this._redraw();
      },
      changeValue: function() {
        var element2 = this.element;
        var valMin = +element2.attr("data-value-min");
        var valMax = +element2.attr("data-value-max");
        this.val(valMin, valMax);
      },
      disable: function() {
        var element2 = this.element;
        element2.data("disabled", true);
        element2.parent().addClass("disabled");
      },
      enable: function() {
        var element2 = this.element;
        element2.data("disabled", false);
        element2.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-value-min":
            this.changeValue();
            break;
          case "data-value-max":
            this.changeValue();
            break;
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element, slider = this.slider;
        var marker = slider.find(".marker");
        marker.off(Metro2.events.startAll);
        marker.off(Metro2.events.focus);
        marker.off(Metro2.events.blur);
        marker.off(Metro2.events.keydown);
        marker.off(Metro2.events.keyup);
        slider.off(Metro2.events.click);
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/drag-items/drag-items.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var DragItemsDefaultConfig = {
      dragitemsDeferred: 0,
      target: null,
      dragItem: "li",
      dragMarker: ".drag-item-marker",
      drawDragMarker: false,
      clsDragItemAvatar: "",
      clsDragItem: "",
      canDrag: true,
      onDragStartItem: Metro2.noop,
      onDragMoveItem: Metro2.noop,
      onDragDropItem: Metro2.noop,
      onTarget: Metro2.noop,
      onTargetIn: Metro2.noop,
      //TODO
      onTargetOut: Metro2.noop,
      //TODO
      onDragItemsCreate: Metro2.noop
    };
    Metro2.dragItemsSetup = function(options) {
      DragItemsDefaultConfig = $5.extend({}, DragItemsDefaultConfig, options);
    };
    if (typeof globalThis["metroDragItemsSetup"] !== "undefined") {
      Metro2.dragItemsSetup(globalThis["metroDragItemsSetup"]);
    }
    Metro2.Component("drag-items", {
      init: function(options, elem) {
        this._super(elem, options, DragItemsDefaultConfig, {
          id: Utils.elementId("dragItems"),
          canDrag: false
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("drag-items-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        element2.addClass("drag-items-target");
        if (o2.drawDragMarker === true) {
          element2.find(o2.dragItem).each(function() {
            $5("<span>").addClass("drag-item-marker").appendTo(this);
          });
        }
        o2.canDrag ? this.on() : this.off();
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var doc = $5.document(), body = $5.body();
        var offset, shift2 = { top: 0, left: 0 }, width, height;
        var move = function(e2, avatar, dragItem) {
          var x4 = Utils.pageXY(e2).x, y3 = Utils.pageXY(e2).y;
          var _top = y3 - shift2.top;
          var _left = x4 - shift2.left;
          avatar.css({
            top: _top,
            left: _left
          });
          var target = document.elementsFromPoint(x4, y3).filter(function(el) {
            return $5(el).hasClass("drag-items-target");
          });
          if (target.length === 0) {
            return;
          }
          that._fireEvent("target", {
            target
          });
          var sibling = document.elementsFromPoint(x4, y3).filter(function(el) {
            var $el = $5(el);
            return $5.matches(el, o2.dragItem) && !$el.hasClass("dragged-item-avatar");
          })[0];
          if (!Utils.isValue(sibling)) {
            dragItem.appendTo(target);
          } else {
            var $sibling = $5(sibling);
            var $sibling_offset = $sibling.offset();
            var offsetY = y3 - $sibling_offset.top;
            var offsetX = x4 - $sibling_offset.left;
            var side;
            var dim = { w: $sibling.width(), h: $sibling.height() };
            if (offsetX < dim.w / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
              side = "left";
            } else if (offsetX > dim.w * 2 / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
              side = "right";
            } else if (offsetX > dim.w / 3 && offsetX < dim.w * 2 / 3 && offsetY > dim.h / 2) {
              side = "bottom";
            } else {
              side = "top";
            }
            if (!$sibling.hasClass("dragged-item")) {
              if (side === "top" || side === "left") {
                dragItem.insertBefore($sibling);
              } else {
                dragItem.insertAfter($sibling);
              }
            }
          }
        };
        element2.on(Metro2.events.startAll, o2.drawDragMarker ? o2.dragMarker : o2.dragItem, function(e_start) {
          var dragItem = $5(e_start.target).closest(o2.dragItem);
          var avatar;
          if (Utils.isRightMouse(e_start)) {
            return;
          }
          if (that.canDrag !== true) {
            return;
          }
          dragItem.addClass("dragged-item").addClass(o2.clsDragItem);
          avatar = $5("<div>").addClass("dragged-item-avatar").addClass(o2.clsDragItemAvatar);
          offset = dragItem.offset();
          width = dragItem.width();
          height = dragItem.height();
          shift2.top = Utils.pageXY(e_start).y - offset.top;
          shift2.left = Utils.pageXY(e_start).x - offset.left;
          avatar.css({
            top: offset.top,
            left: offset.left,
            width,
            height
          }).appendTo(body);
          that._fireEvent("drag-start-item", {
            dragItem: dragItem[0],
            avatar: avatar[0]
          });
          doc.on(Metro2.events.moveAll, function(e_move) {
            move(e_move, avatar, dragItem);
            that._fireEvent("drag-move-item", {
              dragItem: dragItem[0],
              avatar: avatar[0]
            });
            e_move.preventDefault();
          }, { ns: that.id, passive: false });
          doc.on(Metro2.events.stopAll, function() {
            that._fireEvent("drag-drop-item", {
              dragItem: dragItem[0],
              avatar: avatar[0]
            });
            dragItem.removeClass("dragged-item").removeClass(o2.clsDragItem);
            avatar.remove();
            doc.off(Metro2.events.moveAll, { ns: that.id });
            doc.off(Metro2.events.stopAll, { ns: that.id });
          }, { ns: that.id });
          if (o2.drawDragMarker) {
            e_start.preventDefault();
            e_start.stopPropagation();
          }
        });
      },
      on: function() {
        this.canDrag = true;
        this.element.find(".drag-item-marker").show();
      },
      off: function() {
        this.canDrag = false;
        this.element.find(".drag-item-marker").hide();
      },
      toggle: function() {
        this.canDrag = this.canDrag ? this.off() : this.on();
      },
      changeAttribute: function(attributeName) {
        var that = this, element2 = this.element, o2 = this.options;
        var changeCanDrag = function() {
          o2.canDtag = JSON.parse(element2.attr("data-can-drag"));
          o2.canDtag ? that.on() : that.off();
        };
        if (attributeName === "data-can-drag") {
          changeCanDrag();
        }
      },
      destroy: function() {
        var element2 = this.element, o2 = this.options;
        element2.off(Metro2.events.startAll, o2.drawDragMarker ? o2.dragMarker : o2.dragItem);
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/draggable/draggable.js
  (function(Metro2, $5) {
    "use strict";
    let DraggableDefaultConfig = {
      dragContext: null,
      draggableDeferred: 0,
      dragElement: "self",
      dragArea: "parent",
      timeout: 0,
      boundaryRestriction: true,
      onCanDrag: Metro2.noop_true,
      onDragStart: Metro2.noop,
      onDragStop: Metro2.noop,
      onDragMove: Metro2.noop,
      onDraggableCreate: Metro2.noop
    };
    Metro2.draggableSetup = function(options) {
      DraggableDefaultConfig = $5.extend({}, DraggableDefaultConfig, options);
    };
    if (typeof globalThis["metroDraggableSetup"] !== "undefined") {
      Metro2.draggableSetup(globalThis["metroDraggableSetup"]);
    }
    Metro2.Component("draggable", {
      init: function(options, elem) {
        this._super(elem, options, DraggableDefaultConfig, {
          drag: false,
          move: false,
          backup: {
            cursor: "default",
            zIndex: "0"
          },
          dragArea: null,
          dragElement: null,
          id: Metro2.utils.elementId("draggable")
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("draggable-create", {
          element: this.element
        });
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const offset = element2.offset();
        const dragElement = o2.dragElement !== "self" ? element2.find(o2.dragElement) : element2;
        element2.data("canDrag", true);
        this.dragElement = dragElement;
        dragElement[0].ondragstart = function() {
          return false;
        };
        element2.css("position", "absolute");
        if (o2.dragArea === "document" || o2.dragArea === "window") {
          o2.dragArea = "body";
        }
        setTimeout(function() {
          that.dragArea = o2.dragArea === "parent" ? element2.parent() : $5(o2.dragArea);
          if (that.dragArea.css("position") === "static") {
            that.dragArea.css("position", "relative");
          }
          if (o2.dragArea !== "parent") {
            element2.appendTo(that.dragArea);
            element2.css({
              top: offset.top,
              left: offset.left
            });
          }
        });
        if (!element2.attr("id")) {
          element2.attr("id", Metro2.utils.elementId("draggable"));
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const position = {
          x: 0,
          y: 0
        };
        this.dragElement.on(Metro2.events.startAll, function(e2) {
          const coord = element2.position(), shiftX = Metro2.utils.pageXY(e2).x - coord.left, shiftY = Metro2.utils.pageXY(e2).y - coord.top;
          const moveElement = function(e3) {
            let top = Metro2.utils.pageXY(e3).y - shiftY;
            let left = Metro2.utils.pageXY(e3).x - shiftX;
            if (o2.boundaryRestriction) {
              if (top < 0) top = 0;
              if (left < 0) left = 0;
              if (top > that.dragArea.outerHeight() - element2.outerHeight()) top = that.dragArea.outerHeight() - element2.outerHeight();
              if (left > that.dragArea.outerWidth() - element2.outerWidth()) left = that.dragArea.outerWidth() - element2.outerWidth();
            }
            position.y = top;
            position.x = left;
            element2.css({
              left,
              top
            });
            that._fireEvent("drag-move", {
              position,
              context: o2.dragContext
            });
          };
          if (element2.data("canDrag") === false || Metro2.utils.exec(o2.onCanDrag, [element2]) !== true) {
            return;
          }
          if (Metro2.isTouchable === false && e2.which !== 1) {
            return;
          }
          that.drag = true;
          element2.addClass("draggable");
          that._fireEvent("drag-start", {
            position,
            context: o2.dragContext
          });
          $5(document).on(Metro2.events.moveAll, moveElement, { ns: that.id, passive: false });
          $5(document).on(Metro2.events.stopAll, function() {
            element2.removeClass("draggable");
            $5(document).off(Metro2.events.moveAll, { ns: that.id });
            $5(document).off(Metro2.events.stopAll, { ns: that.id });
            that.drag = false;
            that.move = false;
            that._fireEvent("drag-stop", {
              position,
              context: o2.dragContext
            });
          }, { ns: that.id });
        });
      },
      off: function() {
        this.element.data("canDrag", false);
      },
      on: function() {
        this.element.data("canDrag", true);
      },
      /* eslint-disable-next-line */
      changeAttribute: function(attributeName, newValue) {
      },
      destroy: function() {
        const element2 = this.element;
        this.dragElement.off(Metro2.events.startAll);
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/eval/eval.js
  (function(Metro2, $5) {
    "use strict";
    let EvalDefaultConfig = {
      enabled: true,
      logErrors: false,
      delimiterStart: "{{",
      delimiterEnd: "}}",
      context: null,
      // контекст выполнения для передачи переменных
      processChild: true
      // обработка дочерних элементов
    };
    Metro2.evalSetup = function(options) {
      EvalDefaultConfig = $5.extend({}, EvalDefaultConfig, options);
    };
    if (typeof globalThis["metroEvalSetup"] !== "undefined") {
      Metro2.evalSetup(globalThis["metroEvalSetup"]);
    }
    Metro2.Component("eval", {
      init: function(options, elem) {
        this._super(elem, options, EvalDefaultConfig, {
          origContent: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.origContent = element2.html();
        if (this.options.enabled) {
          if (this.options.processChild) {
            this._processNodeAndChildren(element2[0]);
          } else {
            element2.text(this.eval(element2.text()));
          }
        }
      },
      _processNodeAndChildren: function(node) {
        if (node.nodeType === 3) {
          node.textContent = this.eval(node.textContent);
          return;
        }
        for (let i3 = 0; i3 < node.childNodes.length; i3++) {
          this._processNodeAndChildren(node.childNodes[i3]);
        }
      },
      eval: function(str2) {
        const o2 = this.options;
        if (!o2.enabled) return str2;
        const regex = new RegExp(
          this._escapeRegExp(o2.delimiterStart || "{{") + "(.*?)" + this._escapeRegExp(o2.delimiterEnd || "}}"),
          "gs"
        );
        return str2.replace(regex, (match, code) => {
          try {
            const fn = new Function("return " + code);
            return fn.call(o2.context);
          } catch (error) {
            if (o2.logErrors) {
              console.error("Metro UI Eval error:", error, "in code:", code);
            }
            return match;
          }
        });
      },
      _escapeRegExp: function(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      },
      reset: function() {
        if (this.origContent) {
          this.element.html(this.origContent);
        }
      },
      destroy: function() {
        this.reset();
        return this._super();
      }
    });
    Metro2.evalText = function(text, options) {
      const tempConfig = $5.extend({}, EvalDefaultConfig, options);
      const instance = { options: tempConfig };
      return Metro2.Component("eval").prototype.eval.call(instance, text);
    };
  })(Metro, Dom);

  // source/components/export/export.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var Export = {
      init: function() {
        return this;
      },
      options: {
        csvDelimiter: "	",
        csvNewLine: "\r\n",
        includeHeader: true
      },
      setup: function(options) {
        this.options = $5.extend({}, this.options, options);
        return this;
      },
      base64: function(data) {
        return globalThis.btoa(unescape(encodeURIComponent(data)));
      },
      b64toBlob: function(b64Data, contentType, sliceSize) {
        contentType = contentType || "";
        sliceSize = sliceSize || 512;
        var byteCharacters = globalThis.atob(b64Data);
        var byteArrays = [];
        var offset;
        for (offset = 0; offset < byteCharacters.length; offset += sliceSize) {
          var slice = byteCharacters.slice(offset, offset + sliceSize);
          var byteNumbers = new Array(slice.length);
          var i3;
          for (i3 = 0; i3 < slice.length; i3 = i3 + 1) {
            byteNumbers[i3] = slice.charCodeAt(i3);
          }
          var byteArray = new globalThis.Uint8Array(byteNumbers);
          byteArrays.push(byteArray);
        }
        return new Blob(byteArrays, {
          type: contentType
        });
      },
      tableToCSV: function(table, filename, options) {
        var o2;
        var body, head, data = "";
        var i3, j4, row, cell;
        o2 = $5.extend({}, this.options, options);
        table = $5(table)[0];
        if (Utils.bool(o2.includeHeader)) {
          head = table.querySelectorAll("thead")[0];
          for (i3 = 0; i3 < head.rows.length; i3++) {
            row = head.rows[i3];
            for (j4 = 0; j4 < row.cells.length; j4++) {
              cell = row.cells[j4];
              data += (j4 ? o2.csvDelimiter : "") + cell.textContent.trim();
            }
            data += o2.csvNewLine;
          }
        }
        body = table.querySelectorAll("tbody")[0];
        for (i3 = 0; i3 < body.rows.length; i3++) {
          row = body.rows[i3];
          for (j4 = 0; j4 < row.cells.length; j4++) {
            cell = row.cells[j4];
            data += (j4 ? o2.csvDelimiter : "") + cell.textContent.trim();
          }
          data += o2.csvNewLine;
        }
        if (Utils.isValue(filename)) {
          return this.createDownload(this.base64("\uFEFF" + data), "application/csv", filename);
        }
        return data;
      },
      createDownload: function(data, contentType, filename) {
        var blob, anchor, url;
        anchor = document.createElement("a");
        anchor.style.display = "none";
        document.body.appendChild(anchor);
        blob = this.b64toBlob(data, contentType);
        url = globalThis.URL.createObjectURL(blob);
        anchor.href = url;
        anchor.download = filename || Utils.elementId("download");
        anchor.click();
        globalThis.URL.revokeObjectURL(url);
        document.body.removeChild(anchor);
        return true;
      },
      arrayToCsv: function(array, filename, options) {
        var o2, data = "", i3, row;
        o2 = $5.extend({}, this.options, options);
        for (i3 = 0; i3 < array.length; i3++) {
          row = array[i3];
          if (typeof row !== "object") {
            data += row + o2.csvNewLine;
          } else {
            $5.each(row, function(key, val) {
              data += (key ? o2.csvDelimiter : "") + val.toString();
            });
            data += o2.csvNewLine;
          }
        }
        if (Utils.isValue(filename)) {
          return this.createDownload(this.base64("\uFEFF" + data), "application/csv", filename);
        }
        return data;
      }
    };
    Metro2.export = Export.init();
    if (globalThis.METRO_GLOBAL_COMMON === true) {
      globalThis.Export = Metro2.export;
    }
  })(Metro, Dom);

  // source/components/file/file.js
  (function(Metro2, $5) {
    "use strict";
    let FileDefaultConfig = {
      fileDeferred: 0,
      label: "",
      mode: "input",
      buttonTitle: "",
      filesSelectedTitle: "",
      dropTitle: "",
      dropIcon: "\u{1F4E5}",
      clearButtonIcon: "\u274C",
      prepend: "",
      clsComponent: "",
      clsPrepend: "",
      clsButton: "",
      clsCaption: "",
      clsLabel: "",
      onSelect: Metro2.noop,
      onFileCreate: Metro2.noop
    };
    Metro2.fileSetup = function(options) {
      FileDefaultConfig = $5.extend({}, FileDefaultConfig, options);
    };
    if (typeof globalThis["metroFileSetup"] !== "undefined") {
      Metro2.fileSetup(globalThis["metroFileSetup"]);
    }
    Metro2.Component("file", {
      init: function(options, elem) {
        this._super(elem, options, FileDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("file-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        const container = element2.wrap("<div>").addClass((o2.mode === "input" ? " file " : o2.mode === "button" ? " file-button " : " drop-zone ") + element2[0].className).addClass(o2.clsComponent);
        const caption = $5("<span>").addClass("caption").addClass(o2.clsCaption);
        const files = $5("<span>").addClass("files").addClass(o2.clsCaption);
        let icon, button;
        if (o2.mode.includes("drop")) {
          icon = $5("<span>").addClass("icon").html(o2.dropIcon).appendTo(container);
          caption.html(o2.dropTitle || this.strings.label_drop_file).insertAfter(icon);
          files.html((o2.filesSelectedTitle || this.strings.label_files_selected).replace("{n}", 0)).insertAfter(caption);
          button = $5("<button>").addClass("button clear-button square").html(o2.clearButtonIcon).appendTo(container);
        } else {
          caption.insertBefore(element2);
          button = $5("<button>").addClass("button select-files-button").attr("tabindex", -1).html(o2.buttonTitle || this.strings.label_choose_file);
          button.appendTo(container);
          button.addClass(o2.clsButton);
          if (container.hasClass("input-small")) {
            button.addClass("small");
          }
          if (element2.attr("dir") === "rtl") {
            container.addClass("rtl");
          }
          if (o2.prepend !== "") {
            const prepend = $5("<div>").html(o2.prepend);
            prepend.addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
          }
        }
        element2[0].className = "";
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(container);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const container = element2.closest("label");
        const caption = container.find(".caption");
        const files = container.find(".files");
        const form = element2.closest("form");
        if (form.length) {
          form.on("reset", function() {
            that.clear();
          });
        }
        container.on(Metro2.events.click, ".select-files-button", function() {
          element2[0].click();
        });
        container.on(Metro2.events.click, ".clear-button", function() {
          that.clear();
        });
        element2.on(Metro2.events.change, function() {
          const fi = this;
          const file_names = [];
          let entry;
          Array.from(fi.files).forEach(function(file) {
            file_names.push(file.name);
          });
          if (o2.mode === "input") {
            entry = file_names.join(", ");
            caption.html(entry);
            caption.attr("title", entry);
          } else {
            files.html((o2.filesSelectedTitle || that.strings.label_files_selected).replace("{n}", element2[0].files.length));
          }
          that._fireEvent("select", {
            files: fi.files
          });
        });
        element2.on(Metro2.events.focus, function() {
          container.addClass("focused");
        });
        element2.on(Metro2.events.blur, function() {
          container.removeClass("focused");
        });
        if (o2.mode !== "input") {
          container.on("drag dragstart dragend dragover dragenter dragleave drop", function(e2) {
            e2.preventDefault();
          });
          container.on("dragenter dragover", function() {
            container.addClass("drop-on");
          });
          container.on("dragleave", function() {
            container.removeClass("drop-on");
          });
          container.on("drop", function(e2) {
            element2[0].files = e2.dataTransfer.files;
            files.html((o2.filesSelectedTitle || that.strings.label_files_selected).replace("{n}", element2[0].files.length));
            container.removeClass("drop-on");
            element2.trigger("change");
          });
        }
      },
      clear: function() {
        const element2 = this.element, o2 = this.options;
        if (o2.mode === "input") {
          element2.siblings(".caption").html("");
        } else {
          element2.siblings(".files").html((o2.filesSelectedTitle || this.strings.label_files_selected).replace("{n}", 0));
        }
        element2[0].value = "";
        element2.trigger("change");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      toggleDir: function() {
        if (this.element.attr("dir") === "rtl") {
          this.element.parent().addClass("rtl");
        } else {
          this.element.parent().removeClass("rtl");
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
          case "dir":
            this.toggleDir();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        const parent2 = element2.parent();
        element2.off(Metro2.events.change);
        parent2.off(Metro2.events.click, "button");
        if (o2.label) {
          parent2.prev("label").remove();
        }
        parent2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/gauge/gauge.js
  (function(Metro2, $5) {
    "use strict";
    let GaugeDefaultConfig = {
      min: 0,
      max: 100,
      value: 0,
      size: 0,
      labelMin: "",
      labelMax: "",
      label: "",
      suffix: "",
      values: 10,
      segments: 10,
      startAngle: 235,
      range: 250,
      theme: "",
      onGaugeCreate: Metro2.noop
    };
    Metro2.gaugeSetup = function(options) {
      GaugeDefaultConfig = $5.extend({}, GaugeDefaultConfig, options);
    };
    if (typeof globalThis["metroGaugeSetup"] !== "undefined") {
      Metro2.gaugeSetup(globalThis["metroGaugeSetup"]);
    }
    Metro2.Component("gauge", {
      init: function(options, elem) {
        this._super(elem, options, GaugeDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2[0].style.setProperty("--analog-gauge-segments", `${o2.segments}`);
        element2[0].style.setProperty("--analog-gauge-start-angle", `${o2.startAngle}deg`);
        element2[0].style.setProperty("--analog-gauge-range", `${o2.range}deg`);
        this.options.range = parseFloat(getComputedStyle(element2[0]).getPropertyValue("--analog-gauge-range"));
        this.options.start = parseFloat(getComputedStyle(element2[0]).getPropertyValue("--analog-gauge-start-angle"));
        this.options.defaultMark = 90;
        this.options.defaultNeedle = 270;
        this.options.minDegree = this.options.start - this.options.defaultNeedle;
        this._createStructure();
        this._createEvents();
        this.update();
        this._fireEvent("gauge-create");
      },
      _generateMarks: function() {
        const o2 = this.options;
        const values = ("" + o2.values).trim();
        if (values === "") return "";
        let t = values.toArray(",");
        let valueArray = [];
        let count;
        if (t.length === 1) {
          valueArray = Array.from(
            { length: +values },
            (_4, i3) => Math.round(o2.min + i3 * (o2.max - o2.min) / (+values - 1 || 1))
          );
          count = parseInt(values);
        } else {
          valueArray = [...t];
          count = t.length;
        }
        const degreeStep = o2.range / (count - 1 || 1);
        return `
                <ul class="value-marks">
                  ${valueArray.map((value, i3) => {
          const degree = o2.start - o2.defaultMark + i3 * degreeStep;
          return `<li style="--_d:${degree}deg" class="mark">${value}</li>`;
        }).join("")}
                </ul>
            `;
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.addClass("analog-gauge");
        if (o2.size) {
          element2.css({
            width: o2.size,
            height: o2.size
          });
        }
        element2.html(`
                <div class="gauge"></div>
                ${this._generateMarks()} 
                <div class="needle"></div> 
                <div class="value">${o2.value}</div> 
                <div class="label">${o2.label}</div> 
                <div class="label-min">${o2.labelMin}</div> 
                <div class="label-max">${o2.labelMax}</div> 
            `);
        if (o2.theme) {
          element2.addClass(`theme-${o2.theme}`);
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
      },
      val: function(value) {
        if (typeof value === "undefined") {
          return this.options.value;
        }
        this.options.value = value;
        this.update();
      },
      update: function() {
        const element2 = this.element, elem = this.elem, o2 = this.options;
        const normalizedValue = Math.max(o2.min, Math.min(o2.max, o2.value));
        const valuePercentage = (normalizedValue - o2.min) / (o2.max - o2.min);
        const degree = o2.minDegree + valuePercentage * o2.range;
        elem.style.setProperty("--analog-gauge-value", `${valuePercentage * o2.range}deg`);
        elem.style.setProperty("--_d", `${degree}deg`);
        element2.find(".value").html(o2.value + o2.suffix);
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/gradient-box/gradient-box.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var GradientBoxDefaultConfig = {
      gradientType: "linear",
      // linear, radial
      gradientShape: "",
      gradientPosition: "",
      gradientSize: "",
      gradientColors: "#000, #fff",
      gradientRepeat: false,
      onGradientBoxCreate: Metro2.noop
    };
    Metro2.gradientBoxSetup = function(options) {
      GradientBoxDefaultConfig = $5.extend(
        {},
        GradientBoxDefaultConfig,
        options
      );
    };
    if (typeof globalThis["metroGradientBoxSetup"] !== "undefined") {
      Metro2.gradientBoxSetup(globalThis["metroGradientBoxSetup"]);
    }
    Metro2.Component("gradient-box", {
      init: function(options, elem) {
        this._super(elem, options, GradientBoxDefaultConfig, {
          // define instance vars here
          colors: [],
          shape: "",
          size: "",
          position: "",
          type: "linear",
          func: "linear-gradient",
          repeat: false
        });
        return this;
      },
      _create: function() {
        var o2 = this.options;
        this.colors = o2.gradientColors.toArray(",");
        this.type = o2.gradientType.toLowerCase();
        this.shape = o2.gradientShape.toLowerCase();
        this.size = o2.gradientSize.toLowerCase();
        this.repeat = o2.gradientRepeat;
        this.func = (this.repeat ? "repeating-" : "") + this.type + "-gradient";
        if (this.type === "linear") {
          if (!o2.gradientPosition) {
            this.position = "to bottom";
          } else {
            this.position = isNaN(o2.gradientPosition) === false ? o2.gradientPosition + "deg" : o2.gradientPosition;
            if (this.position.indexOf("deg") === -1 && this.position.indexOf("to ") === -1) {
              this.position = "to " + this.position;
            }
          }
        } else {
          this.position = o2.gradientPosition.toLowerCase();
          if (this.position && this.position.indexOf("at ") === -1) {
            this.position = "at " + this.position;
          }
        }
        this._createStructure();
        this._setGradient();
        this._fireEvent("gradient-box-create");
      },
      _createStructure: function() {
        this.element.addClass("gradient-box");
      },
      _setGradient: function() {
        var element2 = this.element;
        var gradientRule, gradientOptions = [];
        if (this.type === "radial" && this.shape) {
          gradientOptions.push(this.shape);
        }
        if (this.type === "radial" && this.size) {
          gradientOptions.push(this.size);
        }
        if (this.position) {
        }
        gradientRule = this.func + "(" + (gradientOptions.length ? gradientOptions.join(" ") + ", " : "") + this.colors.join(", ") + ")";
        element2.css({
          background: gradientRule
        });
      },
      changeAttribute: function(attr, newValue) {
        if (attr.indexOf("data-gradient-") === -1) {
          return;
        }
        switch (attr) {
          case "data-gradient-type":
            this.type = newValue;
            this.func = newValue.toLowerCase() + "-gradient";
            break;
          case "data-gradient-colors-css":
            this.colors = newValue ? newValue.toArray(",") : ["#fff", "#000"];
            break;
          case "data-gradient-shape":
            this.shape = newValue.toLowerCase();
            break;
          case "data-gradient-size":
            this.size = newValue.toLowerCase();
            break;
          case "data-gradient-position":
            this.position = newValue.toLowerCase();
            break;
          case "data-gradient-repeat":
            this.repeat = Utils.bool(newValue);
            break;
        }
        this._setGradient();
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/md5/md5.js
  (function(Metro2) {
    "use strict";
    Metro2.md5 = function(string) {
      function RotateLeft(lValue, iShiftBits) {
        return lValue << iShiftBits | lValue >>> 32 - iShiftBits;
      }
      function AddUnsigned(lX, lY) {
        var lX4, lY4, lX8, lY8, lResult;
        lX8 = lX & 2147483648;
        lY8 = lY & 2147483648;
        lX4 = lX & 1073741824;
        lY4 = lY & 1073741824;
        lResult = (lX & 1073741823) + (lY & 1073741823);
        if (lX4 & lY4) {
          return lResult ^ 2147483648 ^ lX8 ^ lY8;
        }
        if (lX4 | lY4) {
          if (lResult & 1073741824) {
            return lResult ^ 3221225472 ^ lX8 ^ lY8;
          } else {
            return lResult ^ 1073741824 ^ lX8 ^ lY8;
          }
        } else {
          return lResult ^ lX8 ^ lY8;
        }
      }
      function F4(x5, y3, z4) {
        return x5 & y3 | ~x5 & z4;
      }
      function G5(x5, y3, z4) {
        return x5 & z4 | y3 & ~z4;
      }
      function H4(x5, y3, z4) {
        return x5 ^ y3 ^ z4;
      }
      function I4(x5, y3, z4) {
        return y3 ^ (x5 | ~z4);
      }
      function FF(a4, b5, c4, d4, x5, s3, ac) {
        a4 = AddUnsigned(a4, AddUnsigned(AddUnsigned(F4(b5, c4, d4), x5), ac));
        return AddUnsigned(RotateLeft(a4, s3), b5);
      }
      function GG(a4, b5, c4, d4, x5, s3, ac) {
        a4 = AddUnsigned(a4, AddUnsigned(AddUnsigned(G5(b5, c4, d4), x5), ac));
        return AddUnsigned(RotateLeft(a4, s3), b5);
      }
      function HH(a4, b5, c4, d4, x5, s3, ac) {
        a4 = AddUnsigned(a4, AddUnsigned(AddUnsigned(H4(b5, c4, d4), x5), ac));
        return AddUnsigned(RotateLeft(a4, s3), b5);
      }
      function II(a4, b5, c4, d4, x5, s3, ac) {
        a4 = AddUnsigned(a4, AddUnsigned(AddUnsigned(I4(b5, c4, d4), x5), ac));
        return AddUnsigned(RotateLeft(a4, s3), b5);
      }
      function ConvertToWordArray(string2) {
        var lWordCount;
        var lMessageLength = string2.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while (lByteCount < lMessageLength) {
          lWordCount = (lByteCount - lByteCount % 4) / 4;
          lBytePosition = lByteCount % 4 * 8;
          lWordArray[lWordCount] = lWordArray[lWordCount] | string2.charCodeAt(lByteCount) << lBytePosition;
          lByteCount++;
        }
        lWordCount = (lByteCount - lByteCount % 4) / 4;
        lBytePosition = lByteCount % 4 * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | 128 << lBytePosition;
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
      }
      function WordToHex(lValue) {
        var WordToHexValue = "", WordToHexValue_temp = "", lByte, lCount;
        for (lCount = 0; lCount <= 3; lCount++) {
          lByte = lValue >>> lCount * 8 & 255;
          WordToHexValue_temp = "0" + lByte.toString(16);
          WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
        }
        return WordToHexValue;
      }
      function Utf8Encode(string2) {
        string2 = string2.replace(/\r\n/g, "\n");
        var utftext = "";
        for (var n2 = 0; n2 < string2.length; n2++) {
          var c4 = string2.charCodeAt(n2);
          if (c4 < 128) {
            utftext += String.fromCharCode(c4);
          } else if (c4 > 127 && c4 < 2048) {
            utftext += String.fromCharCode(c4 >> 6 | 192);
            utftext += String.fromCharCode(c4 & 63 | 128);
          } else {
            utftext += String.fromCharCode(c4 >> 12 | 224);
            utftext += String.fromCharCode(c4 >> 6 & 63 | 128);
            utftext += String.fromCharCode(c4 & 63 | 128);
          }
        }
        return utftext;
      }
      var x4 = [];
      var k4, AA, BB, CC, DD, a3, b4, c3, d3;
      var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
      var S21 = 5, S22 = 9, S23 = 14, S24 = 20;
      var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
      var S41 = 6, S42 = 10, S43 = 15, S44 = 21;
      string = Utf8Encode(string);
      x4 = ConvertToWordArray(string);
      a3 = 1732584193;
      b4 = 4023233417;
      c3 = 2562383102;
      d3 = 271733878;
      for (k4 = 0; k4 < x4.length; k4 += 16) {
        AA = a3;
        BB = b4;
        CC = c3;
        DD = d3;
        a3 = FF(a3, b4, c3, d3, x4[k4], S11, 3614090360);
        d3 = FF(d3, a3, b4, c3, x4[k4 + 1], S12, 3905402710);
        c3 = FF(c3, d3, a3, b4, x4[k4 + 2], S13, 606105819);
        b4 = FF(b4, c3, d3, a3, x4[k4 + 3], S14, 3250441966);
        a3 = FF(a3, b4, c3, d3, x4[k4 + 4], S11, 4118548399);
        d3 = FF(d3, a3, b4, c3, x4[k4 + 5], S12, 1200080426);
        c3 = FF(c3, d3, a3, b4, x4[k4 + 6], S13, 2821735955);
        b4 = FF(b4, c3, d3, a3, x4[k4 + 7], S14, 4249261313);
        a3 = FF(a3, b4, c3, d3, x4[k4 + 8], S11, 1770035416);
        d3 = FF(d3, a3, b4, c3, x4[k4 + 9], S12, 2336552879);
        c3 = FF(c3, d3, a3, b4, x4[k4 + 10], S13, 4294925233);
        b4 = FF(b4, c3, d3, a3, x4[k4 + 11], S14, 2304563134);
        a3 = FF(a3, b4, c3, d3, x4[k4 + 12], S11, 1804603682);
        d3 = FF(d3, a3, b4, c3, x4[k4 + 13], S12, 4254626195);
        c3 = FF(c3, d3, a3, b4, x4[k4 + 14], S13, 2792965006);
        b4 = FF(b4, c3, d3, a3, x4[k4 + 15], S14, 1236535329);
        a3 = GG(a3, b4, c3, d3, x4[k4 + 1], S21, 4129170786);
        d3 = GG(d3, a3, b4, c3, x4[k4 + 6], S22, 3225465664);
        c3 = GG(c3, d3, a3, b4, x4[k4 + 11], S23, 643717713);
        b4 = GG(b4, c3, d3, a3, x4[k4], S24, 3921069994);
        a3 = GG(a3, b4, c3, d3, x4[k4 + 5], S21, 3593408605);
        d3 = GG(d3, a3, b4, c3, x4[k4 + 10], S22, 38016083);
        c3 = GG(c3, d3, a3, b4, x4[k4 + 15], S23, 3634488961);
        b4 = GG(b4, c3, d3, a3, x4[k4 + 4], S24, 3889429448);
        a3 = GG(a3, b4, c3, d3, x4[k4 + 9], S21, 568446438);
        d3 = GG(d3, a3, b4, c3, x4[k4 + 14], S22, 3275163606);
        c3 = GG(c3, d3, a3, b4, x4[k4 + 3], S23, 4107603335);
        b4 = GG(b4, c3, d3, a3, x4[k4 + 8], S24, 1163531501);
        a3 = GG(a3, b4, c3, d3, x4[k4 + 13], S21, 2850285829);
        d3 = GG(d3, a3, b4, c3, x4[k4 + 2], S22, 4243563512);
        c3 = GG(c3, d3, a3, b4, x4[k4 + 7], S23, 1735328473);
        b4 = GG(b4, c3, d3, a3, x4[k4 + 12], S24, 2368359562);
        a3 = HH(a3, b4, c3, d3, x4[k4 + 5], S31, 4294588738);
        d3 = HH(d3, a3, b4, c3, x4[k4 + 8], S32, 2272392833);
        c3 = HH(c3, d3, a3, b4, x4[k4 + 11], S33, 1839030562);
        b4 = HH(b4, c3, d3, a3, x4[k4 + 14], S34, 4259657740);
        a3 = HH(a3, b4, c3, d3, x4[k4 + 1], S31, 2763975236);
        d3 = HH(d3, a3, b4, c3, x4[k4 + 4], S32, 1272893353);
        c3 = HH(c3, d3, a3, b4, x4[k4 + 7], S33, 4139469664);
        b4 = HH(b4, c3, d3, a3, x4[k4 + 10], S34, 3200236656);
        a3 = HH(a3, b4, c3, d3, x4[k4 + 13], S31, 681279174);
        d3 = HH(d3, a3, b4, c3, x4[k4], S32, 3936430074);
        c3 = HH(c3, d3, a3, b4, x4[k4 + 3], S33, 3572445317);
        b4 = HH(b4, c3, d3, a3, x4[k4 + 6], S34, 76029189);
        a3 = HH(a3, b4, c3, d3, x4[k4 + 9], S31, 3654602809);
        d3 = HH(d3, a3, b4, c3, x4[k4 + 12], S32, 3873151461);
        c3 = HH(c3, d3, a3, b4, x4[k4 + 15], S33, 530742520);
        b4 = HH(b4, c3, d3, a3, x4[k4 + 2], S34, 3299628645);
        a3 = II(a3, b4, c3, d3, x4[k4], S41, 4096336452);
        d3 = II(d3, a3, b4, c3, x4[k4 + 7], S42, 1126891415);
        c3 = II(c3, d3, a3, b4, x4[k4 + 14], S43, 2878612391);
        b4 = II(b4, c3, d3, a3, x4[k4 + 5], S44, 4237533241);
        a3 = II(a3, b4, c3, d3, x4[k4 + 12], S41, 1700485571);
        d3 = II(d3, a3, b4, c3, x4[k4 + 3], S42, 2399980690);
        c3 = II(c3, d3, a3, b4, x4[k4 + 10], S43, 4293915773);
        b4 = II(b4, c3, d3, a3, x4[k4 + 1], S44, 2240044497);
        a3 = II(a3, b4, c3, d3, x4[k4 + 8], S41, 1873313359);
        d3 = II(d3, a3, b4, c3, x4[k4 + 15], S42, 4264355552);
        c3 = II(c3, d3, a3, b4, x4[k4 + 6], S43, 2734768916);
        b4 = II(b4, c3, d3, a3, x4[k4 + 13], S44, 1309151649);
        a3 = II(a3, b4, c3, d3, x4[k4 + 4], S41, 4149444226);
        d3 = II(d3, a3, b4, c3, x4[k4 + 11], S42, 3174756917);
        c3 = II(c3, d3, a3, b4, x4[k4 + 2], S43, 718787259);
        b4 = II(b4, c3, d3, a3, x4[k4 + 9], S44, 3951481745);
        a3 = AddUnsigned(a3, AA);
        b4 = AddUnsigned(b4, BB);
        c3 = AddUnsigned(c3, CC);
        d3 = AddUnsigned(d3, DD);
      }
      var temp = WordToHex(a3) + WordToHex(b4) + WordToHex(c3) + WordToHex(d3);
      return temp.toLowerCase();
    };
    if (globalThis.METRO_GLOBAL_COMMON === true) {
      globalThis.md5 = Metro2.md5;
    }
  })(Metro, Dom);

  // source/components/gravatar/gravatar.js
  (function(Metro2, $5) {
    "use strict";
    var GravatarDefaultConfig = {
      gravatarDeferred: 0,
      email: "",
      size: 80,
      default: "mp",
      onGravatarCreate: Metro2.noop
    };
    Metro2.gravatarSetup = function(options) {
      GravatarDefaultConfig = $5.extend({}, GravatarDefaultConfig, options);
    };
    if (typeof globalThis["metroGravatarSetup"] !== "undefined") {
      Metro2.gravatarSetup(globalThis["metroGravatarSetup"]);
    }
    Metro2.Component("gravatar", {
      init: function(options, elem) {
        this._super(elem, options, GravatarDefaultConfig);
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this.get();
        this._fireEvent("gravatar-create", {
          element: element2
        });
      },
      getImage: function(email, size, def, is_object) {
        var image = $5("<img>").attr("alt", email);
        image.attr("src", this.getImageSrc(email, size));
        return is_object === true ? image : image[0];
      },
      getImageSrc: function(email, size, def) {
        if (email === void 0 || email.trim() === "") {
          return "";
        }
        size = size || 80;
        def = Metro2.utils.encodeURI(def) || "404";
        return "//www.gravatar.com/avatar/" + Metro2.md5(email.toLowerCase().trim()) + "?size=" + size + "&d=" + def;
      },
      get: function() {
        var element2 = this.element, o2 = this.options;
        var img = element2[0].tagName === "IMG" ? element2 : element2.find("img");
        if (img.length === 0) {
          return;
        }
        img.attr("src", this.getImageSrc(o2.email, o2.size, o2.default));
        return this;
      },
      resize: function(new_size) {
        this.options.size = new_size !== void 0 ? new_size : this.element.attr("data-size");
        this.get();
      },
      email: function(new_email) {
        this.options.email = new_email !== void 0 ? new_email : this.element.attr("data-email");
        this.get();
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-size":
            this.resize();
            break;
          case "data-email":
            this.email();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/hint/hint.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var HintDefaultConfig = {
      hintDeferred: 0,
      hintHide: 5e3,
      clsHint: "",
      hintText: "",
      hintPosition: Metro2.position.TOP,
      hintOffset: 4,
      onHintShow: Metro2.noop,
      onHintHide: Metro2.noop,
      onHintCreate: Metro2.noop
    };
    Metro2.hintSetup = function(options) {
      HintDefaultConfig = $5.extend({}, HintDefaultConfig, options);
    };
    if (typeof globalThis["metroHintSetup"] !== "undefined") {
      Metro2.hintSetup(globalThis["metroHintSetup"]);
    }
    Metro2.Component("hint", {
      init: function(options, elem) {
        this._super(elem, options, HintDefaultConfig, {
          hint: null,
          hint_size: {
            width: 0,
            height: 0
          },
          id: Utils.elementId("hint")
        });
        return this;
      },
      _create: function() {
        this._createEvents();
        this._fireEvent("hint-create", {
          element: this.element
        });
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var over = false;
        element2.on(Metro2.events.enter, function() {
          over = true;
          setTimeout(function() {
            if (!over) return;
            that.createHint();
            if (+o2.hintHide > 0) {
              setTimeout(function() {
                that.removeHint();
              }, o2.hintHide);
            }
          }, o2.hintDeferred);
        });
        element2.on(Metro2.events.leave, function() {
          over = false;
          that.removeHint();
        });
        $5(globalThis).on(Metro2.events.scroll + " " + Metro2.events.resize, function() {
          if (that.hint !== null) that.setPosition();
        }, { ns: this.id });
      },
      createHint: function() {
        var elem = this.elem, element2 = this.element, o2 = this.options;
        var hint = $5("<div>").addClass("hint").addClass(o2.clsHint).html(o2.hintText);
        this.hint = hint;
        this.hint_size = Utils.hiddenElementSize(hint);
        $5(".hint:not(.permanent-hint)").remove();
        if (elem.tagName === "TD" || elem.tagName === "TH") {
          var wrp = $5("<div/>").css("display", "inline-block").html(element2.html());
          element2.html(wrp);
          this.element = wrp;
        }
        this.setPosition();
        hint.appendTo($5("body"));
        this._fireEvent("hint-show", {
          hint: hint[0]
        });
      },
      setPosition: function() {
        var hint = this.hint, hint_size = this.hint_size, o2 = this.options, element2 = this.element;
        if (o2.hintPosition === Metro2.position.BOTTOM) {
          hint.addClass("bottom");
          hint.css({
            top: element2.offset().top - $5(globalThis).scrollTop() + element2.outerHeight() + o2.hintOffset,
            left: element2.offset().left + element2.outerWidth() / 2 - hint_size.width / 2 - $5(globalThis).scrollLeft()
          });
        } else if (o2.hintPosition === Metro2.position.RIGHT) {
          hint.addClass("right");
          hint.css({
            top: element2.offset().top + element2.outerHeight() / 2 - hint_size.height / 2 - $5(globalThis).scrollTop(),
            left: element2.offset().left + element2.outerWidth() - $5(globalThis).scrollLeft() + o2.hintOffset
          });
        } else if (o2.hintPosition === Metro2.position.LEFT) {
          hint.addClass("left");
          hint.css({
            top: element2.offset().top + element2.outerHeight() / 2 - hint_size.height / 2 - $5(globalThis).scrollTop(),
            left: element2.offset().left - hint_size.width - $5(globalThis).scrollLeft() - o2.hintOffset
          });
        } else {
          hint.addClass("top");
          hint.css({
            top: element2.offset().top - $5(globalThis).scrollTop() - hint_size.height - o2.hintOffset,
            left: element2.offset().left - $5(globalThis).scrollLeft() + element2.outerWidth() / 2 - hint_size.width / 2
          });
        }
      },
      removeHint: function() {
        var that = this;
        var hint = this.hint;
        var options = this.options;
        var timeout = options.onHintHide === Metro2.noop ? 0 : 300;
        if (hint !== null) {
          this._fireEvent("hint-hide", {
            hint: hint[0]
          });
          setTimeout(function() {
            hint.hide(0, function() {
              hint.remove();
              that.hint = null;
            });
          }, timeout);
        }
      },
      changeText: function() {
        this.options.hintText = this.element.attr("data-hint-text");
      },
      changeAttribute: function(attributeName) {
        if (attributeName === "data-hint-text") {
          this.changeText();
        }
      },
      destroy: function() {
        var element2 = this.element;
        this.removeHint();
        element2.off(Metro2.events.enter + "-hint");
        element2.off(Metro2.events.leave + "-hint");
        $5(globalThis).off(Metro2.events.scroll + "-hint");
      }
    });
  })(Metro, Dom);

  // source/components/hotkey/hotkey.js
  (function(Metro2, $5) {
    "use strict";
    const Hotkey = {
      specialKeys: {
        8: "backspace",
        9: "tab",
        13: "return",
        16: "shift",
        17: "ctrl",
        18: "alt",
        19: "pause",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "del",
        96: "0",
        97: "1",
        98: "2",
        99: "3",
        100: "4",
        101: "5",
        102: "6",
        103: "7",
        104: "8",
        105: "9",
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        112: "f1",
        113: "f2",
        114: "f3",
        115: "f4",
        116: "f5",
        117: "f6",
        118: "f7",
        119: "f8",
        120: "f9",
        121: "f10",
        122: "f11",
        123: "f12",
        144: "numlock",
        145: "scroll",
        188: ",",
        190: ".",
        191: "/",
        224: "meta"
      },
      shiftNums: {
        "~": "`",
        "!": "1",
        "@": "2",
        "#": "3",
        "$": "4",
        "%": "5",
        "^": "6",
        "&": "7",
        "*": "8",
        "(": "9",
        ")": "0",
        "_": "-",
        "+": "=",
        ":": ";",
        '"': "'",
        "<": ",",
        ">": ".",
        "?": "/",
        "|": "\\"
      },
      shiftNumsInverse: {
        "`": "~",
        "1": "!",
        "2": "@",
        "3": "#",
        "4": "$",
        "5": "%",
        "6": "^",
        "7": "&",
        "8": "*",
        "9": "(",
        "0": ")",
        "-": "_",
        "=": "+",
        ";": ": ",
        "'": '"',
        ",": "<",
        ".": ">",
        "/": "?",
        "\\": "|"
      },
      textAcceptingInputTypes: [
        "text",
        "password",
        "number",
        "email",
        "url",
        "range",
        "date",
        "month",
        "week",
        "time",
        "datetime",
        "datetime-local",
        "search",
        "color",
        "tel"
      ],
      getKey: function(e2) {
        let key, k4 = e2.keyCode, char = String.fromCharCode(k4).toLowerCase();
        if (e2.shiftKey) {
          key = Hotkey.shiftNums[char] ? Hotkey.shiftNums[char] : char;
        } else {
          key = Hotkey.specialKeys[k4] === void 0 ? char : Hotkey.specialKeys[k4];
        }
        return Hotkey.getModifier(e2).length ? Hotkey.getModifier(e2).join("+") + "+" + key : key;
      },
      getModifier: function(e2) {
        const m4 = [];
        if (e2.altKey) {
          m4.push("alt");
        }
        if (e2.ctrlKey || e2.metaKey) {
          m4.push("ctrl");
        }
        if (e2.shiftKey) {
          m4.push("shift");
        }
        return m4;
      }
    };
    function bindKey(key, fn) {
      return this.each(function() {
        $5(this).on(Metro2.events.keydown + ".hotkey-method-" + key, function(e2) {
          if (e2.repeat) return;
          const _key = Hotkey.getKey(e2);
          const el = $5(this);
          const href = "" + el.attr("href");
          if (key !== _key) {
            return;
          }
          if (el.is("a")) {
            if (href && href.trim() !== "#") {
              globalThis.location.href = href;
            }
          }
          Metro2.utils.exec(fn, [e2, _key, key], this);
        });
      });
    }
    $5.fn.hotkey = bindKey;
    if (globalThis["METRO_JQUERY"] && globalThis["jquery_present"]) {
      globalThis["jQuery"].fn.hotkey = bindKey;
    }
    $5(document).on(Metro2.events.keydown + ".hotkey-data", function(e2) {
      let el, fn, key, href;
      if (METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS && /textarea|input|select/i.test(e2.target.nodeName) || METRO_HOTKEYS_FILTER_CONTENT_EDITABLE && $5(e2.target).attr("contenteditable") || METRO_HOTKEYS_FILTER_TEXT_INPUTS && Hotkey.textAcceptingInputTypes.indexOf(e2.target.type) > -1) {
        return;
      }
      key = Hotkey.getKey(e2);
      if (Metro2.utils.keyInObject(Metro2.hotkeys, key)) {
        el = $5(Metro2.hotkeys[key][0]);
        fn = Metro2.hotkeys[key][1];
        href = ("" + el.attr("href")).trim();
        if (e2.repeat && !el.attr("data-repeat")) {
          return;
        }
        e2.preventDefault();
        if (fn) {
          Metro2.utils.exec(fn);
        } else {
          if (el.is("a") && href && href.length > 0 && href.trim() !== "#") {
            globalThis.location.href = href;
          } else {
            el[0].click();
          }
        }
      }
    });
  })(Metro, Dom);

  // source/components/html-container/html-container.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var HtmlContainerDefaultConfig = {
      htmlcontainerDeferred: 0,
      method: "get",
      htmlSource: null,
      requestData: null,
      requestOptions: null,
      insertMode: "default",
      // replace, append, prepend
      onHtmlLoad: Metro2.noop,
      onHtmlLoadFail: Metro2.noop,
      onHtmlLoadDone: Metro2.noop,
      onHtmlContainerCreate: Metro2.noop
    };
    Metro2.htmlContainerSetup = function(options) {
      HtmlContainerDefaultConfig = $5.extend({}, HtmlContainerDefaultConfig, options);
    };
    if (typeof globalThis["metroHtmlContainerSetup"] !== "undefined") {
      Metro2.htmlContainerSetup(globalThis["metroHtmlContainerSetup"]);
    }
    Metro2.Component("html-container", {
      init: function(options, elem) {
        this._super(elem, options, HtmlContainerDefaultConfig, {
          data: null,
          opt: {},
          htmlSource: ""
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        if (typeof o2.requestData === "string") {
          o2.requestData = JSON.parse(o2.requestData);
        }
        if (Utils.isObject(o2.requestData)) {
          this.data = Utils.isObject(o2.requestData);
        }
        if (typeof o2.requestOptions === "string") {
          o2.requestOptions = JSON.parse(o2.requestOptions);
        }
        if (Utils.isObject(o2.requestOptions)) {
          this.opt = Utils.isObject(o2.requestOptions);
        }
        o2.method = o2.method.toUpperCase();
        if (Utils.isValue(o2.htmlSource)) {
          this.htmlSource = o2.htmlSource;
          this._load();
        }
        this._fireEvent("html-container-create", {
          element: element2
        });
      },
      _load: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var fetchData = {
          method: o2.method
        };
        if (this.data) fetchData["body"] = this.data;
        if (this.opt) fetchData["headers"] = this.opt;
        fetch(this.htmlSource, fetchData).then(Metro2.fetch.status).then(Metro2.fetch.text).then(function(data) {
          var _data = $5(data);
          if (_data.length === 0) {
            _data = $5("<div>").html(data);
          }
          switch (o2.insertMode.toLowerCase()) {
            case "prepend":
              element2.prepend(_data);
              break;
            case "append":
              element2.append(_data);
              break;
            case "replace":
              _data.insertBefore(element2).script();
              element2.remove();
              break;
            default: {
              element2.html(_data);
            }
          }
          that._fireEvent("html-load", {
            data,
            source: o2.htmlSource,
            requestData: that.data,
            requestOptions: that.opt
          });
        }).catch(function(error) {
          that._fireEvent("html-load-fail", {
            error
          });
        });
      },
      load: function(source, data, opt2) {
        if (source) {
          this.htmlSource = source;
        }
        if (data) {
          this.data = Utils.isObject(data);
        }
        if (opt2) {
          this.opt = Utils.isObject(opt2);
        }
        this._load();
      },
      changeAttribute: function(attributeName) {
        var that = this, element2 = this.element, o2 = this.options;
        var changeHTMLSource = function() {
          var html = element2.attr("data-html-source");
          if (Utils.isNull(html)) {
            return;
          }
          if (html.trim() === "") {
            element2.html("");
          }
          o2.htmlSource = html;
          that._load();
        };
        var changeInsertMode = function() {
          var attr = element2.attr("data-insert-mode");
          if (Utils.isValue(attr)) {
            o2.insertMode = attr;
          }
        };
        var changeRequestData = function() {
          var data = element2.attr("data-request-data");
          that.load(o2.htmlSource, data);
        };
        switch (attributeName) {
          case "data-html-source":
            changeHTMLSource();
            break;
          case "data-insert-mode":
            changeInsertMode();
            break;
          case "data-request-data":
            changeRequestData();
            break;
        }
      },
      destroy: function() {
      }
    });
  })(Metro, Dom);

  // source/components/image-box/image-box.js
  (function(Metro2, $5) {
    "use strict";
    var ImageBoxDefaultConfig = {
      image: null,
      size: "cover",
      repeat: false,
      color: "transparent",
      attachment: "scroll",
      origin: "border",
      onImageBoxCreate: Metro2.noop
    };
    Metro2.imageBoxSetup = function(options) {
      ImageBoxDefaultConfig = $5.extend({}, ImageBoxDefaultConfig, options);
    };
    if (typeof globalThis["metroImageBoxSetup"] !== "undefined") {
      Metro2.imageBoxSetup(globalThis["metroImageBoxSetup"]);
    }
    Metro2.Component("image-box", {
      init: function(options, elem) {
        this._super(elem, options, ImageBoxDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._fireEvent("image-box-create");
      },
      _createStructure: function() {
        var element2 = this.element;
        element2.addClass("image-box");
        this._drawImage();
      },
      _drawImage: function() {
        var element2 = this.element, o2 = this.options;
        var image = new Image();
        var portrait;
        if (!element2.attr("data-original"))
          element2.attr("data-original", o2.image);
        element2.css({
          backgroundImage: "url(" + o2.image + ")",
          backgroundSize: o2.size,
          backgroundRepeat: o2.repeat ? "repeat" : "no-repeat",
          backgroundColor: o2.color,
          backgroundAttachment: o2.attachment,
          backgroundOrigin: o2.origin
        });
        image.src = o2.image;
        image.onload = function() {
          portrait = this.height >= this.width;
          element2.removeClass("image-box__portrait image-box__landscape").addClass("image-box__" + (portrait ? "portrait" : "landscape"));
        };
      },
      changeAttribute: function(attr, newValue) {
        var attrName = attr.replace("data-", "");
        if (["image", "size", "repeat", "color", "attachment", "origin"].indexOf(attrName) > -1) {
          this.options[attrName] = newValue;
          this._drawImage();
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/image-compare/image-compare.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var ImageCompareDefaultConfig = {
      imagecompareDeferred: 0,
      width: "100%",
      height: "auto",
      onSliderMove: Metro2.noop,
      onImageCompareCreate: Metro2.noop
    };
    Metro2.imageCompareSetup = function(options) {
      ImageCompareDefaultConfig = $5.extend({}, ImageCompareDefaultConfig, options);
    };
    if (typeof globalThis["metroImageCompareSetup"] !== "undefined") {
      Metro2.imageCompareSetup(globalThis["metroImageCompareSetup"]);
    }
    Metro2.Component("image-compare", {
      init: function(options, elem) {
        this._super(elem, options, ImageCompareDefaultConfig, {
          id: Utils.elementId("image-compare")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("image-compare-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        var container, container_overlay, slider;
        var images, element_width, element_height;
        if (!Utils.isValue(element2.attr("id"))) {
          element2.attr("id", Utils.elementId("image-compare"));
        }
        element2.addClass("image-compare").css({
          width: o2.width
        });
        element_width = element2.width();
        switch (o2.height) {
          case "16/9":
            element_height = Utils.aspectRatioH(element_width, o2.height);
            break;
          case "21/9":
            element_height = Utils.aspectRatioH(element_width, o2.height);
            break;
          case "4/3":
            element_height = Utils.aspectRatioH(element_width, o2.height);
            break;
          case "auto":
            element_height = Utils.aspectRatioH(element_width, "16/9");
            break;
          default:
            element_height = o2.height;
        }
        element2.css({
          height: element_height
        });
        container = $5("<div>").addClass("image-container").appendTo(element2);
        container_overlay = $5("<div>").addClass("image-container-overlay").appendTo(element2).css({
          width: element_width / 2
        });
        slider = $5("<div>").addClass("image-slider").appendTo(element2);
        slider.css({
          top: element_height / 2 - slider.height() / 2,
          left: element_width / 2 - slider.width() / 2
        });
        images = element2.find("img");
        $5.each(images, function(i3) {
          var img = $5("<div>").addClass("image-wrapper");
          img.css({
            width: element_width,
            height: element_height,
            backgroundImage: "url(" + this.src + ")"
          });
          img.appendTo(i3 === 0 ? container : container_overlay);
        });
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var overlay = element2.find(".image-container-overlay");
        var slider = element2.find(".image-slider");
        slider.on(Metro2.events.startAll, function() {
          var w5 = element2.width();
          $5(document).on(Metro2.events.moveAll, function(e2) {
            var x4 = Utils.getCursorPositionX(element2[0], e2), left_pos;
            if (x4 < 0) x4 = 0;
            if (x4 > w5) x4 = w5;
            overlay.css({
              width: x4
            });
            left_pos = x4 - slider.width() / 2;
            slider.css({
              left: left_pos
            });
            that._fireEvent("slider-move", {
              x: x4,
              l: left_pos
            });
          }, { ns: that.id });
          $5(document).on(Metro2.events.stopAll, function() {
            $5(document).off(Metro2.events.moveAll, { ns: that.id });
            $5(document).off(Metro2.events.stopAll, { ns: that.id });
          }, { ns: that.id });
        });
        $5(globalThis).on(Metro2.events.resize, function() {
          var element_width = element2.width(), element_height;
          if (o2.width !== "100%") {
            return;
          }
          switch (o2.height) {
            case "16/9":
              element_height = Utils.aspectRatioH(element_width, o2.height);
              break;
            case "21/9":
              element_height = Utils.aspectRatioH(element_width, o2.height);
              break;
            case "4/3":
              element_height = Utils.aspectRatioH(element_width, o2.height);
              break;
            case "auto":
              element_height = Utils.aspectRatioH(element_width, "16/9");
              break;
            default:
              element_height = o2.height;
          }
          element2.css({
            height: element_height
          });
          $5.each(element2.find(".image-wrapper"), function() {
            $5(this).css({
              width: element_width,
              height: element_height
            });
          });
          element2.find(".image-container-overlay").css({
            width: element_width / 2
          });
          slider.css({
            top: element_height / 2 - slider.height() / 2,
            left: element_width / 2 - slider.width() / 2
          });
        }, { ns: this.id });
      },
      /* eslint-disable-next-line */
      changeAttribute: function(attributeName) {
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.start);
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/image-grid/image-grig.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var ImageGridDefaultConfig = {
      useBackground: false,
      backgroundSize: "cover",
      backgroundPosition: "top left",
      clsImageGrid: "",
      clsImageGridItem: "",
      clsImageGridImage: "",
      onItemClick: Metro2.noop,
      onDrawItem: Metro2.noop,
      onImageGridCreate: Metro2.noop
    };
    Metro2.imageGridSetup = function(options) {
      ImageGridDefaultConfig = $5.extend({}, ImageGridDefaultConfig, options);
    };
    if (typeof globalThis["metroImageGridSetup"] !== "undefined") {
      Metro2.imageGridSetup(globalThis["metroImageGridSetup"]);
    }
    Metro2.Component("image-grid", {
      init: function(options, elem) {
        this._super(elem, options, ImageGridDefaultConfig, {
          // define instance vars here
          items: []
        });
        return this;
      },
      _create: function() {
        this.items = this.element.children("img");
        this._createStructure();
        this._createEvents();
        this._fireEvent("image-grid-create");
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        element2.addClass("image-grid").addClass(o2.clsImageGrid);
        this._createItems();
      },
      _createEvents: function() {
        var that = this, element2 = this.element;
        element2.on(Metro2.events.click, ".image-grid__item", function() {
          that._fireEvent("item-click", {
            item: this
          });
        });
      },
      _createItems: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var items = this.items;
        element2.clear();
        items.each(function() {
          var el = $5(this);
          var src = this.src;
          var wrapper = $5("<div>").addClass("image-grid__item").addClass(o2.clsImageGridItem).appendTo(element2);
          var img = new Image();
          img.src = src;
          img.onload = function() {
            var port = this.height >= this.width;
            wrapper.addClass(port ? "image-grid__item-portrait" : "image-grid__item-landscape");
            el.addClass(o2.clsImageGridImage).appendTo(wrapper);
            if (o2.useBackground) {
              wrapper.css({
                background: "url(" + src + ")",
                backgroundRepeat: "no-repeat",
                backgroundSize: o2.backgroundSize,
                backgroundPosition: o2.backgroundPosition
              }).attr("data-original", el.attr("data-original") || src).attr("data-title", el.attr("alt") || el.attr("data-title") || "");
              el.visible(false);
            }
            that._fireEvent("draw-item", {
              item: wrapper[0],
              image: el[0]
            });
          };
        });
      },
      changeAttribute: function(attr, val) {
        var o2 = this.options;
        if (attr === "data-use-background") {
          o2.useBackground = Utils.bool(val);
          this._createItems();
        }
        if (attr === "data-background-size") {
          o2.backgroundSize = val;
          this._createItems();
        }
        if (attr === "data-background-position") {
          o2.backgroundPosition = val;
          this._createItems();
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/image-magnifier/image-magnifier.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var ImageMagnifierDefaultConfig = {
      imagemagnifierDeferred: 0,
      width: "100%",
      height: "auto",
      lensSize: 100,
      lensType: "square",
      // square, circle
      magnifierZoom: 2,
      magnifierMode: "glass",
      // glass, zoom
      magnifierZoomElement: null,
      clsMagnifier: "",
      clsLens: "",
      clsZoom: "",
      onMagnifierMove: Metro2.noop,
      onImageMagnifierCreate: Metro2.noop
    };
    Metro2.imageMagnifierSetup = function(options) {
      ImageMagnifierDefaultConfig = $5.extend({}, ImageMagnifierDefaultConfig, options);
    };
    if (typeof globalThis["metroImageMagnifierSetup"] !== "undefined") {
      Metro2.imageMagnifierSetup(globalThis["metroImageMagnifierSetup"]);
    }
    Metro2.Component("image-magnifier", {
      init: function(options, elem) {
        this._super(elem, options, ImageMagnifierDefaultConfig, {
          zoomElement: null,
          id: Utils.elementId("image-magnifier")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("image-magnifier-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        var magnifier, element_width, element_height;
        var image = element2.find("img");
        if (image.length === 0) {
          throw new Error("Image not defined");
        }
        if (!Utils.isValue(element2.attr("id"))) {
          element2.attr("id", Utils.elementId("image-magnifier"));
        }
        element2.addClass("image-magnifier").css({
          width: o2.width
        }).addClass(o2.clsMagnifier);
        element_width = element2.width();
        switch (o2.height) {
          case "16/9":
            element_height = Utils.aspectRatioH(element_width, o2.height);
            break;
          case "21/9":
            element_height = Utils.aspectRatioH(element_width, o2.height);
            break;
          case "4/3":
            element_height = Utils.aspectRatioH(element_width, o2.height);
            break;
          case "auto":
            element_height = Utils.aspectRatioH(element_width, "16/9");
            break;
          default:
            element_height = o2.height;
        }
        element2.css({
          height: element_height
        });
        var x4 = element_width / 2 - o2.lensSize / 2;
        var y3 = element_height / 2 - o2.lensSize / 2;
        if (o2.magnifierMode === "glass") {
          magnifier = $5("<div>").addClass("image-magnifier-glass").appendTo(element2);
          magnifier.css({
            width: o2.lensSize,
            height: o2.lensSize,
            borderRadius: o2.lensType !== "circle" ? 0 : "50%",
            top: y3,
            left: x4,
            backgroundImage: "url(" + image[0].src + ")",
            backgroundRepeat: "no-repeat",
            backgroundPosition: "-" + (x4 * o2.magnifierZoom - o2.lensSize / 4 + 4) + "px -" + (y3 * o2.magnifierZoom - o2.lensSize / 4 + 4) + "px",
            backgroundSize: image[0].width * o2.magnifierZoom + "px " + image[0].height * o2.magnifierZoom + "px"
          }).addClass(o2.clsLens);
        } else {
          magnifier = $5("<div>").addClass("image-magnifier-glass").appendTo(element2);
          magnifier.css({
            width: o2.lensSize,
            height: o2.lensSize,
            borderRadius: 0,
            borderWidth: 1,
            top: y3,
            left: x4
          }).addClass(o2.clsLens);
          if (!Utils.isValue(o2.magnifierZoomElement) || $5(o2.magnifierZoomElement).length === 0) {
            this.zoomElement = $5("<div>").insertAfter(element2);
          } else {
            this.zoomElement = $5(o2.magnifierZoomElement);
          }
          var zoom_element_width = magnifier[0].offsetWidth * o2.magnifierZoom;
          var zoom_element_height = magnifier[0].offsetHeight * o2.magnifierZoom;
          var cx = zoom_element_width / o2.lensSize;
          var cy = zoom_element_height / o2.lensSize;
          this.zoomElement.css({
            width: zoom_element_width,
            height: zoom_element_height,
            backgroundImage: "url(" + image[0].src + ")",
            backgroundRepeat: "no-repeat",
            backgroundPosition: "-" + x4 * cx + "px -" + y3 * cy + "px",
            backgroundSize: image[0].width * cx + "px " + image[0].height * cy + "px"
          }).addClass(o2.clsZoom);
        }
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var glass = element2.find(".image-magnifier-glass");
        var glass_size = glass[0].offsetWidth / 2;
        var image = element2.find("img")[0];
        var zoomElement = this.zoomElement;
        var cx, cy;
        $5(globalThis).on(Metro2.events.resize, function() {
          var x4 = element2.width() / 2 - o2.lensSize / 2;
          var y3 = element2.height() / 2 - o2.lensSize / 2;
          if (o2.magnifierMode === "glass") {
            glass.css({
              backgroundPosition: "-" + (x4 * o2.magnifierZoom - o2.lensSize / 4 + 4) + "px -" + (y3 * o2.magnifierZoom - o2.lensSize / 4 + 4) + "px",
              backgroundSize: image.width * o2.magnifierZoom + "px " + image.height * o2.magnifierZoom + "px"
            });
          }
        }, { ns: this.id });
        if (o2.magnifierMode !== "glass") {
          cx = zoomElement[0].offsetWidth / glass_size / 2;
          cy = zoomElement[0].offsetHeight / glass_size / 2;
          zoomElement.css({
            backgroundSize: image.width * cx + "px " + image.height * cy + "px"
          });
        }
        var lens_move = function(pos) {
          var x4, y3;
          var magic = 4, zoom = parseInt(o2.magnifierZoom);
          if (o2.magnifierMode === "glass") {
            x4 = pos.x;
            y3 = pos.y;
            if (x4 > image.width - glass_size / zoom) {
              x4 = image.width - glass_size / zoom;
            }
            if (x4 < glass_size / zoom) {
              x4 = glass_size / zoom;
            }
            if (y3 > image.height - glass_size / zoom) {
              y3 = image.height - glass_size / zoom;
            }
            if (y3 < glass_size / zoom) {
              y3 = glass_size / zoom;
            }
            glass.css({
              top: y3 - glass_size,
              left: x4 - glass_size,
              backgroundPosition: "-" + (x4 * zoom - glass_size + magic) + "px -" + (y3 * zoom - glass_size + magic) + "px"
            });
          } else {
            x4 = pos.x - glass_size;
            y3 = pos.y - glass_size;
            if (x4 > image.width - glass_size * 2) {
              x4 = image.width - glass_size * 2;
            }
            if (x4 < 0) {
              x4 = 0;
            }
            if (y3 > image.height - glass_size * 2) {
              y3 = image.height - glass_size * 2;
            }
            if (y3 < 0) {
              y3 = 0;
            }
            glass.css({
              top: y3,
              left: x4
            });
            zoomElement.css({
              backgroundPosition: "-" + x4 * cx + "px -" + y3 * cy + "px"
            });
          }
        };
        element2.on(Metro2.events.move, function(e2) {
          var pos = Utils.getCursorPosition(image, e2);
          lens_move(pos);
          that._fireEvent("magnifier-move", {
            pos,
            glass: glass[0],
            zoomElement: zoomElement ? zoomElement[0] : void 0
          });
          e2.preventDefault();
        });
        element2.on(Metro2.events.leave, function() {
          var x4 = element2.width() / 2 - o2.lensSize / 2;
          var y3 = element2.height() / 2 - o2.lensSize / 2;
          glass.animate({
            draw: {
              top: y3,
              left: x4
            }
          });
          lens_move({
            x: x4 + o2.lensSize / 2,
            y: y3 + o2.lensSize / 2
          });
        });
      },
      /* eslint-disable-next-line */
      changeAttribute: function(attributeName) {
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.move);
        element2.off(Metro2.events.leave);
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/image-placeholder/image-placeholder.js
  (function(Metro2, $5) {
    "use strict";
    var ImagePlaceholderDefaultConfig = {
      size: "100x100",
      width: null,
      height: null,
      color: "#f8f8f8",
      textColor: "#292929",
      font: "12px sans-serif",
      text: "",
      showText: true,
      onImagePlaceholderCreate: Metro2.noop
    };
    Metro2.imagePlaceholderSetup = function(options) {
      ImagePlaceholderDefaultConfig = $5.extend({}, ImagePlaceholderDefaultConfig, options);
    };
    if (typeof globalThis["metroImagePlaceholderSetup"] !== "undefined") {
      Metro2.imagePlaceholderSetup(globalThis["metroImagePlaceholderSetup"]);
    }
    Metro2.Component("image-placeholder", {
      init: function(options, elem) {
        this._super(elem, options, ImagePlaceholderDefaultConfig, {
          // define instance vars here
          width: 0,
          height: 0
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("image-placeholder-create");
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        var size = o2.size.toArray("x");
        this.width = o2.width ? o2.width : size[0];
        this.height = o2.height ? o2.height : size[1];
        element2.attr("src", this._createPlaceholder());
      },
      _createEvents: function() {
      },
      _createPlaceholder: function() {
        var o2 = this.options;
        var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
        var width = this.width, height = this.height;
        canvas.width = parseInt(width);
        canvas.height = parseInt(height);
        context.clearRect(0, 0, width, height);
        context.fillStyle = o2.color;
        context.fillRect(0, 0, width, height);
        context.fillStyle = o2.textColor;
        context.font = o2.font;
        context.translate(width / 2, height / 2);
        context.textAlign = "center";
        context.textBaseline = "middle";
        if (o2.showText)
          context.fillText(o2.text ? o2.text : width + " \xD7 " + height, 0, 0);
        return canvas.toDataURL();
      },
      // changeAttribute: function(attr, newValue){
      // },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/info-box/info-box.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var InfoBoxDefaultConfig = {
      infoboxDeferred: 0,
      type: "",
      width: 480,
      height: "auto",
      overlay: true,
      overlayColor: "#000000",
      overlayAlpha: 0.5,
      overlayClickClose: false,
      autoHide: 0,
      removeOnClose: false,
      closeButton: true,
      clsBox: "",
      clsBoxContent: "",
      clsOverlay: "",
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onInfoBoxCreate: Metro2.noop
    };
    Metro2.infoBoxSetup = function(options) {
      InfoBoxDefaultConfig = $5.extend({}, InfoBoxDefaultConfig, options);
    };
    if (typeof globalThis["metroInfoBoxSetup"] !== "undefined") {
      Metro2.infoBoxSetup(globalThis["metroInfoBoxSetup"]);
    }
    Metro2.Component("info-box", {
      init: function(options, elem) {
        this._super(elem, options, InfoBoxDefaultConfig, {
          overlay: null,
          id: Utils.elementId("info-box")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("info-box-create", {
          element: element2
        });
      },
      _overlay: function() {
        var o2 = this.options;
        var overlay = $5("<div>");
        overlay.addClass("overlay").addClass(o2.clsOverlay);
        if (o2.overlayColor === "transparent") {
          overlay.addClass("transparent");
        } else {
          overlay.css({
            background: Farbe.Routines.toRGBA(Farbe.Routines.parse(o2.overlayColor), o2.overlayAlpha)
          });
        }
        return overlay;
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        var closer, content;
        if (o2.overlay === true) {
          this.overlay = this._overlay();
        }
        element2.addClass("info-box").addClass(o2.type).addClass(o2.clsBox);
        closer = element2.find("closer");
        if (closer.length === 0) {
          closer = $5("<span>").addClass("button square closer");
          closer.appendTo(element2);
        }
        if (o2.closeButton !== true) {
          closer.hide();
        }
        content = element2.find(".info-box-content");
        if (content.length > 0) {
          content.addClass(o2.clsBoxContent);
        }
        element2.css({
          width: o2.width,
          height: o2.height,
          visibility: "hidden",
          top: "100%",
          left: ($5(globalThis).width() - element2.outerWidth()) / 2
        });
        element2.appendTo($5("body"));
      },
      _createEvents: function() {
        var that = this, element2 = this.element;
        element2.on(Metro2.events.click, ".closer", function() {
          that.close();
        });
        element2.on(Metro2.events.click, ".js-dialog-close", function() {
          that.close();
        });
        $5(globalThis).on(Metro2.events.resize, function() {
          that.reposition();
        }, { ns: this.id });
      },
      _setPosition: function() {
        var element2 = this.element;
        element2.css({
          top: ($5(globalThis).height() - element2.outerHeight()) / 2,
          left: ($5(globalThis).width() - element2.outerWidth()) / 2
        });
      },
      reposition: function() {
        this._setPosition();
      },
      setContent: function(c3) {
        var element2 = this.element;
        var content = element2.find(".info-box-content");
        if (content.length === 0) {
          return;
        }
        content.html(c3);
        this.reposition();
      },
      setType: function(t) {
        var element2 = this.element;
        element2.removeClass("success info alert warning").addClass(t);
      },
      open: function() {
        var that = this, element2 = this.element, o2 = this.options;
        if (o2.overlay === true && $5(".overlay").length === 0) {
          this.overlay.appendTo($5("body"));
          if (o2.overlayClickClose === true) {
            this.overlay.on(Metro2.events.click, function() {
              that.close();
            });
          }
        }
        this._setPosition();
        element2.css({
          visibility: "visible"
        });
        this._fireEvent("open");
        element2.data("open", true);
        if (parseInt(o2.autoHide) > 0) {
          setTimeout(function() {
            that.close();
          }, parseInt(o2.autoHide));
        }
      },
      close: function() {
        var element2 = this.element, o2 = this.options;
        if (o2.overlay === true) {
          $5("body").find(".overlay").remove();
        }
        element2.css({
          visibility: "hidden",
          top: "100%"
        });
        this._fireEvent("close");
        element2.data("open", false);
        if (o2.removeOnClose === true) {
          this.destroy();
          element2.remove();
        }
      },
      isOpen: function() {
        return this.element.data("open") === true;
      },
      /* eslint-disable-next-line */
      changeAttribute: function(attributeName) {
      },
      destroy: function() {
        var element2 = this.element;
        element2.off("all");
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
    Metro2["infobox"] = {
      isInfoBox: function(el) {
        return Utils.isMetroObject(el, "infobox");
      },
      open: function(el, c3, t) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        var ib = Metro2.getPlugin(el, "infobox");
        if (c3 !== void 0) {
          ib.setContent(c3);
        }
        if (t !== void 0) {
          ib.setType(t);
        }
        ib.open();
      },
      close: function(el) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        var ib = Metro2.getPlugin(el, "infobox");
        ib.close();
      },
      setContent: function(el, c3) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        if (c3 === void 0) {
          c3 = "";
        }
        var ib = Metro2.getPlugin(el, "infobox");
        ib.setContent(c3);
        ib.reposition();
      },
      setType: function(el, t) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        var ib = Metro2.getPlugin(el, "infobox");
        ib.setType(t);
        ib.reposition();
      },
      isOpen: function(el) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        var ib = Metro2.getPlugin(el, "infobox");
        return ib.isOpen();
      },
      create: function(c3, t, o2, open) {
        var $$ = Utils.$();
        var el, ib, box_type;
        box_type = t !== void 0 ? t : "";
        el = $$("<div>").appendTo($$("body"));
        $$("<div>").addClass("info-box-content").appendTo(el);
        var ib_options = $$.extend({}, {
          removeOnClose: true,
          type: box_type
        }, o2 !== void 0 ? o2 : {});
        ib_options._runtime = true;
        el.infobox(ib_options);
        ib = Metro2.getPlugin(el, "infobox");
        ib.setContent(c3);
        if (open !== false) {
          ib.open();
        }
        return el;
      }
    };
  })(Metro, Dom);

  // source/components/input-mask/input-mask.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var InputMaskDefaultConfig = {
      maskPattern: ".",
      mask: null,
      maskPlaceholder: "_",
      maskEditableStart: 0,
      thresholdInterval: 300,
      onChar: Metro2.noop,
      onInputMaskCreate: Metro2.noop
    };
    Metro2.inputMaskSetup = function(options) {
      InputMaskDefaultConfig = $5.extend({}, InputMaskDefaultConfig, options);
    };
    if (typeof globalThis["metroInputMaskSetup"] !== "undefined") {
      Metro2.inputMaskSetup(globalThis["metroInputMaskSetup"]);
    }
    Metro2.Component("input-mask", {
      init: function(options, elem) {
        this._super(elem, options, InputMaskDefaultConfig, {
          // define instance vars here
          pattern: null,
          mask: "",
          maskArray: [],
          placeholder: "",
          length: 0,
          thresholdTimer: null,
          id: Utils.elementId("input-mask")
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("input-mask-create");
      },
      _createStructure: function() {
        var o2 = this.options;
        if (!o2.mask) {
          throw new Error("You must provide a pattern for masked input.");
        }
        if (typeof o2.maskPlaceholder !== "string" || o2.maskPlaceholder.length > 1) {
          throw new Error("Mask placeholder should be a single character or an empty string.");
        }
        this.placeholder = o2.maskPlaceholder;
        this.mask = "" + o2.mask;
        this.maskArray = this.mask.split("");
        this.pattern = new RegExp("^" + o2.maskPattern + "+$");
        this.length = this.mask.length;
        this._showValue();
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var editableStart = o2.maskEditableStart;
        var id = this.id;
        var checkEditablePosition = function(pos) {
          if (pos < editableStart) {
            setPosition(editableStart);
            return false;
          }
          return true;
        };
        var checkEditableChar = function(pos) {
          return pos < that.mask.length && that.mask.charAt(pos) === that.placeholder;
        };
        var findNextEditablePosition = function(pos) {
          var i3, a3 = that.maskArray;
          for (i3 = pos; i3 <= a3.length; i3++) {
            if (a3[i3] === that.placeholder) {
              return i3;
            }
          }
          return pos;
        };
        var setPosition = function(pos) {
          that.elem.setSelectionRange(pos, pos);
        };
        var clearThresholdInterval = function() {
          clearInterval(that.thresholdTimer);
          that.thresholdTimer = null;
        };
        element2.on("change", function() {
          if (this.value === "") {
            this.value = that.mask;
            setPosition(editableStart);
          }
        }, { ns: id });
        element2.on("focus click", function() {
          checkEditablePosition(this.selectionStart);
          setPosition(findNextEditablePosition(this.selectionStart));
        }, { ns: id });
        element2.on("keydown", function(e2) {
          var pos = this.selectionStart;
          var val = this.value;
          var code = e2.code, key = e2.key;
          if (code === "ArrowRight" || code === "End") {
            return true;
          } else {
            if (pos >= that.length && ["Backspace", "Home", "ArrowLeft", "ArrowUp"].indexOf(code) === -1) {
              e2.preventDefault();
            } else if (code === "Home" || code === "ArrowUp") {
              e2.preventDefault();
              setPosition(editableStart);
            } else if (code === "ArrowLeft") {
              if (pos - 1 < editableStart) {
                e2.preventDefault();
              }
            } else if (code === "Backspace") {
              e2.preventDefault();
              if (pos - 1 >= editableStart) {
                if (checkEditableChar(pos - 1)) {
                  if (this.value.charAt(pos - 1) !== that.placeholder) {
                    this.value = val.substr(0, pos - 1) + that.placeholder + val.substr(pos);
                  }
                }
                setPosition(pos - 1);
              }
            } else if (code === "Space") {
              e2.preventDefault();
              setPosition(pos + 1);
            } else if (!that.pattern.test(key)) {
              e2.preventDefault();
            } else {
              e2.preventDefault();
              if (checkEditableChar(pos)) {
                this.value = val.substr(0, pos) + (o2.onChar === Metro2.noop ? key : Utils.exec(o2.onChar, [key], this)) + val.substr(pos + 1);
                setPosition(findNextEditablePosition(pos + 1));
              }
            }
          }
        }, { ns: id });
        element2.on("keyup", function() {
          var el = this;
          clearThresholdInterval();
          that.thresholdTimer = setInterval(function() {
            clearThresholdInterval();
            setPosition(findNextEditablePosition(el.selectionStart));
          }, o2.thresholdInterval);
        }, { ns: id });
      },
      _showValue: function() {
        var that = this, elem = this.elem;
        var a3 = new Array(this.length);
        var val;
        if (!elem.value) {
          elem.value = this.mask;
        } else {
          val = elem.value;
          $5.each(this.maskArray, function(i3, v4) {
            if (val[i3] !== v4 && !that.pattern.test(val[i3])) {
              a3[i3] = that.placeholder;
            } else {
              a3[i3] = val[i3];
            }
          });
          this.elem.value = a3.join("");
        }
      },
      destroy: function() {
        var element2 = this.element, id = this.id;
        element2.off("change", { ns: id });
        element2.off("focus", { ns: id });
        element2.off("click", { ns: id });
        element2.off("keydown", { ns: id });
        element2.off("keyup", { ns: id });
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/input-material/input-material.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var MaterialInputDefaultConfig = {
      materialinputDeferred: 0,
      label: "",
      informer: "",
      icon: "",
      permanentLabel: false,
      searchButton: false,
      clearButton: true,
      revealButton: true,
      clearButtonIcon: "\u274C",
      revealButtonIcon: "\u{1F440}",
      searchButtonIcon: "\u{1F50D}",
      customButtons: [],
      searchButtonClick: "submit",
      clsComponent: "",
      clsInput: "",
      clsLabel: "",
      clsInformer: "",
      clsIcon: "",
      clsLine: "",
      onInputCreate: Metro2.noop
    };
    Metro2.materialInputSetup = function(options) {
      MaterialInputDefaultConfig = $5.extend({}, MaterialInputDefaultConfig, options);
    };
    if (typeof globalThis["metroMaterialInputSetup"] !== "undefined") {
      Metro2.materialInputSetup(globalThis["metroMaterialInputSetup"]);
    }
    Metro2.Component("material-input", {
      init: function(options, elem) {
        this._super(elem, options, MaterialInputDefaultConfig, {
          history: [],
          historyIndex: -1
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("input-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        var container;
        var buttons;
        element2[0].className = "";
        element2.attr("autocomplete", "nope");
        if (element2.attr("type") === void 0) {
          element2.attr("type", "text");
        }
        container = element2.wrap("<div>").addClass("input-material " + element2[0].className);
        buttons = $5("<div>").addClass("buttons").appendTo(container);
        if (o2.label) {
          $5("<span>").html(o2.label).addClass("label").addClass(o2.clsLabel).insertAfter(element2);
        }
        if (Utils.isValue(o2.informer)) {
          $5("<span>").html(o2.informer).addClass("informer").addClass(o2.clsInformer).insertAfter(element2);
        }
        if (Utils.isValue(o2.icon)) {
          container.addClass("with-icon");
          $5("<span>").html(o2.icon).addClass("icon").addClass(o2.clsIcon).insertAfter(element2);
        }
        if (o2.clearButton === true && !element2[0].readOnly) {
          const clearButton = $5("<button>").addClass("button input-clear-button").addClass(o2.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(buttons);
        }
        if (element2.attr("type") === "password" && o2.revealButton === true) {
          const revealButton = $5("<button>").addClass("button input-reveal-button").addClass(o2.clsRevealButton).attr("tabindex", -1).attr("type", "button").html(o2.revealButtonIcon);
          revealButton.appendTo(buttons);
        }
        if (o2.searchButton === true) {
          const searchButton = $5("<button>").addClass("button input-search-button").addClass(o2.clsSearchButton).attr("tabindex", -1).attr("type", o2.searchButtonClick === "submit" ? "submit" : "button").html(o2.searchButtonIcon);
          searchButton.appendTo(buttons);
        }
        const customButtons = Utils.isObject(o2.customButtons);
        if (Array.isArray(customButtons)) {
          $5.each(customButtons, function() {
            var item = this;
            var btn = $5("<button>");
            btn.addClass("button input-custom-button").addClass(o2.clsCustomButton).addClass(item.cls).attr("tabindex", -1).attr("type", "button").html(item.text);
            if (item.attr && typeof item.attr === "object") {
              $5.each(item.attr, function(k4, v4) {
                btn.attr(Str.dashedName(k4), v4);
              });
            }
            if (item.onclick) btn.on("click", () => {
              item.onclick.apply(btn, [element2.valueOf(), element2]);
            });
            btn.appendTo(buttons);
          });
        }
        container.append($5("<hr>").addClass(o2.clsLine));
        if (o2.permanentLabel === true) {
          container.addClass("permanent-label");
        }
        container.addClass(o2.clsComponent);
        element2.addClass(o2.clsInput);
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.component = container;
      },
      _createEvents: function() {
        const that = this, o2 = this.options;
        const element2 = this.element;
        this.component.on(Metro2.events.click, ".input-clear-button", function() {
          const curr = element2.val();
          element2.val("").fire("clear").fire("change").fire("keyup").focus();
          that._fireEvent("clear-click", {
            prev: curr
          });
        });
        this.component.on(Metro2.events.click, ".input-reveal-button", function() {
          if (element2.attr("type") === "password") {
            element2.attr("type", "text");
          } else {
            element2.attr("type", "password");
          }
          that._fireEvent("reveal-click", {
            val: element2.val()
          });
        });
        this.component.on(Metro2.events.click, ".input-search-button", function() {
          if (o2.searchButtonClick !== "submit") {
            that._fireEvent("search-button-click", {
              val: element2.val(),
              button: this
            });
          } else {
            if (this.form) this.form.submit();
          }
        });
        element2.on(Metro2.events.keydown, function(e2) {
          if (e2.keyCode === Metro2.keyCode.ENTER) {
            that._fireEvent("enter-click", {
              val: element2.val()
            });
          }
        });
      },
      clear: function() {
        this.element.val("");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        if (attributeName === "disabled") {
          this.toggleState();
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/keypad/keypad.js
  (function(Metro2, $5) {
    "use strict";
    let KeypadDefaultConfig = {
      keypadDeferred: 0,
      label: "",
      keySize: 36,
      keys: "1, 2, 3, 4, 5, 6, 7, 8, 9, 0",
      exceptKeys: "",
      keySeparator: "",
      trimSeparator: false,
      keyDelimiter: ",",
      copyInlineStyles: false,
      target: null,
      keyLength: 0,
      shuffle: false,
      shuffleCount: 3,
      //position: Metro.position.BOTTOM_LEFT, //top-left, top, top-right, right, bottom-right, bottom, bottom-left, left
      // dynamicPosition: false,
      serviceButtons: true,
      showValue: true,
      open: false,
      useElementSizeForKeys: false,
      // sizeAsKeys: false,
      openMode: "auto",
      clsKeypad: "",
      clsInput: "",
      clsKeys: "",
      clsKey: "",
      clsServiceKey: "",
      clsBackspace: "",
      clsClear: "",
      clsLabel: "",
      onChange: Metro2.noop,
      onClear: Metro2.noop,
      onBackspace: Metro2.noop,
      onShuffle: Metro2.noop,
      onKey: Metro2.noop,
      onKeypadCreate: Metro2.noop
    };
    Metro2.keypadSetup = function(options) {
      KeypadDefaultConfig = $5.extend({}, KeypadDefaultConfig, options);
    };
    if (typeof globalThis["metroKeypadSetup"] !== "undefined") {
      Metro2.keypadSetup(globalThis["metroKeypadSetup"]);
    }
    Metro2.Component("keypad", {
      init: function(options, elem) {
        this._super(elem, options, KeypadDefaultConfig, {
          value: elem.tagName === "INPUT" ? elem.value : elem.innerText,
          positions: ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"],
          keypad: null,
          keys: [],
          keys_to_work: [],
          exceptKeys: []
        });
        return this;
      },
      _create: function() {
        const element2 = this.element, o2 = this.options;
        this.options.position = "bottom-left";
        this.keys = o2.keys.toArray(o2.keyDelimiter);
        this.keys_to_work = this.keys;
        this.exceptKeys = o2.exceptKeys.toArray(o2.keyDelimiter);
        this._createKeypad();
        if (o2.shuffle === true) {
          this.shuffle();
        }
        this._createKeys();
        this._createEvents();
        this._fireEvent("keypad-create", {
          element: element2
        });
      },
      _createKeypad: function() {
        const element2 = this.element, o2 = this.options;
        let keys;
        const keypad = element2.wrap("<div>").addClass("input keypad").addClass(element2[0].className).addClass(o2.clsKeypad);
        if (element2.attr("type") === void 0) {
          element2.attr("type", "text");
        }
        element2.attr("readonly", true);
        keys = $5("<div>").addClass("keys").addClass(o2.clsKeys);
        keys.appendTo(keypad);
        this._setKeysPosition();
        if (o2.open === true) {
          keys.addClass("open keep-open");
        }
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          let i3 = 0, l3 = element2[0].style.length;
          for (; i3 < l3; i3++) {
            keypad.css(element2[0].style[i3], element2.css(element2[0].style[i3]));
          }
        }
        element2.addClass(o2.clsInput);
        keypad.addClass(o2.clsKeypad);
        element2.on(Metro2.events.blur, function() {
          keypad.removeClass("focused");
        });
        element2.on(Metro2.events.focus, function() {
          keypad.addClass("focused");
        });
        const buttons = $5("<div>").addClass("button-group").appendTo(keypad);
        const kbdButton = $5("<button>").addClass("button input-kbd-button").addClass(o2.clsKbdButton).attr("tabindex", -1).attr("type", "button").html("\u2328");
        kbdButton.appendTo(buttons);
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(keypad);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            element2.id(id);
            label.attr("for", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (o2.disabled === true || element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.keypad = keypad;
      },
      _setKeysPosition: function() {
        const element2 = this.element, o2 = this.options;
        const keypad = element2.parent();
        const keys = keypad.find(".keys");
        keys.removeClass(this.positions.join(" ")).addClass(o2.position);
      },
      _createKeys: function() {
        const element2 = this.element, o2 = this.options;
        const keypad = element2.parent();
        let key, keys = keypad.find(".keys");
        const factor = Math.round(Math.sqrt(this.keys.length + 2));
        const key_size = o2.keySize;
        let width;
        keys.html("");
        $5.each(this.keys_to_work, function() {
          key = $5("<span>").addClass("key").addClass(o2.clsKey).html(this);
          key.data("key", this);
          key.css({
            width: o2.keySize,
            height: o2.keySize,
            lineHeight: o2.keySize - 4
          }).appendTo(keys);
        });
        if (o2.serviceButtons === true) {
          const service_keys = ["&larr;", "&times;"];
          $5.each(service_keys, function() {
            key = $5("<span>").addClass("key service-key").addClass(o2.clsKey).addClass(o2.clsServiceKey).html(this);
            if (this === "&larr;") {
              key.addClass(o2.clsBackspace);
            }
            if (this === "&times;") {
              key.addClass(o2.clsClear);
            }
            key.data("key", this);
            key.css({
              width: o2.keySize,
              height: o2.keySize,
              lineHeight: o2.keySize - 4
            }).appendTo(keys);
          });
        }
        if (o2.useElementSizeForKeys === true) {
          keys.outerWidth(element2.outerWidth());
        } else {
          width = factor * (key_size + 2) - 6;
          keys.outerWidth(width);
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const keypad = element2.parent();
        const keys = keypad.find(".keys");
        keys.on(Metro2.events.click, ".key", function(e2) {
          const key = $5(this);
          const keyValue = key.data("key");
          let crop;
          if (key.data("key") !== "&larr;" && key.data("key") !== "&times;") {
            if (o2.keyLength > 0 && ("" + that.value).length === o2.keyLength) {
              return false;
            }
            if (that.exceptKeys.indexOf(keyValue) === -1)
              that.value = that.value + (that.value !== "" ? o2.keySeparator : "") + keyValue;
            if (o2.shuffle === true) {
              that.shuffle();
              that._createKeys();
            }
            if (o2.dynamicPosition === true) {
              o2.position = that.positions[$5.random(0, that.positions.length - 1)];
              that._setKeysPosition();
            }
            that._fireEvent("key", {
              key: key.data("key"),
              val: that.value
            });
          } else {
            if (key.data("key") === "&times;") {
              that.value = "";
              that._fireEvent("clear");
            }
            if (key.data("key") === "&larr;") {
              crop = o2.keySeparator && that.value[that.value.length - 1] !== o2.keySeparator ? 2 : 1;
              that.value = that.value.substring(0, that.value.length - crop);
              that._fireEvent("backspace", {
                val: that.value
              });
            }
          }
          if (o2.showValue === true) {
            if (element2[0].tagName === "INPUT") {
              element2.val(that.value);
            } else {
              element2.text(that.value);
            }
          }
          that._fireEvent("change", {
            val: that.val
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
        keypad.on(Metro2.events.click, function(e2) {
          if (o2.open === true) {
            return;
          }
          if (keys.hasClass("open") === true) {
            keys.removeClass("open").removeClass("top-left");
          } else {
            keys.addClass("open");
            if (o2.openMode === "auto") {
              if (Metro2.utils.inViewport(keys[0]) === false) {
                keys.addClass("top-left");
              }
            } else {
              if (o2.openMode === "up") {
                keys.addClass("top-left");
              }
            }
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        if (o2.target !== null) {
          element2.on(Metro2.events.change, function() {
            const t = $5(o2.target);
            if (t.length === 0) {
              return;
            }
            if (t[0].tagName === "INPUT") {
              t.val(that.value);
            } else {
              t.text(that.value);
            }
          });
        }
      },
      shuffle: function() {
        const o2 = this.options;
        for (let i3 = 0; i3 < o2.shuffleCount; i3++) {
          this.keys_to_work = this.keys_to_work.shuffle();
        }
        this._fireEvent("shuffle", {
          keysToWork: this.keys_to_work,
          keys: this.keys
        });
      },
      shuffleKeys: function(count) {
        if (count === void 0) {
          count = this.options.shuffleCount;
        }
        for (let i3 = 0; i3 < count; i3++) {
          this.keys_to_work = this.keys_to_work.shuffle();
        }
        this._createKeys();
      },
      val: function(v4) {
        const element2 = this.element, o2 = this.options;
        if (typeof v4 === "undefined") {
          return o2.trimSeparator ? this.value.replace(new RegExp(o2.keySeparator, "g")) : this.value;
        }
        this.value = "" + v4;
        if (element2[0].tagName === "INPUT") {
          element2.val(v4);
        } else {
          element2.text(v4);
        }
        return this;
      },
      open: function() {
        const element2 = this.element, o2 = this.options;
        const keypad = element2.parent();
        const keys = keypad.find(".keys");
        keys.addClass("open");
        if (o2.openMode === "auto") {
          if (Metro2.utils.inViewport(keys[0]) === false) {
            keys.addClass("top-left");
          }
        } else {
          if (o2.openMode === "up") {
            keys.addClass("top-left");
          }
        }
      },
      close: function() {
        const element2 = this.element;
        const keypad = element2.parent();
        const keys = keypad.find(".keys");
        keys.removeClass("open").removeClass("top-left");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      setPosition: function(pos) {
        const new_position = pos !== void 0 ? pos : this.element.attr("data-position");
        if (this.positions.indexOf(new_position) === -1) {
          return;
        }
        this.options.position = new_position;
        this._setKeysPosition();
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
          case "data-position":
            this.setPosition();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options, keypad = this.keypad, keys = keypad.find(".keys");
        keypad.off(Metro2.events.click);
        keys.off(Metro2.events.click, ".key");
        element2.off(Metro2.events.change);
        if (o2.label) {
          keypad.prev("label").remove();
        }
        keypad.remove();
      }
    });
    $5(document).on(Metro2.events.click, function() {
      const keypads = $5(".keypad .keys");
      $5.each(keypads, function() {
        if (!$5(this).hasClass("keep-open")) {
          $5(this).removeClass("open");
        }
      });
    });
  })(Metro, Dom);

  // source/components/lightbox/lightbox.js
  (function(Metro2, $5) {
    "use strict";
    var LightboxDefaultConfig = {
      loop: true,
      source: "img",
      iconClose: "\u274C",
      iconPrev: "\u{1F850}",
      iconNext: "\u{1F852}",
      clsNext: "",
      clsPrev: "",
      clsClose: "",
      clsImage: "",
      clsImageContainer: "",
      clsImageWrapper: "",
      clsLightbox: "",
      onDrawImage: Metro2.noop,
      onLightboxCreate: Metro2.noop
    };
    Metro2.lightboxSetup = function(options) {
      LightboxDefaultConfig = $5.extend({}, LightboxDefaultConfig, options);
    };
    if (typeof globalThis["metroLightboxSetup"] !== "undefined") {
      Metro2.lightboxSetup(globalThis["metroLightboxSetup"]);
    }
    Metro2.Component("lightbox", {
      init: function(options, elem) {
        this._super(elem, options, LightboxDefaultConfig, {
          // define instance vars here
          overlay: null,
          lightbox: null,
          current: null,
          items: []
        });
        return this;
      },
      _create: function() {
        var o2 = this.options;
        if (!o2.source) {
          o2.source = "img";
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("lightbox-create");
      },
      _createStructure: function() {
        var o2 = this.options;
        var lightbox, overlay;
        overlay = $5(".lightbox-overlay");
        if (overlay.length === 0) {
          overlay = $5("<div>").addClass("lightbox-overlay").appendTo("body").hide();
        }
        lightbox = $5("<div>").addClass("lightbox").addClass(o2.clsLightbox).appendTo("body").hide();
        $5("<span>").addClass("lightbox__prev").addClass(o2.clsPrev).html(o2.iconPrev).appendTo(lightbox);
        $5("<span>").addClass("lightbox__next").addClass(o2.clsNext).html(o2.iconNext).appendTo(lightbox);
        $5("<span>").addClass("lightbox__closer").addClass(o2.clsClose).html(o2.iconClose).appendTo(lightbox);
        $5("<div>").addClass("lightbox__image").addClass(o2.clsImageContainer).appendTo(lightbox);
        this.component = lightbox[0];
        this.lightbox = lightbox;
        this.overlay = overlay;
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var lightbox = $5(this.component);
        element2.on(Metro2.events.click, o2.source, function() {
          that.open(this);
        });
        lightbox.on(Metro2.events.click, ".lightbox__closer", function() {
          that.close();
        });
        lightbox.on(Metro2.events.click, ".lightbox__prev", function() {
          that.prev();
        });
        lightbox.on(Metro2.events.click, ".lightbox__next", function() {
          that.next();
        });
      },
      _setupItems: function() {
        var element2 = this.element, o2 = this.options;
        var items = element2.find(o2.source);
        if (items.length === 0) {
          return;
        }
        this.items = items;
      },
      _goto: function(el) {
        var that = this, o2 = this.options;
        var $el = $5(el);
        var img = $5("<img>"), src;
        var imageContainer, imageWrapper, activity;
        imageContainer = this.lightbox.find(".lightbox__image");
        imageContainer.find(".lightbox__image-wrapper").remove();
        imageWrapper = $5("<div>").addClass("lightbox__image-wrapper").addClass(o2.clsImageWrapper).attr("data-title", $el.attr("alt") || $el.attr("data-title") || "").appendTo(imageContainer);
        activity = $5("<div>").appendTo(imageWrapper);
        Metro2.makePlugin(activity, "activity", {
          type: "cycle",
          style: "color"
        });
        this.current = el;
        if (el.tagName === "IMG" || el.tagName === "DIV") {
          src = $el.attr("data-original") || $el.attr("src");
          img.attr("src", src);
          img[0].onload = function() {
            var port = this.height > this.width;
            img.addClass(port ? "lightbox__image-portrait" : "lightbox__image-landscape").addClass(o2.clsImage);
            img.attr("alt", $el.attr("alt"));
            img.appendTo(imageWrapper);
            activity.remove();
            that._fireEvent("draw-image", {
              image: img[0],
              item: imageWrapper[0]
            });
          };
        }
      },
      _index: function(el) {
        var index = -1;
        this.items.each(function(i3) {
          if (this === el) {
            index = i3;
          }
        });
        return index;
      },
      next: function() {
        var index, current = this.current;
        index = this._index(current);
        if (index + 1 >= this.items.length) {
          if (this.options.loop) {
            index = -1;
          } else {
            return;
          }
        }
        this._goto(this.items[index + 1]);
      },
      prev: function() {
        var index, current = this.current;
        index = this._index(current);
        if (index - 1 < 0) {
          if (this.options.loop) {
            index = this.items.length;
          } else {
            return;
          }
        }
        this._goto(this.items[index - 1]);
      },
      open: function(el) {
        this._setupItems();
        this._goto(el);
        this.overlay.show();
        this.lightbox.show();
        return this;
      },
      close: function() {
        this.overlay.hide();
        this.lightbox.hide();
      },
      changeAttribute: function() {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/list/list.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var ListDefaultConfig = {
      listDeferred: 0,
      templateBeginToken: "<%",
      templateEndToken: "%>",
      paginationDistance: 5,
      paginationShortMode: true,
      thousandSeparator: ",",
      decimalSeparator: ",",
      itemTag: "li",
      defaultTemplateTag: "div",
      sortClass: null,
      sortDir: "asc",
      sortInitial: true,
      filterClass: null,
      filter: null,
      filterString: "",
      filters: null,
      source: null,
      showItemsSteps: false,
      showSearch: false,
      showListInfo: false,
      showPagination: false,
      showActivity: true,
      muteList: true,
      items: -1,
      itemsSteps: "all, 10,25,50,100",
      itemsAllTitle: "Show all",
      listItemsCountTitle: "Show entries:",
      listSearchTitle: "Search:",
      listInfoTitle: "Showing $1 to $2 of $3 entries",
      paginationPrevTitle: "Prev",
      paginationNextTitle: "Next",
      activityType: "cycle",
      activityStyle: "color",
      activityTimeout: 100,
      searchWrapper: null,
      rowsWrapper: null,
      infoWrapper: null,
      paginationWrapper: null,
      searchThreshold: 500,
      clsComponent: "",
      clsList: "",
      clsListItem: "",
      clsListTop: "",
      clsItemsCount: "",
      clsSearch: "",
      clsListBottom: "",
      clsListInfo: "",
      clsListPagination: "",
      clsPagination: "",
      clsTemplateTag: "",
      onDraw: Metro2.noop,
      onDrawItem: Metro2.noop,
      onSortStart: Metro2.noop,
      onSortStop: Metro2.noop,
      onSortItemSwitch: Metro2.noop,
      onSearch: Metro2.noop,
      onRowsCountChange: Metro2.noop,
      onDataLoad: Metro2.noop,
      onDataLoaded: Metro2.noop,
      onDataLoadError: Metro2.noop,
      onFilterItemAccepted: Metro2.noop,
      onFilterItemDeclined: Metro2.noop,
      onListCreate: Metro2.noop
    };
    Metro2.listSetup = function(options) {
      ListDefaultConfig = $5.extend({}, ListDefaultConfig, options);
    };
    if (typeof globalThis["metroListSetup"] !== "undefined") {
      Metro2.listSetup(globalThis["metroListSetup"]);
    }
    Metro2.Component("list", {
      init: function(options, elem) {
        this._super(elem, options, ListDefaultConfig, {
          currentPage: 1,
          pagesCount: 1,
          filterString: "",
          data: null,
          activity: null,
          busy: false,
          filters: [],
          wrapperInfo: null,
          wrapperSearch: null,
          wrapperRows: null,
          wrapperPagination: null,
          filterIndex: null,
          filtersIndexes: [],
          itemTemplate: null,
          sort: {
            dir: "asc",
            colIndex: 0
          },
          header: null,
          items: []
        });
        return this;
      },
      _create: function() {
        var that = this, o2 = this.options;
        if (o2.source) {
          that._fireEvent("data-load", {
            source: o2.source
          });
          fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then(function(data) {
            that._fireEvent("data-loaded", {
              source: o2.source,
              data
            });
            that._build(data);
          }).catch(function(error) {
            that._fireEvent("data-load-error", {
              source: o2.source,
              error
            });
          });
        } else {
          that._build();
        }
      },
      _build: function(data) {
        if (Utils.isValue(data)) {
          this._createItemsFromJSON(data);
        } else {
          this._createItemsFromHTML();
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("list-create");
      },
      _createItemsFromHTML: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var clsTemplateTag = ("" + o2.clsTemplateTag).toArray(",");
        this.items = [];
        $5.each(element2.children(o2.itemTag), function() {
          var tagChildren = $5(this).children("*");
          if (clsTemplateTag.length) {
            if (clsTemplateTag.length === 1) {
              tagChildren.addClass(clsTemplateTag[0]);
            } else {
              tagChildren.each(function(i3, child) {
                $5(child).addClass(clsTemplateTag[i3] ? clsTemplateTag[i3] : clsTemplateTag[clsTemplateTag.length - 1]);
              });
            }
          }
          that.items.push(this);
        });
      },
      _createItemsFromJSON: function(source) {
        var that = this, o2 = this.options;
        var clsTemplateTag = ("" + o2.clsTemplateTag).toArray(",");
        this.items = [];
        if (Utils.isValue(source.template)) {
          this.itemTemplate = source.template;
        }
        if (Utils.isValue(source.header)) {
          this.header = source.header;
        }
        if (Utils.isValue(source.data)) {
          $5.each(source.data, function() {
            var item = "", row = this;
            var li = document.createElement(o2.itemTag);
            var tpl = that.itemTemplate;
            var tagChildren;
            if (!Utils.isValue(tpl)) {
              for (var i3 in row) {
                item += "<" + o2.defaultTemplateTag + ">" + row[i3] + "</" + o2.defaultTemplateTag + ">";
              }
            } else {
              item = Metro2.template(tpl, row, {
                beginToken: o2.templateBeginToken,
                endToken: o2.templateEndToken
              });
            }
            li.innerHTML = item;
            tagChildren = $5(li).children("*");
            if (clsTemplateTag.length) {
              if (clsTemplateTag.length === 1) {
                tagChildren.addClass(clsTemplateTag[0]);
              } else {
                tagChildren.each(function(i4, child) {
                  $5(child).addClass(clsTemplateTag[i4] ? clsTemplateTag[i4] : clsTemplateTag[clsTemplateTag.length - 1]);
                });
              }
            }
            that.items.push(li);
          });
        }
      },
      _createTopBlock: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var top_block = $5("<div>").addClass("list-top").addClass(o2.clsListTop).insertBefore(element2);
        var search_block, search_input, rows_block, rows_select;
        search_block = Utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $5("<div>").addClass("list-search-block").addClass(o2.clsSearch).appendTo(top_block);
        search_input = $5("<input>").attr("type", "text").appendTo(search_block);
        Metro2.makePlugin(search_input, "input", {
          prepend: o2.listSearchTitle
        });
        if (o2.showSearch !== true) {
          search_block.hide();
        }
        rows_block = Utils.isValue(this.wrapperRows) ? this.wrapperRows : $5("<div>").addClass("list-rows-block").addClass(o2.clsItemsCount).appendTo(top_block);
        rows_select = $5("<select>").appendTo(rows_block);
        $5.each(o2.itemsSteps.toArray(), function() {
          var option = $5("<option>").attr("value", this === "all" ? -1 : this).text(this === "all" ? o2.itemsAllTitle : this).appendTo(rows_select);
          if (+this === +o2.items) option.attr("selected", "selected");
        });
        rows_select.select({
          filter: false,
          prepend: o2.listItemsCountTitle,
          onChange: function(val) {
            if (+val === +o2.items) return;
            o2.items = parseInt(val);
            that.currentPage = 1;
            that._draw();
            that._fireEvent("rows-count-change", {
              val
            });
          }
        });
        if (o2.showItemsSteps !== true) {
          rows_block.hide();
        }
        return top_block;
      },
      _createBottomBlock: function() {
        var element2 = this.element, o2 = this.options;
        var bottom_block = $5("<div>").addClass("list-bottom").addClass(o2.clsListBottom).insertAfter(element2);
        var info4, pagination;
        info4 = $5("<div>").addClass("list-info").addClass(o2.clsListInfo).appendTo(bottom_block);
        if (o2.showListInfo !== true) {
          info4.hide();
        }
        pagination = $5("<div>").addClass("list-pagination").addClass(o2.clsListPagination).appendTo(bottom_block);
        if (o2.showPagination !== true) {
          pagination.hide();
        }
        return bottom_block;
      },
      _createStructure: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var list_component;
        var w_search = $5(o2.searchWrapper), w_info = $5(o2.infoWrapper), w_rows = $5(o2.rowsWrapper), w_paging = $5(o2.paginationWrapper);
        if (w_search.length > 0) {
          this.wrapperSearch = w_search;
        }
        if (w_info.length > 0) {
          this.wrapperInfo = w_info;
        }
        if (w_rows.length > 0) {
          this.wrapperRows = w_rows;
        }
        if (w_paging.length > 0) {
          this.wrapperPagination = w_paging;
        }
        if (!element2.parent().hasClass("list-component")) {
          list_component = $5("<div>").addClass("list-component").insertBefore(element2);
          element2.appendTo(list_component);
        } else {
          list_component = element2.parent();
        }
        list_component.addClass(o2.clsComponent);
        this.activity = $5("<div>").addClass("list-progress").appendTo(list_component);
        $5("<div>").activity({
          type: o2.activityType,
          style: o2.activityStyle
        }).appendTo(this.activity);
        if (o2.showActivity !== true) {
          this.activity.css({
            visibility: "hidden"
          });
        }
        element2.addClass(o2.clsList);
        this._createTopBlock();
        this._createBottomBlock();
        if (Utils.isValue(o2.filterString)) {
          this.filterString = o2.filterString;
        }
        var filter_func;
        if (Utils.isValue(o2.filter)) {
          filter_func = Utils.isFunc(o2.filter);
          if (filter_func === false) {
            filter_func = Utils.func(o2.filter);
          }
          that.filterIndex = that.addFilter(filter_func);
        }
        if (Utils.isValue(o2.filters) && typeof o2.filters === "string") {
          $5.each(o2.filters.toArray(), function() {
            filter_func = Utils.isFunc(this);
            if (filter_func !== false) {
              that.filtersIndexes.push(that.addFilter(filter_func));
            }
          });
        }
        this.currentPage = 1;
        if (o2.sortInitial !== false) this.sorting(o2.sortClass, o2.sortDir, true);
        else this.draw();
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var component = element2.parent();
        var search = component.find(".list-search-block input");
        var customSearch;
        function searchItem(e2) {
          that.filterString = this.value.trim().toLowerCase();
          if (that.filterString[that.filterString.length - 1] === ":") {
            return;
          }
          that.currentPage = 1;
          that._draw();
        }
        searchItem = Hooks.useDebounce(searchItem, o2.searchThreshold);
        search.on(Metro2.events.inputchange, searchItem);
        if (Utils.isValue(this.wrapperSearch)) {
          customSearch = this.wrapperSearch.find("input");
          if (customSearch.length > 0) {
            customSearch.on(Metro2.events.inputchange, searchItem);
          }
        }
        function pageLinkClick(l3) {
          var link = $5(l3);
          var item = link.parent();
          if (item.hasClass("active")) {
            return;
          }
          if (item.hasClass("service")) {
            if (link.data("page") === "prev") {
              that.currentPage--;
              if (that.currentPage === 0) {
                that.currentPage = 1;
              }
            } else {
              that.currentPage++;
              if (that.currentPage > that.pagesCount) {
                that.currentPage = that.pagesCount;
              }
            }
          } else {
            that.currentPage = link.data("page");
          }
          that._draw();
        }
        component.on(Metro2.events.click, ".pagination .page-link", function() {
          pageLinkClick(this);
        });
        if (Utils.isValue(this.wrapperPagination)) {
          this.wrapperPagination.on(Metro2.events.click, ".pagination .page-link", function() {
            pageLinkClick(this);
          });
        }
      },
      _info: function(start, stop, length) {
        var element2 = this.element, o2 = this.options;
        var component = element2.parent();
        var info4 = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".list-info");
        var text;
        if (info4.length === 0) {
          return;
        }
        if (stop > length) {
          stop = length;
        }
        if (this.items.length === 0) {
          start = stop = length = 0;
        }
        text = o2.listInfoTitle;
        text = text.replace("$1", start);
        text = text.replace("$2", stop);
        text = text.replace("$3", length);
        info4.html(text);
      },
      _paging: function(length) {
        var element2 = this.element, o2 = this.options;
        var component = element2.parent();
        this.pagesCount = Math.ceil(length / o2.items);
        Metro2.pagination({
          length,
          rows: o2.items,
          current: this.currentPage,
          target: Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".list-pagination"),
          claPagination: o2.clsPagination,
          prevTitle: o2.paginationPrevTitle,
          nextTitle: o2.paginationNextTitle,
          distance: o2.paginationShortMode === true ? o2.paginationDistance : 0
        });
      },
      _filter: function() {
        var that = this, o2 = this.options, items, i3, data, inset, c1, result;
        if (Utils.isValue(this.filterString) || this.filters.length > 0) {
          items = this.items.filter(function(item) {
            data = "";
            if (Utils.isValue(o2.filterClass)) {
              inset = item.getElementsByClassName(o2.filterClass);
              if (inset.length > 0)
                for (i3 = 0; i3 < inset.length; i3++) {
                  data += inset[i3].textContent;
                }
            } else {
              data = item.textContent;
            }
            c1 = data.replace(/[\n\r]+|[\s]{2,}/g, " ").trim().toLowerCase();
            result = Utils.isValue(that.filterString) ? c1.indexOf(that.filterString) > -1 : true;
            if (result === true && that.filters.length > 0) {
              for (i3 = 0; i3 < that.filters.length; i3++) {
                if (Utils.exec(that.filters[i3], [item]) !== true) {
                  result = false;
                  break;
                }
              }
            }
            if (result) {
              that._fireEvent("filter-item-accepted", {
                item
              });
            } else {
              that._fireEvent("filter-item-declined", {
                item
              });
            }
            return result;
          });
          that._fireEvent("search", {
            search: that.filterString,
            items
          });
        } else {
          items = this.items;
        }
        return items;
      },
      _draw: function(cb) {
        var element2 = this.element, o2 = this.options;
        var i3;
        var start = o2.items === -1 ? 0 : o2.items * (this.currentPage - 1), stop = o2.items === -1 ? this.items.length - 1 : start + o2.items - 1;
        var items;
        items = this._filter();
        element2.children(o2.itemTag).remove();
        for (i3 = start; i3 <= stop; i3++) {
          if (Utils.isValue(items[i3])) {
            $5(items[i3]).addClass(o2.clsListItem).appendTo(element2);
          }
          this._fireEvent("draw-item", {
            item: items[i3]
          });
        }
        this._info(start + 1, stop + 1, items.length);
        this._paging(items.length);
        this.activity.hide();
        this._fireEvent("draw");
        if (cb) {
          Utils.exec(cb, [element2], element2[0]);
        }
      },
      _getItemContent: function(item) {
        const locale = this.locale;
        var o2 = this.options, $item = $5(item);
        var i3, inset, data;
        var format, formatMask = Utils.isValue($item.data("formatMask")) ? $item.data("formatMask") : null;
        if (Utils.isValue(o2.sortClass)) {
          data = "";
          inset = $5(item).find("." + o2.sortClass);
          if (inset.length > 0)
            for (i3 = 0; i3 < inset.length; i3++) {
              data += inset[i3].textContent;
            }
          format = inset.length > 0 ? inset[0].getAttribute("data-format") : "";
        } else {
          data = item.textContent;
          format = item.getAttribute("data-format");
        }
        data = ("" + data).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, " ").trim();
        if (Utils.isValue(format)) {
          if (["number", "int", "integer", "float", "money"].indexOf(format) !== -1 && (o2.thousandSeparator !== "," || o2.decimalSeparator !== ".")) {
            data = Utils.parseNumber(data, o2.thousandSeparator, o2.decimalSeparator);
          }
          switch (format) {
            case "date":
              data = formatMask ? Datetime.from(data, formatMask, locale) : datetime(data);
              break;
            case "number":
              data = Number(data);
              break;
            case "int":
            case "integer":
              data = parseInt(data);
              break;
            case "float":
              data = parseFloat(data);
              break;
            case "money":
              data = Utils.parseMoney(data);
              break;
            case "card":
              data = Utils.parseCard(data);
              break;
            case "phone":
              data = Utils.parsePhone(data);
              break;
          }
        }
        return data;
      },
      deleteItem: function(value) {
        var i3, deleteIndexes = [], item;
        var is_func = Utils.isFunc(value);
        for (i3 = 0; i3 < this.items.length; i3++) {
          item = this.items[i3];
          if (is_func) {
            if (Utils.exec(value, [item])) {
              deleteIndexes.push(i3);
            }
          } else {
            if (item.textContent.includes(value)) {
              deleteIndexes.push(i3);
            }
          }
        }
        this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);
        return this;
      },
      draw: function() {
        return this._draw();
      },
      sorting: function(source, dir, redraw) {
        var that = this, o2 = this.options;
        if (Utils.isValue(source)) {
          o2.sortClass = source;
        }
        if (Utils.isValue(dir) && ["asc", "desc"].indexOf(dir) > -1) {
          o2.sortDir = dir;
        }
        this._fireEvent("sort-start", {
          items: this.items
        });
        this.items.sort(function(a3, b4) {
          var c1 = that._getItemContent(a3);
          var c22 = that._getItemContent(b4);
          var result = 0;
          if (c1 < c22) {
            result = o2.sortDir === "asc" ? -1 : 1;
          }
          if (c1 > c22) {
            result = o2.sortDir === "asc" ? 1 : -1;
          }
          if (result !== 0) {
            that._fireEvent("sort-item-switch", {
              a: a3,
              b: b4,
              result
            });
          }
          return result;
        });
        this._fireEvent("sort-stop", {
          items: this.items
        });
        if (redraw === true) {
          this._draw();
        }
        return this;
      },
      filter: function(val) {
        this.filterString = val.trim().toLowerCase();
        this.currentPage = 1;
        this._draw();
      },
      setData: function(data) {
        var that = this, element2 = this.element, o2 = this.options;
        if (Utils.isValue(data) !== true) {
          return;
        }
        that._createItemsFromJSON(data);
        element2.html("");
        if (Utils.isValue(o2.filterString)) {
          that.filterString = o2.filterString;
        }
        var filter_func;
        if (Utils.isValue(o2.filter)) {
          filter_func = Utils.isFunc(o2.filter);
          if (filter_func === false) {
            filter_func = Utils.func(o2.filter);
          }
          that.filterIndex = that.addFilter(filter_func);
        }
        if (Utils.isValue(o2.filters) && typeof o2.filters === "string") {
          $5.each(o2.filters.toArray(), function() {
            filter_func = Utils.isFunc(this);
            if (filter_func !== false) {
              that.filtersIndexes.push(that.addFilter(filter_func));
            }
          });
        }
        that.currentPage = 1;
        that.sorting(o2.sortClass, o2.sortDir, true);
      },
      loadData: function(source) {
        var that = this, o2 = this.options;
        if (Utils.isValue(source) !== true) {
          return;
        }
        o2.source = source;
        this._fireEvent("data-load", {
          source: o2.source
        });
        fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then(function(data) {
          that._fireEvent("data-loaded", {
            source: o2.source,
            data
          });
          that.setData(data);
        }).catch(function(error) {
          that._fireEvent("data-load-error", {
            source: o2.source,
            error
          });
        });
      },
      next: function() {
        if (this.items.length === 0) return;
        this.currentPage++;
        if (this.currentPage > this.pagesCount) {
          this.currentPage = this.pagesCount;
          return;
        }
        this._draw();
      },
      prev: function() {
        if (this.items.length === 0) return;
        this.currentPage--;
        if (this.currentPage === 0) {
          this.currentPage = 1;
          return;
        }
        this._draw();
      },
      first: function() {
        if (this.items.length === 0) return;
        this.currentPage = 1;
        this._draw();
      },
      last: function() {
        if (this.items.length === 0) return;
        this.currentPage = this.pagesCount;
        this._draw();
      },
      page: function(num) {
        if (num <= 0) {
          num = 1;
        }
        if (num > this.pagesCount) {
          num = this.pagesCount;
        }
        this.currentPage = num;
        this._draw();
      },
      addFilter: function(f5, redraw) {
        var func = Utils.isFunc(f5);
        if (func === false) {
          return;
        }
        this.filters.push(func);
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return this.filters.length - 1;
      },
      removeFilter: function(key, redraw) {
        Utils.arrayDeleteByKey(this.filters, key);
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return this;
      },
      removeFilters: function(redraw) {
        this.filters = [];
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
      },
      getFilters: function() {
        return this.filters;
      },
      getFilterIndex: function() {
        return this.filterIndex;
      },
      getFiltersIndexes: function() {
        return this.filtersIndexes;
      },
      changeAttribute: function(attributeName) {
        var that = this, element2 = this.element, o2 = this.options;
        var changeSortDir = function() {
          var dir = element2.attr("data-sort-dir");
          if (!Utils.isValue(dir)) {
            return;
          }
          o2.sortDir = dir;
          that.sorting(o2.sortClass, o2.sortDir, true);
        };
        var changeSortClass = function() {
          var target = element2.attr("data-sort-source");
          if (!Utils.isValue(target)) {
            return;
          }
          o2.sortClass = target;
          that.sorting(o2.sortClass, o2.sortDir, true);
        };
        var changeFilterString = function() {
          var filter = element2.attr("data-filter-string");
          if (!Utils.isValue(filter)) {
            return;
          }
          o2.filterString = filter;
          that.filter(o2.filterString);
        };
        switch (attributeName) {
          case "data-sort-dir":
            changeSortDir();
            break;
          case "data-sort-source":
            changeSortClass();
            break;
          case "data-filter-string":
            changeFilterString();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element;
        var component = element2.parent();
        var search = component.find(".list-search-block input");
        var customSearch;
        search.off(Metro2.events.inputchange);
        if (Utils.isValue(this.wrapperSearch)) {
          customSearch = this.wrapperSearch.find("input");
          if (customSearch.length > 0) {
            customSearch.off(Metro2.events.inputchange);
          }
        }
        component.off(Metro2.events.click, ".pagination .page-link");
        if (Utils.isValue(this.wrapperPagination)) {
          this.wrapperPagination.off(Metro2.events.click, ".pagination .page-link");
        }
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/listview/listview.js
  (function(Metro2, $5) {
    "use strict";
    const file_icon = `
    <svg width="800px" height="800px" fill="none" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
        <path class="a" d="M39.5,15.5h-9a2,2,0,0,1-2-2v-9h-18a2,2,0,0,0-2,2v35a2,2,0,0,0,2,2h27a2,2,0,0,0,2-2Z"/>
        <line class="a" x1="28.5" y1="4.5" x2="39.5" y2="15.5"/>
    </svg>`;
    const toggleImage = `<svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path></svg>`;
    let ListViewDefaultConfig = {
      listviewDeferred: 0,
      selectable: false,
      duration: 100,
      view: Metro2.listView.LIST,
      selectCurrent: true,
      defaultIcon: file_icon,
      onNodeInsert: Metro2.noop,
      onNodeDelete: Metro2.noop,
      onNodeClean: Metro2.noop,
      onCollapseNode: Metro2.noop,
      onExpandNode: Metro2.noop,
      onGroupNodeClick: Metro2.noop,
      onNodeClick: Metro2.noop,
      onNodeDblclick: Metro2.noop,
      onListViewCreate: Metro2.noop
    };
    Metro2.listViewSetup = function(options) {
      ListViewDefaultConfig = $5.extend({}, ListViewDefaultConfig, options);
    };
    if (typeof globalThis["metroListViewSetup"] !== "undefined") {
      Metro2.listViewSetup(globalThis["metroListViewSetup"]);
    }
    Metro2.Component("listview", {
      init: function(options, elem) {
        this._super(elem, options, ListViewDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("listview-create", {
          element: element2
        });
      },
      _createIcon: function(data) {
        return $5("<div>").addClass("icon").html(data);
      },
      _createCaption: function(data = "") {
        return $5("<div>").addClass("caption").html(data);
      },
      _createContent: function(data = "") {
        return $5("<div>").addClass("content").html(data);
      },
      _createDesc: function(data = "") {
        return $5("<div>").addClass("desc").html(data);
      },
      _createDate: function(data = "") {
        return $5("<div>").addClass("date").html(data);
      },
      _createToggle: function() {
        return $5("<span>").addClass("node-toggle").html(toggleImage);
      },
      _createNode: function(data) {
        const that = this, o2 = this.options;
        const node = $5("<li>");
        node.append($5("<input type='checkbox' data-role='checkbox'>").data("node", node));
        node.append(that._createIcon(data.icon ?? o2.defaultIcon));
        node.append(that._createCaption(data.caption));
        node.append(that._createDesc(data.desc));
        node.append(that._createDate(data.date));
        node.append(that._createContent(data.content));
        return node;
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const nodes = element2.find("li");
        element2.addClass("listview");
        element2.find("ul").addClass("listview");
        if (o2.selectable) {
          element2.addClass("selectable");
        }
        $5.each(nodes, function(index) {
          const node = $5(this);
          const nodeContent = node.html();
          const defaultFileName = `Item_${index + 1}`;
          if (node.children("ul").length > 0) {
            node.prepend(that._createCaption(node.data("caption") ?? defaultFileName));
            node.addClass("node-group");
            node.append(that._createToggle());
            if (node.data("collapsed") !== true) node.addClass("expanded");
          } else {
            node.clear().addClass("node");
            node.append($5("<input type='checkbox' data-role='checkbox'>").data("node", node));
            node.append(that._createIcon(node.data("icon") ?? o2.defaultIcon));
            node.append(that._createCaption(node.data("caption") ?? defaultFileName));
            node.append(that._createDesc(node.data("desc")));
            node.append(that._createDate(node.data("date")));
            node.append(that._createContent(nodeContent));
          }
        });
        if (o2.selectable) {
          element2.addClass("selectable");
        }
        this.view(o2.view);
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.dblclick, ".node", function() {
          const node = $5(this);
          that._fireEvent("node-dblclick", {
            node
          });
        });
        element2.on(Metro2.events.click, ".node", function() {
          const node = $5(this);
          const href = $5(this).attr("href");
          if (href) {
            globalThis.location.href = href;
            return;
          }
          const isCurrent = node.hasClass("current");
          element2.find(".node").removeClass("current");
          if (!isCurrent) {
            node.addClass("current");
          }
          if (o2.selectCurrent === true) {
            element2.find(".node").removeClass("current-select");
            if (!isCurrent) {
              node.addClass("current-select");
            }
          }
          that._fireEvent("node-click", {
            node
          });
        });
        element2.on(Metro2.events.click, ".node-toggle", function() {
          const node = $5(this).closest("li");
          that.toggleNode(node);
        });
        element2.on(Metro2.events.click, ".node-group > .caption", function() {
          const node = $5(this).closest("li");
          element2.find(".node-group").removeClass("current-group");
          node.addClass("current-group");
          that._fireEvent("group-node-click", {
            node
          });
        });
        element2.on(Metro2.events.dblclick, ".node-group > .caption", function() {
          const node = $5(this).closest("li");
          that.toggleNode(node);
          that._fireEvent("node-dbl-click", {
            node
          });
        });
      },
      view: function(v4) {
        const element2 = this.element, o2 = this.options;
        if (v4 === void 0) {
          return o2.view;
        }
        o2.view = v4;
        $5.each(Metro2.listView, function(i3, v5) {
          element2.removeClass("view-" + v5);
          element2.find("ul").removeClass("view-" + v5);
        });
        element2.addClass("view-" + o2.view);
        element2.find("ul").addClass("view-" + o2.view);
      },
      toggleNode: function(node) {
        const o2 = this.options;
        let func;
        node = $5(node);
        if (!node.hasClass("node-group")) {
          return;
        }
        node.toggleClass("expanded");
        func = node.hasClass("expanded") !== true ? "slideUp" : "slideDown";
        this._fireEvent("collapse-node", {
          node
        });
        node.children("ul")[func](o2.duration);
      },
      toggleSelectable: function() {
        const element2 = this.element, o2 = this.options;
        o2.selectable = !o2.selectable;
        const func = o2.selectable === true ? "addClass" : "removeClass";
        console.log(func);
        element2[func]("selectable");
        element2.find("ul")[func]("selectable");
      },
      add: function(data, node = null) {
        const element2 = this.element, o2 = this.options;
        let target;
        let new_node;
        let toggle;
        if (node === null) {
          target = element2;
        } else {
          node = $5(node);
          if (!node.hasClass("node-group")) {
            return;
          }
          target = node.children("ul");
          if (target.length === 0) {
            target = $5("<ul>").addClass("listview").addClass("view-" + o2.view).appendTo(node);
            toggle = this._createToggle();
            toggle.appendTo(node);
            node.addClass("expanded");
          }
        }
        new_node = this._createNode(data);
        new_node.addClass("node").appendTo(target);
        const cb = $5("<input type='checkbox'>");
        cb.data("node", new_node);
        new_node.prepend(cb);
        Metro2.makePlugin(cb, "checkbox", {});
        this._fireEvent("node-insert", {
          newNode: new_node,
          parentNode: node,
          list: target
        });
        return new_node;
      },
      addGroup: function(data) {
        const element2 = this.element, o2 = this.options;
        let node;
        delete data["icon"];
        node = this._createNode(data);
        node.addClass("node-group").appendTo(element2);
        node.append(this._createToggle());
        node.addClass("expanded");
        node.append($5("<ul>").addClass("listview").addClass("view-" + o2.view));
        this._fireEvent("node-insert", {
          newNode: node,
          parentNode: null,
          list: element2
        });
        return node;
      },
      insertBefore: function(data, node) {
        let new_node, parent_node, list;
        node = $5(node);
        if (!node.length) {
          return;
        }
        new_node = this._createNode(data);
        new_node.addClass("node").insertBefore(node);
        parent_node = new_node.closest(".node");
        list = new_node.closest("ul");
        this._fireEvent("node-insert", {
          newNode: new_node,
          parentNode: parent_node,
          list
        });
        return new_node;
      },
      insertAfter: function(data, node) {
        let new_node, parent_node, list;
        node = $5(node);
        if (!node.length) {
          return;
        }
        new_node = this._createNode(data);
        new_node.addClass("node").insertAfter(node);
        parent_node = new_node.closest(".node");
        list = new_node.closest("ul");
        this._fireEvent("node-insert", {
          newNode: new_node,
          parentNode: parent_node,
          list
        });
        return new_node;
      },
      del: function(node) {
        const element2 = this.element;
        node = $5(node);
        if (!node.length) {
          return;
        }
        const parent_list = node.closest("ul");
        const parent_node = parent_list.closest("li");
        node.remove();
        if (parent_list.children().length === 0 && !parent_list.is(element2)) {
          parent_list.remove();
          parent_node.removeClass("expanded");
          parent_node.children(".node-toggle").remove();
        }
        this._fireEvent("node-delete", {
          node
        });
      },
      clean: function(node) {
        node = $5(node);
        if (!node.length) {
          return;
        }
        node.children("ul").remove();
        node.removeClass("expanded");
        node.children(".node-toggle").remove();
        this._fireEvent("node-clean", {
          node
        });
      },
      getSelected: function() {
        const element2 = this.element;
        const nodes = [];
        $5.each(element2.find(":checked"), function() {
          const check = $5(this);
          nodes.push(check.closest(".node")[0]);
        });
        return nodes;
      },
      clearSelected: function() {
        this.element.find(":checked").prop("checked", false);
        this.element.trigger("change");
      },
      selectAll: function(mode = true) {
        this.element.find(".checkbox input").prop("checked", mode);
        this.element.trigger("change");
      },
      selectByAttribute: function(attributeName, attributeValue, select = true) {
        this.element.find("li[" + attributeName + '="' + attributeValue + '"] > .checkbox input').prop("checked", select);
        this.element.trigger("change");
      },
      changeAttribute: function(attributeName) {
        const that = this, element2 = this.element, o2 = this.options;
        const changeView = function() {
          const new_view = "view-" + element2.attr("data-view");
          that.view(new_view);
        };
        const changeSelectable = function() {
          o2.selectable = JSON.parse(element2.attr("data-selectable")) === true;
          that.toggleSelectable();
        };
        switch (attributeName) {
          case "data-view":
            changeView();
            break;
          case "data-selectable":
            changeSelectable();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".node");
        element2.off(Metro2.events.click, ".node-toggle");
        element2.off(Metro2.events.click, ".node-group > .caption");
        element2.off(Metro2.events.dblclick, ".node-group > .caption");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/marquee/marquee.js
  (function(Metro2, $5) {
    "use strict";
    var MarqueeDefaultConfig = {
      items: null,
      loop: true,
      height: "auto",
      width: "100%",
      duration: 1e4,
      direction: "left",
      ease: "linear",
      mode: "default",
      // default || accent
      accentPause: 2e3,
      firstPause: 1e3,
      stopOnHover: true,
      clsMarquee: "",
      clsMarqueeItem: "",
      onMarqueeItem: Metro2.noop,
      onMarqueeItemComplete: Metro2.noop,
      onMarqueeComplete: Metro2.noop,
      onMarqueeCreate: Metro2.noop
    };
    Metro2.marqueeSetup = function(options) {
      MarqueeDefaultConfig = $5.extend({}, MarqueeDefaultConfig, options);
    };
    if (typeof globalThis["metroMarqueeSetup"] !== "undefined") {
      Metro2.marqueeSetup(globalThis["metroMarqueeSetup"]);
    }
    Metro2.Component("marquee", {
      init: function(options, elem) {
        this._super(elem, options, MarqueeDefaultConfig, {
          // define instance vars here
          origin: null,
          items: [],
          running: false,
          current: -1,
          chain: []
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("marquee-create");
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        element2.addClass("marquee").addClass(o2.clsMarquee);
        element2.css({
          height: o2.height,
          width: o2.width
        });
        const items = element2.html().split("\n").map((a3) => a3.trim()).filter((a3) => a3.length);
        const itemsFromOptions = Metro2.utils.isObject(o2.items) || [];
        this.origin = [...items, ...itemsFromOptions];
        this.setItems(this.origin, true);
        if (this.items.length) {
          this.current = 0;
          this.createChain();
          console.log(this.chain);
          this.start();
        }
      },
      setItems: function(items, replace = true) {
        const element2 = this.element, o2 = this.options;
        const dir = o2.direction.toLowerCase();
        if (replace) {
          this.items.length = 0;
        }
        element2.clear();
        this.items = items.map((item) => {
          return $5("<div>").html(item).addClass("marquee__item").addClass(o2.clsMarqueeItem).appendTo(element2)[0];
        });
        $5(this.items).addClass(dir === "left" || dir === "right" ? "moveLeftRight" : "moveUpDown");
        if (o2.height === "auto") {
          let h3 = 0;
          $5(this.items).each(function() {
            const el = $5(this);
            const eh = +el.outerHeight(true);
            if (eh > h3) {
              h3 = eh;
            }
          });
          element2.height(h3);
        }
        return this;
      },
      setItem: function(index, value) {
        var target = $5(this.items[index]), h3, o2 = this.options, element2 = this.element;
        if (!target.length) {
          return;
        }
        target.html(value);
        h3 = target.outerHeight(true);
        if (o2.height === "auto" && element2.height() < h3) {
          element2.height(h3);
        }
        return this;
      },
      addItem: function(item, index = -1) {
        var element2 = this.element, o2 = this.options;
        var ins, $item = $5(item), trg, h3;
        ins = $item.length ? $item : $5("<div>").html(item);
        if (index < 0) {
          element2.append(ins);
        } else {
          trg = this.items[index];
          if (trg) {
            ins.insertBefore(trg);
          } else {
            element2.append(ins);
          }
        }
        h3 = ins.outerHeight(true);
        if (o2.height === "auto" && element2.height() < h3) {
          element2.height(h3);
        }
        return this;
      },
      createChain: function() {
        const element2 = this.element, o2 = this.options, magic = 20;
        let dir = o2.direction;
        let ease = o2.ease;
        let dur = +o2.duration;
        let i3 = 0;
        let rect = element2[0].getBoundingClientRect();
        this.chain.length = 0;
        if (o2.mode === "default") {
          for (const item of this.items) {
            const el = $5(item);
            const elRect = item.getBoundingClientRect();
            const half = (rect.width - elRect.width) / 2;
            let draw;
            if (el.attr("data-direction")) {
              dir = el.attr("data-direction");
            }
            if (el.attr("data-duration")) {
              dur = +el.attr("data-duration");
            }
            if (el.attr("data-ease")) {
              ease = el.attr("data-ease");
            } else {
              ease = o2.ease;
            }
            if (["left", "right"].indexOf(dir) > -1) {
              draw = {
                left: dir === "left" ? [rect.width, -elRect.width - magic] : [-elRect.width - magic, rect.width]
              };
            } else {
              draw = {
                top: dir === "up" ? [rect.height, -elRect.height - magic] : [-elRect.height - magic, rect.height]
              };
            }
            this.chain.push({
              el: el[0],
              draw,
              dur,
              ease,
              defer: i3 === 0 ? +o2.firstPause : 0
            });
            i3++;
          }
        } else {
          for (const item of this.items) {
            const el = $5(item);
            const elRect = item.getBoundingClientRect();
            const halfW = (rect.width - elRect.width) / 2;
            const halfH = (rect.height - elRect.height) / 2;
            let draw1, draw2;
            dur = o2.duration / 2;
            if (el.attr("data-direction")) {
              dir = el.attr("data-direction").toLowerCase();
            }
            if (el.attr("data-duration")) {
              dur = +el.attr("data-duration") / 2;
            }
            let _ease = ease ? ease.split(" ") : ["linear"];
            if (el.attr("data-ease")) {
              _ease = el.attr("data-ease").split(" ");
            }
            if (["left", "right"].includes(dir)) {
              draw1 = {
                left: dir === "left" ? [rect.width, halfW] : [-elRect.width - magic, halfW]
              };
              draw2 = {
                left: dir === "left" ? [halfW, -elRect.width - magic] : [halfW, rect.width + magic]
              };
            } else {
              draw1 = {
                top: dir === "up" ? [rect.height, halfH] : [-elRect.height - magic, halfH]
              };
              draw2 = {
                top: dir === "up" ? [halfH, -elRect.height - magic] : [halfH, rect.height + magic]
              };
            }
            this.chain.push({
              el: el[0],
              draw: draw1,
              dur,
              ease: _ease[0] || "linear",
              defer: i3 === 0 ? +o2.firstPause : 0
            });
            this.chain.push({
              el: el[0],
              draw: draw2,
              dur,
              ease: _ease[1] ? _ease[1] : _ease[0] ? _ease[0] : "linear",
              defer: +o2.accentPause
            });
            i3++;
          }
        }
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.enter, function() {
          if (o2.stopOnHover)
            $5.pauseAll(that.items);
        });
        element2.on(Metro2.events.leave, function() {
          if (o2.stopOnHover)
            $5.resumeAll(that.items);
        });
        const resize = Hooks.useDebounce((e2) => {
          that.stop();
          that.setItems(this.items, true);
          that.createChain();
          that.start();
        }, 1e3);
        $5(window).on(Metro2.events.resize, resize);
      },
      start: function() {
        const o2 = this.options;
        this.running = true;
        $5.chain(this.chain, {
          loop: o2.loop,
          onChainItem: Metro2.utils.isFunc(o2.onMarqueeItem),
          onChainItemComplete: Metro2.utils.isFunc(o2.onMarqueeItemComplete),
          onChainComplete: Metro2.utils.isFunc(o2.onMarqueeComplete)
        });
        return this;
      },
      stop: function() {
        this.running = false;
        $5.stopAll(false);
        return this;
      },
      changeAttribute: function() {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/master/master.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var MasterDefaultConfig = {
      masterDeferred: 0,
      effect: "slide",
      // slide, fade, switch, slowdown, custom
      effectFunc: "linear",
      duration: METRO_ANIMATION_DURATION,
      controlPrev: "\u{1F850}",
      controlNext: "\u{1F852}",
      controlTitle: "Master, page $1 of $2",
      backgroundImage: "",
      clsMaster: "",
      clsControls: "",
      clsControlPrev: "",
      clsControlNext: "",
      clsControlTitle: "",
      clsPages: "",
      clsPage: "",
      onBeforePage: Metro2.noop_true,
      onBeforeNext: Metro2.noop_true,
      onBeforePrev: Metro2.noop_true,
      onNextPage: Metro2.noop,
      onPrevPage: Metro2.noop,
      onMasterCreate: Metro2.noop
    };
    Metro2.masterSetup = function(options) {
      MasterDefaultConfig = $5.extend({}, MasterDefaultConfig, options);
    };
    if (typeof globalThis["metroMasterSetup"] !== "undefined") {
      Metro2.masterSetup(globalThis["metroMasterSetup"]);
    }
    Metro2.Component("master", {
      init: function(options, elem) {
        this._super(elem, options, MasterDefaultConfig, {
          pages: [],
          currentIndex: 0,
          isAnimate: false,
          id: Utils.elementId("master")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        element2.addClass("master").addClass(o2.clsMaster);
        element2.css({
          backgroundImage: "url(" + o2.backgroundImage + ")"
        });
        this._createControls();
        this._createPages();
        this._createEvents();
        this._fireEvent("master-create", {
          element: element2
        });
      },
      _createControls: function() {
        var element2 = this.element, o2 = this.options;
        var controls_position = ["top", "bottom"];
        var controls, title, pages = element2.find(".page");
        title = String(o2.controlTitle).replace("$1", "1");
        title = String(title).replace("$2", pages.length);
        $5.each(controls_position, function() {
          controls = $5("<div>").addClass("controls controls-" + this).addClass(o2.clsControls).appendTo(element2);
          $5("<span>").addClass("prev").addClass(o2.clsControlPrev).html(o2.controlPrev).appendTo(controls);
          $5("<span>").addClass("next").addClass(o2.clsControlNext).html(o2.controlNext).appendTo(controls);
          $5("<span>").addClass("title").addClass(o2.clsControlTitle).html(title).appendTo(controls);
        });
        this._enableControl("prev", false);
      },
      _enableControl: function(type, state2) {
        var control = this.element.find(".controls ." + type);
        if (state2 === true) {
          control.removeClass("disabled");
        } else {
          control.addClass("disabled");
        }
      },
      _setTitle: function() {
        var title = this.element.find(".controls .title");
        var title_str = this.options.controlTitle.replace("$1", this.currentIndex + 1);
        title_str = title_str.replace("$2", String(this.pages.length));
        title.html(title_str);
      },
      _createPages: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var pages = element2.find(".pages");
        var page = element2.find(".page");
        if (pages.length === 0) {
          pages = $5("<div>").addClass("pages").appendTo(element2);
        }
        pages.addClass(o2.clsPages);
        $5.each(page, function() {
          var p3 = $5(this);
          if (p3.data("cover")) {
            element2.css({
              backgroundImage: "url(" + p3.data("cover") + ")"
            });
          } else {
            element2.css({
              backgroundImage: "url(" + o2.backgroundImage + ")"
            });
          }
          p3.css({
            left: "100%"
          });
          p3.addClass(o2.clsPage).hide(0);
          that.pages.push(p3);
        });
        page.appendTo(pages);
        this.currentIndex = 0;
        if (this.pages[this.currentIndex] !== void 0) {
          if (this.pages[this.currentIndex].data("cover") !== void 0) {
            element2.css({
              backgroundImage: "url(" + this.pages[this.currentIndex].data("cover") + ")"
            });
          }
          this.pages[this.currentIndex].css("left", "0").show(0);
          setTimeout(function() {
            pages.css({
              height: that.pages[0].outerHeight(true) + 2
            });
          }, 0);
        }
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.click, ".controls .prev", function() {
          if (that.isAnimate === true) {
            return;
          }
          if (Utils.exec(o2.onBeforePrev, [that.currentIndex, that.pages[that.currentIndex], element2]) === true && Utils.exec(o2.onBeforePage, ["prev", that.currentIndex, that.pages[that.currentIndex], element2]) === true) {
            that.prev();
          }
        });
        element2.on(Metro2.events.click, ".controls .next", function() {
          if (that.isAnimate === true) {
            return;
          }
          if (Utils.exec(o2.onBeforeNext, [that.currentIndex, that.pages[that.currentIndex], element2]) === true && Utils.exec(o2.onBeforePage, ["next", that.currentIndex, that.pages[that.currentIndex], element2]) === true) {
            that.next();
          }
        });
        $5(globalThis).on(Metro2.events.resize, function() {
          element2.find(".pages").height(that.pages[that.currentIndex].outerHeight(true) + 2);
        }, { ns: this.id });
      },
      _slideToPage: function(index) {
        var current, next, to2;
        if (this.pages[index] === void 0) {
          return;
        }
        if (this.currentIndex === index) {
          return;
        }
        to2 = index > this.currentIndex ? "next" : "prev";
        current = this.pages[this.currentIndex];
        next = this.pages[index];
        this.currentIndex = index;
        this._effect(current, next, to2);
      },
      _slideTo: function(to2) {
        var current, next, forward = to2.toLowerCase() === "next";
        current = this.pages[this.currentIndex];
        if (forward) {
          if (this.currentIndex + 1 >= this.pages.length) {
            return;
          }
          this.currentIndex++;
        } else {
          if (this.currentIndex - 1 < 0) {
            return;
          }
          this.currentIndex--;
        }
        next = this.pages[this.currentIndex];
        this._fireEvent(forward ? "next-page" : "prev-page", {
          current,
          next,
          forward
        });
        this._effect(current, next, to2);
      },
      _effect: function(current, next, to2) {
        var that = this, element2 = this.element, o2 = this.options;
        var out = element2.width();
        var pages = element2.find(".pages");
        this._setTitle();
        if (this.currentIndex === this.pages.length - 1) {
          this._enableControl("next", false);
        } else {
          this._enableControl("next", true);
        }
        if (this.currentIndex === 0) {
          this._enableControl("prev", false);
        } else {
          this._enableControl("prev", true);
        }
        setTimeout(function() {
          that.isAnimate = true;
          pages.animate({
            draw: {
              height: next.outerHeight(true) + 2
            },
            onDone: function() {
              finish();
            }
          });
        }, 0);
        pages.css("overflow", "hidden");
        function finish() {
          if (next.data("cover") !== void 0) {
            element2.css({
              backgroundImage: "url(" + next.data("cover") + ")"
            });
          } else {
            element2.css({
              backgroundImage: "url(" + o2.backgroundImage + ")"
            });
          }
          pages.css("overflow", "initial");
          that.isAnimate = false;
        }
        function _slide() {
          current.stop(true).animate({
            draw: {
              left: to2 === "next" ? -out : out
            },
            dur: o2.duration,
            ease: o2.effectFunc,
            onDone: function() {
              current.hide(0);
            }
          });
          next.stop(true).css({
            left: to2 === "next" ? out : -out
          }).show(0).animate({
            draw: {
              left: 0
            },
            dur: o2.duration,
            ease: o2.effectFunc,
            onDone: function() {
              finish();
            }
          });
        }
        function _switch() {
          current.hide();
          next.css({
            top: 0,
            left: 0,
            opacity: 0
          }).show(function() {
            finish();
          });
        }
        function _fade() {
          current.fadeOut(o2.duration);
          next.css({
            top: 0,
            left: 0,
            opacity: 0
          }).fadeIn(o2.duration, "linear", function() {
            finish();
          });
        }
        switch (o2.effect) {
          case "fade":
            _fade();
            break;
          case "switch":
            _switch();
            break;
          default:
            _slide();
        }
      },
      toPage: function(index) {
        this._slideToPage(index);
      },
      next: function() {
        this._slideTo("next");
      },
      prev: function() {
        this._slideTo("prev");
      },
      changeEffect: function() {
        this.options.effect = this.element.attr("data-effect");
      },
      changeEffectFunc: function() {
        this.options.effectFunc = this.element.attr("data-effect-func");
      },
      changeEffectDuration: function() {
        this.options.duration = this.element.attr("data-duration");
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-effect":
            this.changeEffect();
            break;
          case "data-effect-func":
            this.changeEffectFunc();
            break;
          case "data-duration":
            this.changeEffectDuration();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.click, ".controls .prev");
        element2.off(Metro2.events.click, ".controls .next");
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/navview/navview.js
  (function(Metro2, $5) {
    "use strict";
    let NavigationViewDefaultConfig = {
      navviewDeferred: 0,
      expandPoint: null,
      // compacted: false,
      toggle: null,
      animate: true,
      activeState: true,
      initialView: "expand",
      onMenuItemClick: Metro2.noop,
      onPaneClose: Metro2.noop,
      onBeforePaneClose: Metro2.noop,
      onPaneOpen: Metro2.noop,
      onBeforePaneOpen: Metro2.noop,
      onNavviewCreate: Metro2.noop
    };
    Metro2.navViewSetup = function(options) {
      NavigationViewDefaultConfig = $5.extend({}, NavigationViewDefaultConfig, options);
    };
    if (typeof globalThis["metroNavViewSetup"] !== "undefined") {
      Metro2.navViewSetup(globalThis["metroNavViewSetup"]);
    }
    Metro2.Component("nav-view", {
      init: function(options, elem) {
        this._super(elem, options, NavigationViewDefaultConfig, {
          pane: null,
          content: null,
          paneToggle: null,
          id: null,
          menuScrollDistance: 0,
          menuScrollStep: 0
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("navview-create");
      },
      _calcMenuHeight: function() {
        let element2 = this.element, pane, menu_container;
        let elements_height = 0;
        pane = element2.children(".navview-pane");
        if (pane.length === 0) {
          return;
        }
        menu_container = pane.children(".navview-menu-container");
        if (menu_container.length === 0) {
          return;
        }
        $5.each(menu_container.prevAll(), function() {
          elements_height += $5(this).outerHeight(true);
        });
        $5.each(menu_container.nextAll(), function() {
          elements_height += $5(this).outerHeight(true);
        });
        menu_container.css({
          height: "calc(100% - " + elements_height + "px)"
        });
        this.menuScrollStep = 48;
        this.menuScrollDistance = Metro2.utils.nearest(menu_container[0].scrollHeight - menu_container.height(), 48);
      },
      _recalc: function() {
        const that = this;
        setTimeout(function() {
          that._calcMenuHeight();
        }, 200);
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        let pane, content, toggle, menu;
        element2.addClass("navview");
        if (element2.attr("id") === void 0) {
          this.id = Metro2.utils.elementId("navview");
          element2.attr("id", this.id);
        } else {
          this.id = element2.attr("id");
        }
        if (o2.initialView !== "compact" && Metro2.utils.mediaExist(o2.expandPoint)) {
          element2.addClass("expanded");
        } else {
          element2.addClass("compacted handmade");
        }
        const state2 = Metro2.storage.getItem("navview:compacted");
        if (state2 === true) {
          element2.removeClass("expanded");
          element2.addClass("compacted handmade");
        }
        pane = element2.children(".navview-pane");
        content = element2.children(".navview-content");
        toggle = $5(o2.toggle);
        menu = pane.children(".navview-menu");
        if (menu.length) {
          menu.prevAll().reverse().wrapAll($5("<div>").addClass("navview-container"));
          menu.wrap($5("<div>").addClass("navview-menu-container"));
          menu.find("a").each(function() {
            const a3 = $5(this);
            const icon = a3.children(".icon");
            const caption = a3.children(".caption");
            if (!icon.length) {
              a3.prepend($5("<span>").addClass("icon").html(caption.text()[0]));
            }
          });
        }
        this.pane = pane.length > 0 ? pane : null;
        this.content = content.length > 0 ? content : null;
        this.paneToggle = toggle.length > 0 ? toggle : null;
        if (o2.animate) {
          element2.addClass("animate-panes");
        }
        this._recalc();
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const menu_container = element2.find(".navview-menu-container");
        const menu = menu_container.children(".navview-menu");
        menu_container.on(
          "mousewheel",
          function(e2) {
            const pane_width = element2.find(".navview-pane").width();
            const dir = e2.deltaY > 0 ? -1 : 1;
            const step = that.menuScrollStep;
            const distance = that.menuScrollDistance;
            const top = parseInt(menu.css("top"));
            if (pane_width > 50) {
              return false;
            }
            if (dir === -1 && Math.abs(top) <= distance) {
              menu.css("top", parseInt(menu.css("top")) + step * dir);
            }
            if (dir === 1 && top <= -step) {
              menu.css("top", parseInt(menu.css("top")) + step * dir);
            }
          },
          {
            passive: true
          }
        );
        element2.on(Metro2.events.click, ".pull-button", function() {
          that._pullClick(this, "pull");
        });
        element2.on(Metro2.events.click, ".holder", function() {
          that._pullClick(this, "holder");
        });
        element2.on(Metro2.events.click, ".navview-menu li", function() {
          if (o2.activeState === true) {
            element2.find(".navview-menu li.active").removeClass("active");
            $5(this).toggleClass("active");
          }
        });
        element2.on(Metro2.events.click, ".navview-menu li > a", function() {
          that._fireEvent("menu-item-click", {
            item: this
          });
        });
        if (this.paneToggle !== null) {
          this.paneToggle.on(Metro2.events.click, function() {
          });
        }
        menu.find("a").on(Metro2.events.enter, function() {
          if (!element2.hasClass("compacted")) {
            return;
          }
          const a3 = $5(this);
          const r2 = Metro2.utils.rect(this);
          const c3 = a3.children(".caption");
          c3.css({
            position: "fixed",
            top: r2.top,
            left: r2.left + menu_container.width(),
            borderRadius: 4,
            paddingLeft: 10,
            boxShadow: "0 0 5px 0 var(--shadow-color)"
          });
        });
        menu.find("a").on(Metro2.events.leave, function() {
          if (!element2.hasClass("compacted")) {
            return;
          }
          const a3 = $5(this);
          const c3 = a3.children(".caption");
          c3[0].style = "";
        });
        $5(globalThis).on(
          Metro2.events.resize,
          () => {
            this._recalc();
            if (!element2.hasClass("handmade")) {
              if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint)) {
                element2.removeClass("compacted");
                element2.addClass("expanded");
              } else {
                element2.removeClass("expanded");
                element2.addClass("compacted");
              }
            }
          },
          { ns: this.id }
        );
      },
      _togglePaneMode: function(hand = false) {
        const element2 = this.element, o2 = this.options;
        element2.toggleClass("expanded");
        element2.toggleClass("compacted");
        element2.toggleClass("handmade");
        if (element2.hasClass("compacted")) {
          Metro2.storage.setItem("navview:compacted", true);
          Metro2.utils.exec(o2.onPaneClose, null, this);
        } else {
          Metro2.storage.setItem("navview:compacted", false);
          Metro2.utils.exec(o2.onPaneOpen, null, this);
        }
      },
      _pullClick: function(el, sender) {
        let input, target = $5(el);
        if (target && target.hasClass("holder")) {
          input = target.parent().find("input");
          setTimeout(function() {
            input.focus();
          }, 200);
        }
        this._togglePaneMode(sender === "pull");
        this._recalc();
        return true;
      },
      toggle: function() {
        this._togglePaneMode();
      },
      compact: function() {
        const element2 = this.element;
        element2.addClass("compacted handmade");
        element2.removeClass("expanded");
        this._recalc();
      },
      expand: function() {
        const element2 = this.element;
        element2.addClass("expanded");
        element2.removeClass("compacted handmade");
        this._recalc();
      },
      state() {
        return this.element.hasClass("expanded") ? "expand" : "compact";
      },
      /* eslint-disable-next-line */
      changeAttribute: function(attributeName) {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".pull-button, .holder");
        element2.off(Metro2.events.click, ".navview-menu li");
        element2.off(Metro2.events.click, ".navview-menu li > a");
        if (this.paneToggle !== null) {
          this.paneToggle.off(Metro2.events.click);
        }
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/notify/notify.js
  (function(Metro2, $5) {
    "use strict";
    let NotifyDefaultConfig = {
      container: null,
      width: 220,
      timeout: 3e3,
      duration: METRO_ANIMATION_DURATION,
      distance: "max",
      animation: "linear",
      clsNotify: "",
      onClick: Metro2.noop,
      onClose: Metro2.noop,
      onShow: Metro2.noop,
      onAppend: Metro2.noop,
      onNotifyCreate: Metro2.noop
    };
    Metro2.notifySetup = function(options) {
      NotifyDefaultConfig = $5.extend({}, NotifyDefaultConfig, options);
    };
    if (typeof globalThis["metroNotifySetup"] !== "undefined") {
      Metro2.notifySetup(globalThis["metroNotifySetup"]);
    }
    const Notify = {
      container: null,
      options: {},
      notifies: [],
      setup: function(options) {
        this.options = $5.extend({}, NotifyDefaultConfig, options);
        return this;
      },
      reset: function() {
        const reset_options = {
          width: 220,
          timeout: METRO_TIMEOUT,
          duration: METRO_ANIMATION_DURATION,
          distance: "max",
          animation: "linear"
        };
        this.options = $5.extend({}, NotifyDefaultConfig, reset_options);
      },
      _createContainer: function() {
        const container = $5("<div>").addClass("notify-container");
        $5("body").prepend(container);
        return container;
      },
      create: function(message, title, options = {}) {
        const that = this, o2 = this.options;
        let notify, m4, t, id = Metro2.utils.elementId("notify");
        if (!message) {
          return false;
        }
        notify = $5("<div>").addClass("notify").addClass(o2.clsNotify).attr("id", id);
        notify.css({
          width: o2.width
        });
        if (title) {
          t = $5("<div>").addClass("notify-title").html(title);
          notify.prepend(t);
        }
        m4 = $5("<div>").addClass("notify-message").html(message);
        m4.appendTo(notify);
        if (options.clsNotify) {
          notify.addClass(options.clsNotify);
        }
        if (options.width !== void 0) {
          notify.css({
            width: options.width
          });
        }
        notify.on(Metro2.events.click, function() {
          Metro2.utils.exec(Metro2.utils.isValue(options.onClick) ? options.onClick : o2.onClick, null, this);
          that.kill($5(this).closest(".notify"), Metro2.utils.isValue(options.onClose) ? options.onClose : o2.onClose);
        });
        if (Notify.container === null) {
          Notify.container = Notify._createContainer();
        }
        notify.appendTo(Notify.container);
        notify.hide(function() {
          Metro2.utils.exec(Metro2.utils.isValue(options.onAppend) ? options.onAppend : o2.onAppend, null, notify[0]);
          const duration = Metro2.utils.isValue(options.duration) ? options.duration : o2.duration;
          const animation = Metro2.utils.isValue(options.animation) ? options.animation : o2.animation;
          let distance = Metro2.utils.isValue(options.distance) ? options.distance : o2.distance;
          if (distance === "max" || isNaN(distance)) {
            distance = $5(globalThis).height();
          }
          notify.show().animate({
            draw: {
              marginTop: [distance, 4],
              opacity: [0, 1]
            },
            dur: duration,
            ease: animation,
            onDone: function() {
              Metro2.utils.exec(o2.onNotifyCreate, null, this);
              if (options !== void 0 && options.keepOpen === true) {
              } else {
                setTimeout(function() {
                  that.kill(notify, Metro2.utils.isValue(options.onClose) ? options.onClose : o2.onClose);
                }, o2.timeout);
              }
              Metro2.utils.exec(Metro2.utils.isValue(options.onShow) ? options.onShow : o2.onShow, null, notify[0]);
            }
          });
        });
      },
      kill: function(notify, callback) {
        const that = this, o2 = this.options;
        notify.off(Metro2.events.click);
        notify.zoomOut(300, "linear", function() {
          Metro2.utils.exec(callback ? callback : that.options.onClose, null, notify[0]);
          notify.remove();
        });
      },
      killAll: function() {
        const that = this;
        const notifies = $5(".notify");
        $5.each(notifies, function() {
          that.kill($5(this));
        });
      }
    };
    Metro2["notify"] = Notify.setup();
  })(Metro, Dom);

  // source/components/tabs/tabs.js
  (function(Metro2, $5) {
    "use strict";
    let TabsDefaultConfig = {
      tabsDeferred: 0,
      expand: false,
      expandPoint: null,
      type: "default",
      // default, text, group, pills
      updateUri: false,
      position: "top",
      // top, bottom, left, right
      align: "left",
      // left, center, right
      link: "",
      clsTabs: "",
      clsTabsList: "",
      clsTabsListItem: "",
      clsTabsListItemActive: "",
      onTab: Metro2.noop,
      onTabOpen: Metro2.noop,
      onTabClose: Metro2.noop,
      onBeforeTab: Metro2.noop_true,
      onTabsCreate: Metro2.noop
    };
    Metro2.tabsSetup = function(options) {
      TabsDefaultConfig = $5.extend({}, TabsDefaultConfig, options);
    };
    if (typeof globalThis["metroTabsSetup"] !== "undefined") {
      Metro2.tabsSetup(globalThis["metroTabsSetup"]);
    }
    Metro2.Component("tabs", {
      init: function(options, elem) {
        this._super(elem, options, TabsDefaultConfig, {
          _targets: [],
          id: Metro2.utils.elementId("tabs")
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const tab = element2.find(".active")[0];
        this._createStructure();
        this._createEvents();
        this._open(tab);
        this._fireEvent("tabs-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        const container = element2.wrap("<div>").addClass("tabs");
        let expandTitle, hamburger;
        container.addClass(`tabs-${o2.position}`);
        element2.addClass("tabs-list");
        element2.addClass("tabs-" + o2.type);
        element2.addClass("align-" + o2.align);
        element2.data("expanded", false);
        expandTitle = $5("<div>").addClass("expand-title");
        container.prepend(expandTitle);
        hamburger = container.find(".hamburger");
        if (hamburger.length === 0) {
          hamburger = $5("<button>").attr("type", "button").addClass("hamburger menu-down").appendTo(container);
          for (let i3 = 0; i3 < 3; i3++) {
            $5("<span>").addClass("line").appendTo(hamburger);
          }
        }
        container.addClass(o2.clsTabs);
        element2.addClass(o2.clsTabsList);
        element2.children("li").addClass(o2.clsTabsListItem);
        if (o2.expand === true) {
          if (!["left", "right"].includes(o2.position)) {
            container.addClass("tabs-expand");
          }
        } else {
          if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint) && !["left", "right"].includes(o2.position)) {
            container.addClass("tabs-expand");
          }
        }
        if (["left", "right"].includes(o2.position)) {
          container.addClass("tabs-expand");
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const container = element2.parent();
        $5(globalThis).on(
          Metro2.events.resize,
          function() {
            if (["left", "right"].includes(o2.position)) {
              return;
            }
            if (o2.expand === true) {
              if (!["left", "right"].includes(o2.position)) {
                container.addClass("tabs-expand");
              }
            } else {
              if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint) && !["left", "right"].includes(o2.position)) {
                if (!container.hasClass("tabs-expand")) container.addClass("tabs-expand");
              } else {
                if (container.hasClass("tabs-expand")) container.removeClass("tabs-expand");
              }
            }
          },
          { ns: this.id }
        );
        container.on(Metro2.events.click, ".hamburger, .expand-title", function() {
          if (element2.data("expanded") === false) {
            element2.addClass("expand");
            element2.data("expanded", true);
            container.find(".hamburger").addClass("active");
          } else {
            element2.removeClass("expand");
            element2.data("expanded", false);
            container.find(".hamburger").removeClass("active");
          }
        });
        element2.on(Metro2.events.click, "li", function(e2) {
          const link = $5(this).children("a");
          const href = link.attr("href").trim();
          const tab = link.parent("li");
          that._fireEvent("tab", {
            tab: tab[0],
            target: tab.children("a").href()
          });
          if (tab.hasClass("active")) {
          }
          if (element2.data("expanded") === true) {
            element2.removeClass("expand");
            element2.data("expanded", false);
            container.find(".hamburger").removeClass("active");
          }
          if (Metro2.utils.exec(o2.onBeforeTab, [tab, element2], tab[0]) !== true) {
            return false;
          }
          if (href) {
            if (href.startsWith("#")) {
              that._open(tab);
              e2.preventDefault();
            } else {
              globalThis.location.href = href;
            }
          }
        });
        $5(globalThis).on("hashchange", function() {
          let hash, tab;
          if (o2.updateUri) {
            hash = globalThis.location.hash;
            tab = that._findTabByTarget(hash);
            that._open($5(tab));
          }
        });
      },
      _findTabByTarget: function(target) {
        const element2 = this.element;
        const tabs = element2.find("li");
        let tab = void 0;
        tabs.each(function(i3, el) {
          if (!tab && $5(el).children("a").attr("href") === target) {
            tab = el;
          }
        });
        return tab;
      },
      _collectTargets: function() {
        const that = this, element2 = this.element;
        const tabs = element2.find("li");
        this._targets = [];
        $5.each(tabs, function() {
          const tab = $5(this);
          if (tab.hasClass("divider")) return;
          const target = tab.find("a").attr("href").trim();
          if (target.length > 1 && target[0] === "#") {
            that._targets.push(target);
          }
        });
      },
      _open: function(tab) {
        const element2 = this.element, o2 = this.options;
        const tabs = element2.find("li");
        const expandTitle = element2.siblings(".expand-title");
        const activeTab = element2.find("li.active");
        if (tabs.length === 0) {
          return;
        }
        this._collectTargets();
        if (tab === void 0) {
          tab = $5(tabs[0]);
        } else {
          tab = $5(tab);
        }
        const target = tab.find("a").attr("href");
        const tabIndex = tab.index();
        if (target === void 0) {
          return;
        }
        tabs.removeClass("active").removeClass(o2.clsTabsListItemActive);
        if (tab.parent().hasClass("d-menu")) {
          tab.parent().parent().addClass("active");
        } else {
          tab.addClass("active");
        }
        if (o2.link) {
          $5(`[data-link=${o2.link}]`).each((i3, el) => {
            if (el === this.elem) return;
            const tabs2 = $5(el).find("li");
            if (tabs2.length && tabs2[tabIndex]) {
              tabs2[tabIndex].click();
            }
          });
        }
        $5.each(this._targets, function() {
          const t = $5(this);
          if (t.length > 0) t.hide();
        });
        if (target !== "#" && target[0] === "#") {
          if (o2.updateUri) {
            globalThis.location.hash = target;
          }
          $5(target).show();
        }
        expandTitle.html(tab.find("a").html());
        tab.addClass(o2.clsTabsListItemActive);
        if (!activeTab.is(tab)) {
          this._fireEvent("tab-open", {
            tab: tab[0],
            target: tab.children("a").attr("href")
          });
          this._fireEvent("tab-close", {
            tab: activeTab[0],
            target: activeTab.children("a").attr("href")
          });
        }
      },
      next: function() {
        const element2 = this.element;
        let next, active_tab = element2.find("li.active");
        next = active_tab.next("li");
        if (next.length > 0) {
          this._open(next);
        }
      },
      prev: function() {
        const element2 = this.element;
        let next, active_tab = element2.find("li.active");
        next = active_tab.prev("li");
        if (next.length > 0) {
          this._open(next);
        }
      },
      openByTarget: function(target) {
        const tab = this._findTabByTarget(target);
        if (tab) {
          this._open($5(tab));
        }
      },
      openByIndex: function(index) {
        const element2 = this.element;
        const tabs = element2.find("li");
        if (Metro2.utils.isValue(tabs[index])) this._open($5(tabs[index]));
      },
      open: function(tab) {
        const element2 = this.element;
        const tabs = element2.find("li");
        if (!Metro2.utils.isValue(tab)) {
          tab = 1;
        }
        if (Metro2.utils.isInt(tab)) {
          if (Metro2.utils.isValue(tabs[tab - 1])) this._open($5(tabs[tab - 1]));
        } else {
          this._open($5(tab));
        }
      },
      changeAttribute: function() {
      },
      destroy: function() {
        const element2 = this.element;
        const container = element2.parent();
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        container.off(Metro2.events.click, ".hamburger, .expand-title");
        element2.off(Metro2.events.click, "a");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/package-manager/package-manager.js
  (function(Metro2, $5) {
    "use strict";
    const copy_image = `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M21 8C21 6.34315 19.6569 5 18 5H10C8.34315 5 7 6.34315 7 8V20C7 21.6569 8.34315 23 10 23H18C19.6569 23 21 21.6569 21 20V8ZM19 8C19 7.44772 18.5523 7 18 7H10C9.44772 7 9 7.44772 9 8V20C9 20.5523 9.44772 21 10 21H18C18.5523 21 19 20.5523 19 20V8Z"/>
        <path d="M6 3H16C16.5523 3 17 2.55228 17 2C17 1.44772 16.5523 1 16 1H6C4.34315 1 3 2.34315 3 4V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V4C5 3.44772 5.44772 3 6 3Z"/>
    </svg>`;
    const npm_image = `<svg width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <path d="M0 9.781v10.667h8.885v1.771h7.115v-1.771h16v-10.667zM8.885 18.661h-1.771v-5.333h-1.781v5.333h-3.552v-7.104h7.104zM14.219 18.661v1.787h-3.552v-8.891h7.115v7.109h-3.563zM30.224 18.661h-1.776v-5.333h-1.781v5.333h-1.781v-5.333h-1.771v5.333h-3.563v-7.104h10.672zM14.219 13.333h1.781v3.557h-1.781z"/>
    </svg>`;
    const pnpm_image = `<svg width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <path d="M30,10.75H21.251V2H30Z" />
        <path d="M20.374,10.75h-8.75V2h8.75Z" />
        <path d="M10.749,10.75H2V2h8.749Z" />
        <path d="M30,20.375H21.251v-8.75H30Z" />
        <path d="M20.374,20.375h-8.75v-8.75h8.75Z"/>
        <path d="M20.374,30h-8.75V21.25h8.75Z"/>
        <path d="M30,30H21.251V21.25H30Z" />
        <path d="M10.749,30H2V21.25h8.749Z" />
    </svg>`;
    const yarn_image = `<svg width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <path d="M28.208,24.409a10.493,10.493,0,0,0-3.959,1.822,23.743,23.743,0,0,1-5.835,2.642,1.632,1.632,0,0,1-.983.55A62.228,62.228,0,0,1,10.984,30c-1.163.009-1.876-.3-2.074-.776a1.573,1.573,0,0,1,.866-2.074,3.759,3.759,0,0,1-.514-.379c-.171-.171-.352-.514-.406-.388-.225.55-.343,1.894-.947,2.5-.83.839-2.4.559-3.328.072-1.019-.541.072-1.813.072-1.813a.73.73,0,0,1-.992-.343,4.847,4.847,0,0,1-.667-2.949,5.374,5.374,0,0,1,1.749-2.895,9.334,9.334,0,0,1,.658-4.4,10.445,10.445,0,0,1,3.165-3.661S6.628,10.747,7.35,8.817c.469-1.262.658-1.253.812-1.308a3.633,3.633,0,0,0,1.452-.857,5.265,5.265,0,0,1,4.41-1.7S15.2,1.4,16.277,2.09a18.349,18.349,0,0,1,1.533,2.886s1.281-.748,1.425-.469a11.334,11.334,0,0,1,.523,6.132,14.01,14.01,0,0,1-2.6,5.411c-.135.225,1.551.938,2.615,3.887.983,2.7.108,4.96.262,5.212.027.045.036.063.036.063s1.127.09,3.391-1.308A8.5,8.5,0,0,1,27.739,22.3a1.081,1.081,0,0,1,.469,2.11Z"/>
    </svg>`;
    const bun_image = `<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M11.966 22.566c6.609 0 11.966-4.326 11.966-9.661 0-3.308-2.051-6.23-5.204-7.963-1.283-.713-2.291-1.353-3.13-1.885-1.58-1.004-2.555-1.623-3.632-1.623-1.094 0-2.327.783-3.955 1.816a49.78 49.78 0 0 1-2.808 1.692C2.051 6.675 0 9.597 0 12.905c0 5.335 5.357 9.66 11.966 9.66Zm-1.397-17.83a5.885 5.885 0 0 0 .497-2.403c0-.144.201-.186.229-.028.656 2.775-.9 4.15-2.051 4.61-.124.048-.199-.12-.103-.208a5.748 5.748 0 0 0 1.428-1.971Zm2.052-.102a5.795 5.795 0 0 0-.78-2.3v-.015c-.068-.123.086-.263.185-.172 1.956 2.105 1.303 4.055.554 5.037-.082.102-.229-.003-.188-.126a5.837 5.837 0 0 0 .229-2.424Zm1.771-.559a5.708 5.708 0 0 0-1.607-1.801V2.26c-.112-.085-.024-.274.113-.218 2.588 1.084 2.766 3.171 2.452 4.395a.116.116 0 0 1-.048.071.11.11 0 0 1-.153-.026.118.118 0 0 1-.022-.083 5.864 5.864 0 0 0-.735-2.324Zm-5.072.559c-.616.544-1.279.758-2.058.997-.116 0-.194-.078-.155-.18 1.747-.907 2.369-1.645 2.99-2.771 0 0 .155-.117.188.085 0 .303-.348 1.325-.965 1.869Zm4.931 11.205a2.949 2.949 0 0 1-.935 1.549 2.16 2.16 0 0 1-1.282.618 2.167 2.167 0 0 1-1.323-.618 2.95 2.95 0 0 1-.923-1.549.243.243 0 0 1 .064-.197.23.23 0 0 1 .192-.069h3.954a.226.226 0 0 1 .19.07.239.239 0 0 1 .063.196Zm-5.443-2.17a1.85 1.85 0 0 1-2.377-.244 1.969 1.969 0 0 1-.233-2.44c.207-.318.502-.565.846-.711a1.84 1.84 0 0 1 1.089-.11c.365.075.701.26.964.53.264.27.443.616.515.99a1.98 1.98 0 0 1-.108 1.118 1.923 1.923 0 0 1-.696.866Zm8.471.005a1.849 1.849 0 0 1-2.374-.252 1.956 1.956 0 0 1-.546-1.362c0-.383.11-.758.319-1.076.207-.318.502-.566.847-.711a1.84 1.84 0 0 1 1.09-.108c.366.076.702.261.965.533s.44.617.512.993a1.98 1.98 0 0 1-.113 1.118 1.922 1.922 0 0 1-.7.865Z"/>
    </svg>`;
    let PackageManagerDefaultConfig = {
      link: "package-manager",
      default: "npm",
      deps: "",
      // dev, peer, or empty for default
      package: "",
      onPackageManagerCreate: Metro2.noop
    };
    Metro2.packageManagerSetup = function(options) {
      PackageManagerDefaultConfig = $5.extend({}, PackageManagerDefaultConfig, options);
    };
    if (typeof globalThis["metroPackageManagerSetup"] !== "undefined") {
      Metro2.packageManagerSetup(globalThis["metroPackageManagerSetup"]);
    }
    Metro2.Component("package-manager", {
      init: function(options, elem) {
        this._super(elem, options, PackageManagerDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        const that = this, element2 = this.element, o2 = this.options;
        this._createStructure();
        this._createEvents();
        this._fireEvent("component-create");
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const timestamp = (/* @__PURE__ */ new Date()).getTime();
        const npmId = Hooks.useId(`pm-npm-${timestamp}`);
        const pnpmId = Hooks.useId(`pm-pnpm-${timestamp}`);
        const yarnId = Hooks.useId(`pm-yarn-${timestamp}`);
        const bunId = Hooks.useId(`pm-bun-${timestamp}`);
        element2.addClass("package-manager");
        element2.html(`
                <ul data-role="tabs" data-expand="true" data-link="${o2.link}">
                    <li class="${o2.default === "npm" ? "active" : ""}"><a href="#${npmId}">${npm_image} npm</a></li>
                    <li class="${o2.default === "pnpm" ? "active" : ""}"><a href="#${pnpmId}">${pnpm_image} pnpm</a></li>
                    <li class="${o2.default === "yarn" ? "active" : ""}"><a href="#${yarnId}">${yarn_image} yarn</a></li>
                    <li class="${o2.default === "bun" ? "active" : ""}"><a href="#${bunId}">${bun_image} bun</a></li>
                </ul>
                <div>
                    <div class="pm-command" id="${npmId}">
                        <button class="small square"><span class="icon">${copy_image}</span></button>
                        <code>npm i ${o2.deps === "" ? "" : o2.deps === "dev" ? "-D" : ""} ${o2.package}</code>
                    </div>
                    <div class="pm-command" id="${pnpmId}">
                        <button class="small square"><span class="icon">${copy_image}</span></button>
                        <code>pnpm add ${o2.deps === "" ? "" : o2.deps === "dev" ? "-D" : "--save-peer"} ${o2.package}</code>
                    </div>
                    <div class="pm-command" id="${yarnId}">
                        <button class="small square"><span class="icon">${copy_image}</span></button>
                        <code>yarn add ${o2.deps === "" ? "" : o2.deps === "dev" ? "-D" : "-P"} ${o2.package}</code>
                    </div>
                    <div class="pm-command" id="${bunId}">
                        <button class="small square"><span class="icon">${copy_image}</span></button>
                        <code>bun add ${o2.deps === "" ? "" : o2.deps === "dev" ? "-D" : "--peer"} ${o2.package}</code>
                    </div>
                </div>
            `);
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.on("click", ".pm-command button", function() {
          const command = $5(this).parent().find("code").text();
          Metro2.utils.copy2clipboard(command);
        });
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/page-control/pagecontrol.js
  (function(Metro2, $5) {
    "use strict";
    let PageControlDefaultConfig = {
      appendButton: true,
      tabsPosition: "left",
      customButtons: null,
      activateNewTab: true,
      defaultNewTabTitle: "New File",
      defaultNewCanClose: true,
      defaultNewTabIcon: "",
      defaultNewTabImage: "",
      defaultNewTabPosition: "before",
      // before, after
      appendActions: null,
      tabsActions: null,
      tabActions: null,
      refControl: false,
      onAppendButtonClick: Metro2.noop,
      onTabCreate: Metro2.noop_arg,
      onTabActivate: Metro2.noop,
      onTabDeactivate: Metro2.noop,
      onTabBeforeClose: Metro2.noop_true,
      onTabClose: Metro2.noop,
      onTabRename: Metro2.noop,
      onTabPropChange: Metro2.noop,
      onTabOrganized: Metro2.noop
    };
    Metro2.pageControlSetup = function(options) {
      PageControlDefaultConfig = $5.extend({}, PageControlDefaultConfig, options);
    };
    if (typeof globalThis["metroPageControlSetup"] !== "undefined") {
      Metro2.pageControlSetup(globalThis["metroPageControlSetup"]);
    }
    Metro2.Component("page-control", {
      init: function(options, elem) {
        this._super(elem, options, PageControlDefaultConfig, {
          // define instance vars here
          newFileIndex: 1,
          invisibleTabsHolderToggle: null,
          invisibleTabsHolder: null
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("page-control-create");
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        this.component = $5("<div>").addClass("page-control").insertBefore(element2);
        element2.addClass("page-control__tabs").appendTo(this.component);
        element2.addClass(`tabs-position-${o2.tabsPosition}`);
        const items = element2.children("li:not(.page-control__tab-custom)");
        let activeTabExists = false;
        items.each(function(index, el) {
          const $el = $5(el), html = $el.html(), active = $el.hasClass("active");
          const tab = that.createTab({
            caption: html,
            icon: $el.attr("data-icon"),
            image: $el.attr("data-image"),
            canClose: $el.attr("data-close") !== "false",
            data: $el.attr("data-data"),
            ref: $el.attr("data-ref")
          });
          if (active && !activeTabExists) {
            activeTabExists = true;
            tab.addClass("active");
            that._fireEvent("tab-activate", { tab: tab[0] });
          }
          element2.append(tab);
          $el.remove();
        });
        if (!activeTabExists) {
          const tab = this.element.children(".page-control__tab").first();
          tab.addClass("active");
          this._fireEvent("tab-activate", { tab: tab[0] });
        }
        if (o2.refControl) {
          this._updateRefs();
        }
        if (o2.appendButton) {
          const appendButton = $5("<li>").addClass("page-control__tab__append").html(`<span class="toggle">+</span>`);
          if (o2.appendActions) {
            const appendItems = Metro2.utils.exec(o2.appendActions, null, this);
            if (!Array.isArray(appendItems)) {
              throw "PageControl Error! Prop appendActions must be a function that returns an array.";
            }
            const appendMenu = $5("<ul data-role='dropdown' class='d-menu context'>");
            appendItems.map((el) => appendMenu.append(that._renderMenuItem(el)));
            appendButton.append(appendMenu);
          }
          element2.append(appendButton);
        }
        const services = $5("<li>").addClass("page-control__tab__service").addClass("invisible-tabs").appendTo(element2);
        services.append(
          $5("<div>").addClass("page-control__service-button").html(`
                    <span class="toggle">\u21A7</span>
                    <ul class="d-menu place-right context page-control__invisible_tabs_holder"></ul>
                `)
        );
        this.invisibleTabsHolderToggle = services.find(".page-control__tab__service.invisible-tabs > .page-control__service-button");
        this.invisibleTabsHolder = Metro2.makePlugin(services.find(".page-control__invisible_tabs_holder"), "dropdown", {
          onClick: (e2) => {
            const parent2 = $5(e2.target.parentNode);
            if (parent2.hasClass("page-control__tab__closer")) {
              this.closeButtonClick(e2);
            } else {
              this.activateTab(parent2[0]);
            }
            e2.preventDefault();
            e2.stopPropagation();
          }
        });
        this.invisibleTabsHolderToggle.hide();
        this.organizeTabs();
        const tabsServices = $5("<li>").addClass("page-control__tab__service").addClass("tabs-menu").appendTo(element2);
        tabsServices.append(
          $5("<div>").addClass("page-control__service-button").html(`
                    <span class="toggle">\uFE19</span>
                    <ul class="d-menu place-right context" data-role="dropdown"></ul>
                `)
        );
        if (!o2.tabsActions) {
          tabsServices.hide();
        } else {
          const tabsMenu = tabsServices.find("ul");
          const tabsMenuItems = Metro2.utils.exec(o2.tabsActions, null, this);
          tabsMenuItems.map((el) => tabsMenu.append(that._renderMenuItem(el)));
        }
      },
      _updateRefs: function() {
        const tabs = this.element.find(".page-control__tab");
        const activeTab = this.element.find(".page-control__tab.active");
        tabs.each((_4, el) => $5($5(el).data("ref")).hide());
        $5(activeTab.data("ref")).show();
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.on("click", ".page-control__tab__closer", this.closeButtonClick.bind(this));
        element2.on("click", ".page-control__tab__menu > li > a", function(e2) {
          const action = $5(this).attr("data-action");
          const menu = Metro2.getPlugin($5(this).closest("ul"), "dropdown");
          const tab = $5(this).closest(".page-control__tab")[0];
          menu.close();
          switch (action) {
            case "close": {
              that.closeTab(tab);
              break;
            }
            case "close-all": {
              that.closeAll();
              break;
            }
            case "close-other": {
              that.closeOtherTabs(tab);
              break;
            }
            case "close-inactive": {
              that.closeInactiveTabs();
              break;
            }
            case "close-left": {
              that.closeTabsOnTheLeft(tab);
              break;
            }
            case "close-right": {
              that.closeTabsOnTheRight(tab);
              break;
            }
            case "rename": {
              that.renameTab(tab);
              break;
            }
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on("click", ".page-control__tab", function() {
          const tab = $5(this);
          if (tab.hasClass("active")) {
            return;
          }
          that.activateTab(this);
        });
        element2.on("click", ".page-control__tab__append > span", (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          const tab = that.createTab({
            caption: `${o2.defaultNewTabTitle} ${that.newFileIndex++}`,
            canClose: o2.defaultNewCanClose,
            icon: o2.defaultNewTabIcon,
            image: o2.defaultNewTabImage,
            data: null
          });
          that._fireEvent("tab-append", { tab });
          that.activateTab(tab);
          that.organizeTabs();
          that._fireEvent("append-button-click", { tab });
        });
        $5(globalThis).on("resize", () => {
          this.organizeTabs();
        });
      },
      _renderMenuItem: function(el) {
        const li = $5("<li>");
        const an = $5("<a>");
        if (el.icon || el.image) {
          an.append(el.icon ? $5("<span class='icon'>").addClass(el.icon) : $5("<img class='icon'>").attr("src", el.image).attr("alt", ""));
        }
        if (el.title) {
          an.append($5("<span>").addClass("caption").text(el.title));
        }
        an.data("data", el.data);
        if (el.onclick) an.on("click", (e2) => el.onclick(e2));
        li.append(an);
        return li;
      },
      createTab: function({ caption, icon, image, canClose = true, hasMenu = true, data, ref }) {
        const that = this, element2 = this.element, o2 = this.options;
        const tab = $5("<li>").addClass("page-control__tab").appendTo(element2);
        if (hasMenu) {
          tab.append(
            $5("<div>").addClass("page-control__tab__menu__holder").html(`
                        <span class="">\uFE19</span>
                        <ul class="d-menu context page-control__tab__menu" data-role="dropdown">
                            <li><a data-action="rename">${this.strings.label_rename_tab}</a></li>
                            <li class="divider"></li>
                            <li><a data-action="close">${this.strings.label_close_tab}</a></li>
                            <li><a data-action="close-other">${this.strings.label_close_other_tabs}</a></li>
                            <li><a data-action="close-left">${this.strings.label_close_tabs_left}</a></li>
                            <li><a data-action="close-right">${this.strings.label_close_tabs_right}</a></li>
                            <li><a data-action="close-all">${this.strings.label_close_all_tabs}</a></li>
                            <li><a data-action="close-inactive">${this.strings.label_close_inactive_tabs}</a></li>
                        </ul>
                    `)
          );
          if (o2.tabActions) {
            const tabMenu = tab.find("ul");
            const tabMenuItems = Metro2.utils.exec(o2.tabActions);
            if (!Array.isArray(tabMenuItems)) {
              throw "PageControl Error! Prop tabActions must be a function that returns an array.";
            }
            tabMenu.append($5("<li class='divider'>"));
            tabMenuItems.map((el) => tabMenu.append(that._renderMenuItem(el)));
          }
        }
        if (icon || image) {
          tab.append(
            $5("<span>").addClass("page-control__tab__icon").html(icon ? `<span class="${icon}">` : `<img src="${image}" alt=""/>`)
          );
        }
        tab.append($5("<span>").addClass("page-control__tab__caption").html(caption));
        if (canClose) {
          tab.append($5("<span>").addClass("page-control__tab__closer").html(`<span>\u2715</span>`));
        }
        tab.data("data", data);
        tab.data("ref", ref);
        this._fireEvent("tab-create", { tab: tab[0] });
        element2[o2.defaultNewTabPosition === "before" ? "prepend" : "append"](tab);
        return tab[0];
      },
      closeButtonClick: function(e2) {
        const that = this, o2 = this.options;
        const tab = $5(e2.target).closest(".page-control__tab");
        const parent2 = tab.closest("ul");
        if (!o2.onTabBeforeClose(tab[0])) {
          return;
        }
        that.closeTab(tab[0]);
        if (parent2.hasClass("page-control__invisible_tabs_holder") && parent2.children(".page-control__tab").length === 0) {
          Metro2.getPlugin(this.invisibleTabsHolder, "dropdown").close();
          this.invisibleTabsHolderToggle.hide();
        }
        e2.preventDefault();
        e2.stopPropagation();
      },
      closeTab: function(tab, reorg = true) {
        const $tab = $5(tab);
        if ($tab.hasClass("active")) {
          const prev = $tab.prev(".page-control__tab"), next = $tab.next(".page-control__tab");
          if (prev.length) {
            this.activateTab(prev[0]);
          } else if (next.length) {
            this.activateTab(next[0]);
          } else if ($tab.parent().hasClass("page-control__invisible_tabs_holder") && parent.children(".page-control__tab").length === 1) {
            if (element.children(".page-control__tab").length) {
              this.activateTab(element.children(".page-control__tab").last()[0]);
            }
          }
        }
        this._fireEvent("tab-close", { tab });
        if (this.options.refControl) {
          $5($tab.data("ref")).remove();
        }
        $tab.remove();
        if (reorg) this.organizeTabs();
        return this;
      },
      activateTab: function(tab) {
        const element2 = this.element, o2 = this.options;
        element2.find(".page-control__tab").each((index, el) => {
          const t = $5(el);
          if (t.hasClass("active")) {
            this._fireEvent("tab-deactivate", { tab: el });
            t.removeClass("active");
          }
        });
        $5(tab).addClass("active");
        if (o2.refControl) {
          this._updateRefs();
        }
        this._fireEvent("tab-activate", { tab });
        if ($5(tab).parent().hasClass("page-control__invisible_tabs_holder")) {
          element2.prepend(tab);
          this.organizeTabs();
        }
        return this;
      },
      organizeTabs: function() {
        const element2 = this.element;
        const tabsWidth = this.elem.getBoundingClientRect().width;
        const holder = this.invisibleTabsHolder;
        const addTabButton = element2.find(".page-control__tab__append");
        holder.children(".page-control__tab").each((index, el) => {
          const tab = $5(el);
          if (addTabButton.length) {
            tab.insertBefore(addTabButton);
          } else {
            tab.appendTo(element2);
          }
        });
        const tabs = element2.children(".page-control__tab");
        let w5 = 0;
        for (let tab of tabs) {
          const tabRect = tab.getBoundingClientRect();
          if (w5 + tabRect.width + 50 > tabsWidth) {
            $5(tab).nextAll(".page-control__tab").appendTo(holder);
            $5(tab).appendTo(holder);
            break;
          }
          w5 += tabRect.width;
        }
        if (holder.children().length) {
          this.invisibleTabsHolderToggle.show(function() {
            $5(this).css({
              display: "flex"
            });
          });
        } else {
          this.invisibleTabsHolderToggle.hide();
        }
        this._fireEvent("tab-organized", null);
      },
      addTab: function({ caption, icon, image, canClose = true, hasMenu = true, data, ref }, insert = "before") {
        const o2 = this.options;
        const newTab = this.createTab({ caption, icon, image, canClose, hasMenu, data, ref });
        if (o2.activateNewTab) {
          this.activateTab(newTab);
        }
        this.element[insert === "before" ? "prepend" : "append"](newTab);
        this.organizeTabs();
        return newTab;
      },
      getActiveTab: function() {
        return this.component.find(".page-control__tab.active")[0];
      },
      getActiveTabIndex: function() {
        return this.component.find(".page-control__tab").index(".active", false);
      },
      getTabByIndex: function(index) {
        return this.component.find(".page-control__tab").get(index);
      },
      getTabByTitle: function(caption) {
        if (!caption) {
          return void 0;
        }
        const tabs = this.component.find(".page-control__tab");
        for (const tab of tabs) {
          if ($5(tab).find(".caption").text() === caption) {
            return tab;
          }
        }
        return void 0;
      },
      closeAll: function() {
        this.component.find(".page-control__tab").each((index, tab) => {
          this.closeTab(tab, false);
        });
        this.organizeTabs();
        return this;
      },
      closeInactiveTabs: function() {
        this.component.find(".page-control__tab").each((index, tab) => {
          if (!$5(tab).hasClass("active")) this.closeTab(tab, false);
        });
        this.organizeTabs();
        return this;
      },
      closeOtherTabs: function(tab) {
        let _tab = typeof tab === "number" ? this.getTabByIndex(tab) : $5(tab);
        this.component.find(".page-control__tab").each((index, tab2) => {
          if (_tab[0] !== tab2) this.closeTab(tab2, false);
        });
        this.activateTab(tab);
        this.organizeTabs();
        return this;
      },
      closeTabsOnTheLeft: function(tab) {
        const tabs = this.component.find(".page-control__tab");
        const tabIndex = tabs.indexOf($5(tab));
        this.component.find(".page-control__tab").each((index, _tab) => {
          if (index < tabIndex) this.closeTab(_tab, false);
        });
        this.organizeTabs();
        return this;
      },
      closeTabsOnTheRight: function(tab) {
        const tabs = this.component.find(".page-control__tab");
        const tabIndex = tabs.indexOf($5(tab));
        this.component.find(".page-control__tab").each((index, _tab) => {
          if (index > tabIndex) this.closeTab(_tab, false);
        });
        this.organizeTabs();
        return this;
      },
      setupTab: function(tab, prop, val) {
        const $tab = $5(tab);
        switch (prop) {
          case "caption": {
            $tab.find(".page-control__tab__caption").text(val);
            break;
          }
          case "icon": {
            $tab.find(".page-control__tab__icon")[0].className = val;
            break;
          }
          case "image": {
            $tab.find(".page-control__tab__image").attr("src", val);
            break;
          }
          case "data": {
            $tab.data("data", val);
            break;
          }
          case "ref": {
            $tab.data("ref", val);
            break;
          }
        }
        this._fireEvent("tab-prop-change", { tab });
        this.organizeTabs();
      },
      renameTab: function(tab) {
        const that = this;
        const caption = $5(tab).find(".page-control__tab__caption");
        Metro2.dialog.create({
          title: that.strings.label_rename_tab,
          content: `
                    <form style="width: 100%">
                        <input type="text" data-role="input" value="${caption.text()}">
                    </form>
                `,
          defaultActions: false,
          customButtons: [
            {
              text: that.strings.label_ok,
              cls: "js-dialog-close info",
              onclick: function(dlg) {
                that.setupTab(tab, "caption", dlg.find("input").val());
              }
            },
            {
              text: that.strings.label_cancel,
              cls: "js-dialog-close"
            }
          ]
        });
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.component.remove();
      }
    });
  })(Metro, Dom);

  // source/components/pagination/pagination.js
  (function(Metro2, $5) {
    "use strict";
    Metro2.pagination = function(c3) {
      var defConf = {
        length: 0,
        //total rows
        rows: 0,
        // page size
        current: 0,
        target: "body",
        clsPagination: "",
        prevTitle: "",
        nextTitle: "",
        distance: 5,
        islandSize: 3,
        shortTrack: 10
      }, conf;
      var strings = Metro2.locales[$5("html").attr("lang") || "en"];
      var i3, prev, next;
      conf = $5.extend({}, defConf, c3);
      var distance = parseInt(conf.distance);
      var shortTrack = parseInt(conf.shortTrack);
      var islandSize = parseInt(conf.islandSize);
      var totalRows = parseInt(conf.length);
      var pageSize = parseInt(conf.rows);
      var totalPages = Math.ceil(totalRows / pageSize);
      var current = parseInt(conf.current);
      var pagination_wrapper = $5(conf.target);
      pagination_wrapper.html("");
      var pagination = $5("<ul>").addClass("pagination").addClass(conf.clsPagination).appendTo(pagination_wrapper);
      if (totalRows === 0) {
        return;
      }
      if (pageSize === -1) {
        return;
      }
      var add_item = function(item_title, item_type, data) {
        var li, a3;
        li = $5("<li>").addClass("page-item").addClass(item_type);
        a3 = $5("<a>").addClass("page-link").html(item_title);
        a3.data("page", data);
        a3.appendTo(li);
        return li;
      };
      prev = add_item(conf.prevTitle || strings.label_prev, "service prev-page", "prev");
      pagination.append(prev);
      pagination.append(add_item(1, current === 1 ? "active" : "", 1));
      if (distance === 0 || totalPages <= shortTrack) {
        for (i3 = 2; i3 < totalPages; i3++) {
          pagination.append(add_item(i3, i3 === current ? "active" : "", i3));
        }
      } else {
        if (current < distance) {
          for (i3 = 2; i3 <= distance; i3++) {
            pagination.append(add_item(i3, i3 === current ? "active" : "", i3));
          }
          if (totalPages > distance) {
            pagination.append(add_item("...", "no-link", null));
          }
        } else if (current <= totalPages && current > totalPages - distance + 1) {
          if (totalPages > distance) {
            pagination.append(add_item("...", "no-link", null));
          }
          for (i3 = totalPages - distance + 1; i3 < totalPages; i3++) {
            pagination.append(add_item(i3, i3 === current ? "active" : "", i3));
          }
        } else {
          pagination.append(add_item("...", "no-link", null));
          for (let i4 = islandSize; i4 > 0; i4--) {
            pagination.append(add_item(current - i4, "", current - i4));
          }
          pagination.append(add_item(current, "active", current));
          for (let i4 = 1; i4 <= islandSize; i4++) {
            pagination.append(add_item(current + i4, "", current + i4));
          }
          pagination.append(add_item("...", "no-link", null));
        }
      }
      if (totalPages > 1 || current < totalPages) pagination.append(add_item(totalPages, current === totalPages ? "active" : "", totalPages));
      next = add_item(conf.nextTitle || strings.label_next, "service next-page", "next");
      pagination.append(next);
      if (current === 1) {
        prev.addClass("disabled");
      }
      if (current === totalPages) {
        next.addClass("disabled");
      }
      if (totalRows === 0) {
        pagination.addClass("disabled");
        pagination.children().addClass("disabled");
      }
      return pagination;
    };
  })(Metro, Dom);

  // source/components/panel/panel.js
  (function(Metro2, $5) {
    "use strict";
    const toggleImage = `<svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path></svg>`;
    var PanelDefaultConfig = {
      panelDeferred: 0,
      id: null,
      titleCaption: "",
      titleIcon: "",
      collapsible: false,
      collapsed: false,
      collapseDuration: 100,
      width: "auto",
      height: "auto",
      draggable: false,
      customButtons: null,
      clsCustomButton: "",
      clsPanel: "",
      clsTitle: "",
      clsTitleCaption: "",
      clsTitleIcon: "",
      clsContent: "",
      clsCollapseToggle: "",
      onCollapse: Metro2.noop,
      onExpand: Metro2.noop,
      onDragStart: Metro2.noop,
      onDragStop: Metro2.noop,
      onDragMove: Metro2.noop,
      onPanelCreate: Metro2.noop
    };
    Metro2.panelSetup = function(options) {
      PanelDefaultConfig = $5.extend({}, PanelDefaultConfig, options);
    };
    if (typeof globalThis["metroPanelSetup"] !== "undefined") {
      Metro2.panelSetup(globalThis["metroPanelSetup"]);
    }
    Metro2.Component("panel", {
      init: function(options, elem) {
        this._super(elem, options, PanelDefaultConfig);
        return this;
      },
      _addCustomButtons: function(buttons) {
        var element2 = this.element, o2 = this.options;
        var title = element2.closest(".panel").find(".panel-title");
        var buttonsContainer, customButtons = [];
        customButtons = Metro2.utils.isObject(buttons);
        if (!customButtons) {
          console.warn("Unknown format for custom buttons", buttons);
          return;
        }
        if (title.length === 0) {
          console.warn("No place for custom buttons");
          return;
        }
        buttonsContainer = title.find(".custom-buttons");
        if (buttonsContainer.length === 0) {
          buttonsContainer = $5("<div>").addClass("custom-buttons").appendTo(title);
        } else {
          buttonsContainer.find(".btn-custom").off(Metro2.events.click);
          buttonsContainer.html("");
        }
        $5.each(customButtons, function() {
          var item = this;
          var customButton = $5("<span>");
          customButton.addClass("button btn-custom").addClass(o2.clsCustomButton).addClass(item.cls).attr("tabindex", -1).html(item.html);
          if (item.attr && typeof item.attr === "object") {
            $5.each(item.attr, function(k4, v4) {
              customButton.attr(Str.dashedName(k4), v4);
            });
          }
          customButton.data("action", item.onclick);
          buttonsContainer.prepend(customButton);
        });
        title.on(Metro2.events.click, ".btn-custom", function(e2) {
          if (Metro2.utils.isRightMouse(e2)) return;
          var button = $5(this);
          var action = button.data("action");
          Metro2.utils.exec(action, [button], this);
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        var panel = $5("<div>").addClass("panel").addClass(o2.clsPanel);
        var id = o2.id ? o2.id : Metro2.utils.elementId("panel");
        var original_classes = element2[0].className;
        var title;
        panel.attr("id", id).addClass(original_classes);
        panel.insertBefore(element2);
        element2.appendTo(panel);
        element2[0].className = "";
        element2.addClass("panel-content").addClass(o2.clsContent).appendTo(panel);
        if (o2.titleCaption !== "" || o2.titleIcon !== "" || o2.collapsible === true) {
          title = $5("<div>").addClass("panel-title").addClass(o2.clsTitle);
          if (o2.titleCaption !== "") {
            $5("<span>").addClass("caption").addClass(o2.clsTitleCaption).html(o2.titleCaption).appendTo(title);
          }
          if (o2.titleIcon !== "") {
            $5(o2.titleIcon).addClass("icon").addClass(o2.clsTitleIcon).appendTo(title);
          }
          if (o2.collapsible === true) {
            var collapseToggle = $5("<span>").addClass("dropdown-toggle marker-center active-toggle").addClass(o2.clsCollapseToggle).appendTo(title);
            collapseToggle.append(toggleImage);
            Metro2.makePlugin(element2, "collapse", {
              toggleElement: collapseToggle,
              duration: o2.collapseDuration,
              onCollapse: o2.onCollapse,
              onExpand: o2.onExpand
            });
            if (o2.collapsed === true) {
              this.collapse();
            }
          }
          title.appendTo(panel);
        }
        if (title && Metro2.utils.isValue(o2.customButtons)) {
          this._addCustomButtons(o2.customButtons);
        }
        if (o2.draggable === true) {
          var dragElement;
          if (title) {
            dragElement = title.find(".caption, .icon");
          } else {
            dragElement = panel;
          }
          Metro2.makePlugin(panel, "draggable", {
            dragContext: panel[0],
            dragElement,
            onDragStart: o2.onDragStart,
            onDragStop: o2.onDragStop,
            onDragMove: o2.onDragMove
          });
        }
        if (o2.width !== "auto" && parseInt(o2.width) >= 0) {
          panel.outerWidth(parseInt(o2.width));
        }
        if (o2.height !== "auto" && parseInt(o2.height) >= 0) {
          panel.outerHeight(parseInt(o2.height));
          element2.css({ overflow: "auto" });
        }
        this.panel = panel;
        this._fireEvent("panel-create", {
          element: element2,
          panel
        });
      },
      customButtons: function(buttons) {
        return this._addCustomButtons(buttons);
      },
      collapse: function() {
        var element2 = this.element;
        if (Metro2.utils.isMetroObject(element2, "collapse") === false) {
          return;
        }
        Metro2.getPlugin(element2, "collapse").collapse();
      },
      open: function() {
        this.expand();
      },
      close: function() {
        this.collapse();
      },
      expand: function() {
        var element2 = this.element;
        if (Metro2.utils.isMetroObject(element2, "collapse") === false) {
          return;
        }
        Metro2.getPlugin(element2, "collapse").expand();
      },
      /* eslint-disable-next-line */
      changeAttribute: function(attributeName) {
      },
      destroy: function() {
        var element2 = this.element, o2 = this.options;
        if (o2.collapsible === true) {
          Metro2.getPlugin(element2, "collapse").destroy();
        }
        if (o2.draggable === true) {
          Metro2.getPlugin(element2, "draggable").destroy();
        }
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/popover/popover.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var PopoverDefaultConfig = {
      popoverDeferred: 0,
      popoverText: "",
      popoverHide: 3e3,
      popoverTimeout: 10,
      popoverOffset: 10,
      popoverTrigger: Metro2.popoverEvents.HOVER,
      popoverPosition: Metro2.position.TOP,
      hideOnLeave: false,
      closeButton: true,
      clsPopover: "",
      clsPopoverContent: "",
      onPopoverShow: Metro2.noop,
      onPopoverHide: Metro2.noop,
      onPopoverCreate: Metro2.noop
    };
    Metro2.popoverSetup = function(options) {
      PopoverDefaultConfig = $5.extend({}, PopoverDefaultConfig, options);
    };
    if (typeof globalThis["metroPopoverSetup"] !== "undefined") {
      Metro2.popoverSetup(globalThis["metroPopoverSetup"]);
    }
    Metro2.Component("popover", {
      init: function(options, elem) {
        this._super(elem, options, PopoverDefaultConfig, {
          popover: null,
          popovered: false,
          size: {
            width: 0,
            height: 0
          },
          id: Utils.elementId("popover")
        });
        return this;
      },
      _create: function() {
        this._createEvents();
        this._fireEvent("popover-create", {
          element: this.element
        });
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var event;
        switch (o2.popoverTrigger) {
          case Metro2.popoverEvents.CLICK:
            event = Metro2.events.click;
            break;
          case Metro2.popoverEvents.FOCUS:
            event = Metro2.events.focus;
            break;
          default:
            event = Metro2.events.enter;
        }
        element2.on(event, function() {
          if (that.popover !== null || that.popovered === true) {
            return;
          }
          setTimeout(function() {
            that.createPopover();
            that._fireEvent("popover-show", {
              popover: that.popover
            });
            if (o2.popoverHide > 0) {
              setTimeout(function() {
                that.removePopover();
              }, o2.popoverHide);
            }
          }, o2.popoverTimeout);
        });
        if (o2.hideOnLeave === true) {
          element2.on(Metro2.events.leave, function() {
            that.removePopover();
          });
        }
        $5(globalThis).on(Metro2.events.scroll, function() {
          if (that.popover !== null) that.setPosition();
        }, { ns: this.id });
      },
      setPosition: function() {
        var popover = this.popover, size = this.size, o2 = this.options, element2 = this.element;
        if (o2.popoverPosition === Metro2.position.BOTTOM) {
          popover.addClass("bottom");
          popover.css({
            top: element2.offset().top - $5(globalThis).scrollTop() + element2.outerHeight() + o2.popoverOffset,
            left: element2.offset().left + element2.outerWidth() / 2 - size.width / 2 - $5(globalThis).scrollLeft()
          });
        } else if (o2.popoverPosition === Metro2.position.RIGHT) {
          popover.addClass("right");
          popover.css({
            top: element2.offset().top + element2.outerHeight() / 2 - size.height / 2 - $5(globalThis).scrollTop(),
            left: element2.offset().left + element2.outerWidth() - $5(globalThis).scrollLeft() + o2.popoverOffset
          });
        } else if (o2.popoverPosition === Metro2.position.LEFT) {
          popover.addClass("left");
          popover.css({
            top: element2.offset().top + element2.outerHeight() / 2 - size.height / 2 - $5(globalThis).scrollTop(),
            left: element2.offset().left - size.width - $5(globalThis).scrollLeft() - o2.popoverOffset
          });
        } else {
          popover.addClass("top");
          popover.css({
            top: element2.offset().top - $5(globalThis).scrollTop() - size.height - o2.popoverOffset,
            left: element2.offset().left + element2.outerWidth() / 2 - size.width / 2 - $5(globalThis).scrollLeft()
          });
        }
      },
      createPopover: function() {
        var that = this, elem = this.elem, element2 = this.element, o2 = this.options;
        var popover;
        var neb_pos;
        var id = Utils.elementId("popover");
        var closeButton;
        if (this.popovered) {
          return;
        }
        popover = $5("<div>").addClass("popover neb").addClass(o2.clsPopover);
        popover.attr("id", id);
        $5("<div>").addClass("popover-content").addClass(o2.clsPopoverContent).html(o2.popoverText).appendTo(popover);
        if (o2.popoverHide === 0 && o2.closeButton === true) {
          closeButton = $5("<button>").addClass("square small popover-close-button").html("&times;").appendTo(popover);
          closeButton.on(Metro2.events.click, function() {
            that.removePopover();
          });
        }
        switch (o2.popoverPosition) {
          case Metro2.position.TOP:
            neb_pos = "neb-s";
            break;
          case Metro2.position.BOTTOM:
            neb_pos = "neb-n";
            break;
          case Metro2.position.RIGHT:
            neb_pos = "neb-w";
            break;
          case Metro2.position.LEFT:
            neb_pos = "neb-e";
            break;
        }
        popover.addClass(neb_pos);
        if (o2.closeButton !== true) {
          popover.on(Metro2.events.click, function() {
            that.removePopover();
          });
        }
        this.popover = popover;
        this.size = Utils.hiddenElementSize(popover);
        if (elem.tagName === "TD" || elem.tagName === "TH") {
          var wrp = $5("<div/>").css("display", "inline-block").html(element2.html());
          element2.html(wrp);
          element2 = wrp;
        }
        this.setPosition();
        popover.appendTo($5("body"));
        this.popovered = true;
        this._fireEvent("popover-create", {
          popover
        });
      },
      removePopover: function() {
        var that = this;
        var timeout = this.options.onPopoverHide === Metro2.noop ? 0 : 300;
        var popover = this.popover;
        if (!this.popovered) {
          return;
        }
        this._fireEvent("popover-hide", {
          popover
        });
        setTimeout(function() {
          popover.hide(0, function() {
            popover.remove();
            that.popover = null;
            that.popovered = false;
          });
        }, timeout);
      },
      show: function() {
        var that = this, o2 = this.options;
        if (this.popovered === true) {
          return;
        }
        setTimeout(function() {
          that.createPopover();
          that._fireEvent("popover-show", {
            popover: that.popover
          });
          if (o2.popoverHide > 0) {
            setTimeout(function() {
              that.removePopover();
            }, o2.popoverHide);
          }
        }, o2.popoverTimeout);
      },
      hide: function() {
        this.removePopover();
      },
      changeAttribute: function(attributeName) {
        var that = this, element2 = this.element, o2 = this.options;
        var changeText = function() {
          o2.popoverText = element2.attr("data-popover-text");
          if (that.popover) {
            that.popover.find(".popover-content").html(o2.popoverText);
            that.setPosition();
          }
        };
        var changePosition = function() {
          o2.popoverPosition = element2.attr("data-popover-position");
          that.setPosition();
        };
        switch (attributeName) {
          case "data-popover-text":
            changeText();
            break;
          case "data-popover-position":
            changePosition();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element, o2 = this.options;
        var event;
        switch (o2.popoverTrigger) {
          case Metro2.popoverEvents.CLICK:
            event = Metro2.events.click;
            break;
          case Metro2.popoverEvents.FOCUS:
            event = Metro2.events.focus;
            break;
          default:
            event = Metro2.events.enter;
        }
        element2.off(event);
        if (o2.hideOnLeave === true) {
          element2.off(Metro2.events.leave);
        }
        $5(globalThis).off(Metro2.events.scroll, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/progress/progress.js
  (function(Metro2, $5) {
    "use strict";
    let ProgressDefaultConfig = {
      progressDeferred: 0,
      showValue: false,
      showLabel: false,
      label: "Progress:",
      value: 0,
      buffer: 0,
      type: "bar",
      small: false,
      segmentSize: 10,
      clsProgress: "",
      clsBack: "",
      clsBar: "",
      clsBuffer: "",
      clsValue: "",
      clsLabel: "",
      clsData: "",
      onValueChange: Metro2.noop,
      onBufferChange: Metro2.noop,
      onComplete: Metro2.noop,
      onBuffered: Metro2.noop,
      onProgressCreate: Metro2.noop
    };
    Metro2.progressSetup = function(options) {
      ProgressDefaultConfig = $5.extend({}, ProgressDefaultConfig, options);
    };
    if (typeof globalThis["metroProgressSetup"] !== "undefined") {
      Metro2.progressSetup(globalThis["metroProgressSetup"]);
    }
    Metro2.Component("progress", {
      init: function(options, elem) {
        this._super(elem, options, ProgressDefaultConfig, {
          value: 0,
          buffer: 0
        });
        return this;
      },
      _create: function() {
        const element2 = this.element, elem = this.elem, o2 = this.options;
        if (typeof o2.type === "string") o2.type = o2.type.toLowerCase();
        element2.html("").addClass("progress");
        this.component = element2.wrap("<div>").addClass("progress-component").addClass(o2.clsProgress);
        function _progress() {
          elem.innerHTML = `<div class="bar"></div>`;
        }
        function _buffer() {
          elem.innerHTML = `
                    <div class="bar"></div>
                    <div class="buffer"></div>
                `;
        }
        function _load() {
          element2.addClass("with-load");
          elem.innerHTML = `
                    <div class="bar"></div>
                    <div class="buffer"></div>
                    <div class="load"></div>
                `;
        }
        function _line() {
          element2.addClass("line");
        }
        function _segment() {
          element2.addClass("segments");
          element2.append(`<div class="bar"></div>`);
          const width = element2.width();
          const segments = Math.ceil(width / (o2.segmentSize || 10));
          for (let i3 = 0; i3 < segments; i3++) {
            elem.innerHTML += `<div class="segment" style="width: ${o2.segmentSize}px"></div>`;
          }
        }
        switch (o2.type) {
          case "buffer":
            _buffer();
            break;
          case "load":
            _load();
            break;
          case "line":
            _line();
            break;
          case "segment":
            _segment();
            break;
          default:
            _progress();
        }
        if (o2.small === true) element2.addClass("small");
        element2.addClass(o2.clsBack);
        element2.find(".bar").addClass(o2.clsBar);
        element2.find(".buffer").addClass(o2.clsBuffer);
        const data = $5("<div>").addClass("progress-data").addClass(o2.clsData).insertBefore(element2);
        const label = $5("<div>").addClass("progress-label").addClass(o2.clsLabel).html(o2.label).appendTo(data);
        const value = $5("<div>").addClass("progress-value").addClass(o2.clsLabel).html(o2.value).appendTo(data);
        if (o2.showLabel === false) {
          label.hide();
        }
        if (o2.showValue === false) {
          value.hide();
        }
        this.val(o2.value);
        this.buff(o2.buffer);
        this._fireEvent("progress-create", {
          element: element2
        });
      },
      val: function(v4) {
        const that = this, element2 = this.element, o2 = this.options;
        const value = this.component.find(".progress-value");
        if (v4 === void 0) {
          return that.value;
        }
        const bar = element2.find(".bar");
        if (bar.length === 0) {
          return false;
        }
        this.value = parseInt(v4, 10);
        bar.css("width", this.value + "%");
        value.html(this.value + "%");
        this._fireEvent("value-change", {
          val: this.value
        });
        if (this.value === 100) {
          this._fireEvent("complete", {
            val: this.value
          });
        }
      },
      buff: function(v4) {
        const that = this, element2 = this.element;
        if (v4 === void 0) {
          return that.buffer;
        }
        const bar = element2.find(".buffer");
        if (bar.length === 0) {
          return false;
        }
        this.buffer = parseInt(v4, 10);
        bar.css("width", this.buffer + "%");
        this._fireEvent("buffer-change", {
          val: this.buffer
        });
        if (this.buffer === 100) {
          this._fireEvent("buffered", {
            val: this.buffer
          });
        }
      },
      changeValue: function() {
        this.val(this.element.attr("data-value"));
      },
      changeBuffer: function() {
        this.buff(this.element.attr("data-buffer"));
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-value":
            this.changeValue();
            break;
          case "data-buffer":
            this.changeBuffer();
            break;
        }
      },
      destroy: function() {
        this.component.remove();
      }
    });
  })(Metro, Dom);

  // source/components/rating/rating.js
  (function(Metro2, $5) {
    "use strict";
    let RatingDefaultConfig = {
      ratingDeferred: 0,
      label: "",
      static: false,
      title: null,
      value: 0,
      values: null,
      message: "",
      stars: 5,
      onColor: null,
      offColor: null,
      roundFunc: "round",
      // ceil, floor, round
      half: true,
      symbol: "\u2605",
      clsRating: "",
      clsTitle: "",
      clsStars: "",
      clsResult: "",
      clsLabel: "",
      onStarClick: Metro2.noop,
      onRatingCreate: Metro2.noop
    };
    Metro2.ratingSetup = function(options) {
      RatingDefaultConfig = $5.extend({}, RatingDefaultConfig, options);
    };
    if (typeof globalThis["metroRatingSetup"] !== "undefined") {
      Metro2.ratingSetup(globalThis["metroRatingSetup"]);
    }
    Metro2.Component("rating", {
      init: function(options, elem) {
        this._super(elem, options, RatingDefaultConfig, {
          value: 0,
          originValue: 0,
          values: [],
          rate: 0,
          rating: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element, o2 = this.options;
        let i3;
        if (isNaN(o2.value)) {
          o2.value = 0;
        } else {
          o2.value = parseFloat(o2.value).toFixed(1);
        }
        if (o2.values !== null) {
          if (Array.isArray(o2.values)) {
            this.values = o2.values;
          } else if (typeof o2.values === "string") {
            this.values = o2.values.toArray();
          }
        } else {
          for (i3 = 1; i3 <= o2.stars; i3++) {
            this.values.push(i3);
          }
        }
        this.originValue = o2.value;
        this.value = o2.value > 0 && o2.roundFunc !== "none" ? Math[o2.roundFunc](o2.value) : Math.abs(o2.value);
        this._createRating();
        this._createEvents();
        this._fireEvent("rating-create", {
          element: element2
        });
      },
      _createRating: function() {
        const element2 = this.element, o2 = this.options;
        const id = Metro2.utils.elementId("rating");
        let i3, stars, result, li;
        const sheet = Metro2.sheet;
        const value = o2.static ? Math.floor(this.originValue) : this.value;
        const rating = element2.wrap("<div>").addClass("rating " + element2[0].className).addClass(o2.clsRating);
        element2.val(this.value);
        rating.attr("id", element2.id() ? "rating--" + element2.id() : id);
        stars = $5("<ul>").addClass("stars").addClass(o2.clsStars).appendTo(rating);
        for (i3 = 1; i3 <= o2.stars; i3++) {
          li = $5("<li>").attr("data-symbol", o2.symbol).data("value", this.values[i3 - 1]).appendTo(stars);
          if (i3 <= value) {
            li.addClass("on");
          }
        }
        result = $5("<span>").addClass("result").addClass(o2.clsResult).appendTo(rating);
        result.html(o2.message);
        if (o2.offColor !== null && (o2.offColor.includes("var(") || Farbe.Routines.isColor(o2.offColor))) {
        }
        if (o2.onColor !== null && (o2.onColor.includes("var(") || Farbe.Routines.isColor(o2.onColor))) {
          Metro2.utils.addCssRule(sheet, "#" + id + " .stars:hover li", "color: " + o2.onColor + ";");
          Metro2.utils.addCssRule(sheet, "#" + id + " .stars li.on", "color: " + o2.onColor + ";");
          Metro2.utils.addCssRule(sheet, "#" + id + " .stars li.half::after", "color: " + o2.onColor + ";");
        }
        if (o2.title !== null) {
          const title = $5("<span>").addClass("title").addClass(o2.clsTitle).html(o2.title);
          rating.prepend(title);
        }
        if (o2.static === true) {
          rating.addClass("static");
          if (o2.half === true) {
            const dec = Math.round(this.originValue % 1 * 10);
            if (dec > 0 && dec <= 9) {
              rating.find(".stars li.on").last().next("li").addClass("half half-" + dec * 10);
            }
          }
        }
        element2[0].className = "";
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(rating);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id2 = Hooks.useId(element2[0]);
            label.attr("for", id2);
            element2.attr("id", id2);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.rating = rating;
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const rating = this.rating;
        rating.on(Metro2.events.click, ".stars li", function() {
          if (o2.static === true) {
            return;
          }
          const star = $5(this);
          const value = star.data("value");
          star.addClass("scale");
          setTimeout(function() {
            star.removeClass("scale");
          }, 300);
          element2.val(value).trigger("change");
          star.addClass("on");
          star.prevAll().addClass("on");
          star.nextAll().removeClass("on");
          that._fireEvent("star-click", {
            value,
            star: star[0]
          });
        });
      },
      val: function(v4) {
        const that = this, element2 = this.element, o2 = this.options;
        const rating = this.rating;
        if (v4 === void 0) {
          return this.value;
        }
        this.value = v4 > 0 ? Math[o2.roundFunc](v4) : 0;
        element2.val(this.value).trigger("change");
        const stars = rating.find(".stars li").removeClass("on");
        $5.each(stars, function() {
          var star = $5(this);
          if (star.data("value") <= that.value) {
            star.addClass("on");
          }
        });
        return this;
      },
      msg: function(m4) {
        const rating = this.rating;
        if (m4 === void 0) {
          return;
        }
        rating.find(".result").html(m4);
        return this;
      },
      static: function(mode) {
        const o2 = this.options;
        const rating = this.rating;
        o2.static = mode;
        if (mode === true) {
          rating.addClass("static");
        } else {
          rating.removeClass("static");
        }
      },
      changeAttributeStatic: function() {
        const element2 = this.element;
        const isStatic = JSON.parse(element2.attr("data-static")) === true;
        this.static(isStatic);
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName, value) {
        switch (attributeName) {
          case "value":
          case "data-value":
            this.val(value);
            break;
          case "disabled":
            this.toggleState();
            break;
          case "data-message":
            this.msg(value);
            break;
          case "data-static":
            this.changeAttributeStatic();
            break;
        }
      },
      destroy: function() {
        const o2 = this.options;
        const rating = this.rating;
        rating.off(Metro2.events.click, ".stars li");
        if (o2.label) {
          rating.prev("label").remove();
        }
        rating.remove();
      }
    });
  })(Metro, Dom);

  // source/components/remote-dataset/remote-dataset.js
  (function(Metro2, $5) {
    "use strict";
    var RemoteDatasetDefaultConfig = {
      caption: "",
      url: "",
      searchUrl: "",
      method: "GET",
      limit: 10,
      offset: 0,
      sort: "",
      limitKey: "limit",
      offsetKey: "offset",
      searchKey: "query",
      totalKey: "total",
      dataKey: "data",
      sortKey: "sortBy",
      orderKey: "order",
      shortPagination: false,
      rows: 10,
      rowsSteps: "10,25,50,100",
      sortRules: "",
      showSearch: true,
      showOrder: true,
      showRowsCount: true,
      template: "",
      clsBody: "",
      clsItem: "",
      clsPagination: "",
      clsSearchBlock: "",
      clsOrderBlock: "",
      clsRowsCountBlock: "",
      onLoad: (f5) => f5,
      onDrawRow: Metro2.noop,
      onDrawCell: Metro2.noop,
      onDatasetCreate: Metro2.noop
    };
    Metro2.remoteDatasetSetup = function(options) {
      RemoteDatasetDefaultConfig = $5.extend({}, RemoteDatasetDefaultConfig, options);
    };
    if (typeof globalThis["metroRemoteDatasetSetup"] !== "undefined") {
      Metro2.remoteDatasetSetup(globalThis["metroRemoteDatasetSetup"]);
    }
    Metro2.Component("remote-dataset", {
      init: function(options, elem) {
        this._super(elem, options, RemoteDatasetDefaultConfig, {
          // define instance vars here
          data: null,
          total: 0
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        this.offset = o2.offset;
        this.rowSteps = o2.rowsSteps.toArray(",");
        this.limit = +o2.rows;
        this.url = o2.url;
        this.search = "";
        const [field, order] = o2.sort.toArray(":");
        this.sortField = field;
        this.sortOrder = order;
        this.template = Metro2.utils.exec(o2.template);
        this.sortRules = o2.sortRules.toArray(",").filter((f5) => f5).map((rule) => rule.toArray(":"));
        this._createStructure();
        this._createEvents();
        this._loadData().then(() => {
        });
        this._fireEvent("dataset-create");
      },
      _loadData: async function(append = false) {
        const o2 = this.options;
        if (!this.url) {
          return;
        }
        let url = this.url + "?" + o2.limitKey + "=" + this.limit + "&" + o2.offsetKey + "=" + this.offset;
        if (this.sortField) {
          url += "&" + o2.sortKey + "=" + this.sortField + "&" + o2.orderKey + "=" + this.sortOrder;
        }
        if (this.search) {
          url += "&" + o2.searchKey + "=" + this.search;
        }
        const response = await fetch(url, { method: o2.method });
        if (response.ok === false) {
          return;
        }
        this.data = Metro2.utils.exec(o2.onLoad, [await response.json()], this);
        this._createEntries(append);
      },
      _createStructure: function() {
        var that = this, element2 = this.element, o2 = this.options;
        let entries;
        element2.addClass("remote-dataset");
        element2.append(entries = $5("<div>").addClass("dataset-entry"));
        entries.html(`
                <div class="service-block">
                    <div class="search-block ${o2.clsSearchBlock} ${o2.showSearch ? "" : "hide-block"}">
                        <input name="search" type="text" data-role="input" 
                            data-prepend="${this.strings.label_search}" 
                            data-search-button="true" 
                            />
                    </div>
                   
                    <div class="order-block ${o2.clsOrderBlock} ${this.sortRules.length === 0 || o2.showOrder === false ? "hide-block" : ""}">
                        <select name="sort-order" data-role="select" data-filter="false">
                            ${this.sortRules.map((rule) => `
                                <option value="${rule[0]}:${rule[1]}" 
                                        ${rule[0] === this.sortField && rule[1] === this.sortOrder ? "selected" : ""}
                                        data-icon="${rule[3] ? rule[3] : ""}"
                                >
                                    ${rule[2]}
                                </option>
                            `).join("")}
                        </select>
                    </div>
                   
                    <div class="count-block ${o2.clsRowsCountBlock} ${o2.showRowsCount ? "" : "hide-block"}">
                        <select name="rows-count" data-role="select" data-prepend="${this.strings.label_rows_count}" data-filter="false">
                            ${this.rowSteps.map((step) => `
                                <option value="${step}" ${+step === this.rowsCount ? "selected" : ""}>
                                    ${step}
                                </option>
                            `).join("")}
                        </select>
                    </div>
                </div>
                <div class="dataset-body"></div>
            `);
        this.body = entries.find(".dataset-body").addClass(o2.clsBody);
        this.loadMore = $5("<div>").addClass("dataset-load-more");
        this.loadMore.html(`
                <button class="button large cycle link load-more-button">
                    <span class="icon">\u27F3</span>
                    ${this.strings.label_load_more}
                </button>
            `).appendTo(element2);
        element2.append(
          this.pagination = $5("<div>").addClass("dataset-pagination")
        );
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.on("click", ".page-link", function() {
          const parent2 = $5(this).parent();
          if (parent2.hasClass("service")) {
            if (parent2.hasClass("prev-page")) {
              that.offset -= that.limit;
              if (that.offset < 0) {
                that.offset = 0;
              }
            } else {
              that.offset += that.limit;
            }
            that._loadData().then(() => {
            });
            return;
          }
          that.offset = $5(this).data("page") * that.limit - that.limit;
          that._loadData().then(() => {
          });
        });
        const searchFn = Hooks.useDebounce(() => {
          const val = element2.find("input[name=search]").val().trim();
          if (val === "") {
            this.search = "";
            this.url = o2.url;
            this._loadData().then(() => {
            });
            return;
          }
          if (val.length < 3) {
            return;
          }
          this.search = val;
          this.url = o2.searchUrl;
          this._loadData().then(() => {
          });
        }, 300);
        element2.on(Metro2.events.inputchange, "input[name=search]", searchFn);
        element2.on("change", "select[name=rows-count]", function() {
          that.limit = +$5(this).val();
          that.offset = 0;
          that._loadData().then(() => {
          });
        });
        element2.on("change", "select[name=sort-order]", function() {
          const [field, order] = $5(this).val().split(":");
          that.url = o2.url;
          that.sortField = field;
          that.sortOrder = order;
          that.offset = 0;
          that._loadData().then(() => {
          });
        });
        element2.on("click", ".load-more-button", function() {
          that.offset += that.limit;
          that._loadData(true).then(() => {
          });
        });
      },
      _createEntries: function(append = false) {
        var that = this, element2 = this.element, o2 = this.options;
        if (!this.data) {
          return;
        }
        const usePagination = Metro2.utils.isValue(this.data[o2.totalKey]);
        this.entries = this.data[o2.dataKey];
        this.total = this.data[o2.totalKey];
        if (append === false) this.body.clear();
        this.entries.forEach((entry, index) => {
          const item = $5("<div>").addClass("dataset-item").addClass(o2.clsItem).addClass(index % 2 === 0 ? "even" : "odd");
          const html = Metro2.utils.exec(o2.template, [entry], entry);
          item.html(html).appendTo(that.body);
        });
        if (usePagination && !o2.shortPagination) {
          Metro2.pagination({
            length: this.total,
            rows: this.limit,
            current: this.offset === 0 ? 1 : Math.round(this.offset / this.limit) + 1,
            target: this.pagination,
            clsPagination: o2.clsPagination
          });
        } else {
          this.pagination.html(`
                    <div class="short-pagination">
                        <div class="button service prev-page"><a href="javascript:void(0)" class="page-link">${this.strings.label_prev}</a></div>
                        <div class="button service next-page"><a href="javascript:void(0)" class="page-link">${this.strings.label_next}</a></div>
                    </div>
                `);
        }
      },
      /*
      * options = {
      *   caption: "",
      *   url: "",
      *   searchUrl: "",
      *   method: "GET",
      *   limit: 10,
      *   offset: 0,
      *   sort: "",
      *   sortOrder: "asc",
      *   limitKey: "limit",
      * }
      * */
      setup: function(options) {
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/remote-table/remote-table.js
  (function(Metro2, $5) {
    "use strict";
    let RemoteTableDefaultConfig = {
      caption: "",
      url: "",
      searchUrl: "",
      method: "GET",
      limit: 10,
      offset: 0,
      fields: "",
      sortableFields: "",
      colSize: "",
      sort: "",
      sortOrder: "asc",
      captions: null,
      limitKey: "limit",
      offsetKey: "offset",
      searchKey: "query",
      totalKey: "total",
      dataKey: "data",
      sortKey: "sortBy",
      orderKey: "order",
      shortPagination: false,
      rows: 10,
      rowsSteps: "10,25,50,100",
      clsTable: "",
      clsPagination: "",
      onLoad: (f5) => f5,
      onDrawRow: Metro2.noop,
      onDrawCell: Metro2.noop,
      onDrawHeadCell: Metro2.noop,
      onTableCreate: Metro2.noop
    };
    Metro2.remoteTableSetup = function(options) {
      RemoteTableDefaultConfig = $5.extend({}, RemoteTableDefaultConfig, options);
    };
    if (typeof globalThis["metroRemoteTableSetup"] !== "undefined") {
      Metro2.remoteTableSetup(globalThis["metroRemoteTableSetup"]);
    }
    Metro2.Component("remote-table", {
      init: function(options, elem) {
        this._super(elem, options, RemoteTableDefaultConfig, {
          // define instance vars here
          data: null,
          total: 0
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        this.offset = o2.offset;
        this.fields = o2.fields.toArray(",");
        this.captions = o2.captions ? o2.captions.toArray(",") : null;
        this.rowSteps = o2.rowsSteps.toArray(",");
        this.colSize = o2.colSize.toArray(",");
        this.limit = +o2.rows;
        this.url = o2.url;
        this.search = "";
        this.sortField = o2.sort;
        this.sortOrder = o2.sortOrder;
        this._createStructure();
        this._createEvents();
        this._loadData().then(() => {
        });
        this._fireEvent("table-create");
      },
      _loadData: async function() {
        const o2 = this.options;
        if (!this.url) {
          return;
        }
        let url = this.url + "?" + o2.limitKey + "=" + this.limit + "&" + o2.offsetKey + "=" + this.offset;
        if (this.sortField) {
          url += "&" + o2.sortKey + "=" + this.sortField + "&" + o2.orderKey + "=" + this.sortOrder;
        }
        if (this.search) {
          url += "&" + o2.searchKey + "=" + this.search;
        }
        const response = await fetch(url, { method: o2.method });
        if (response.ok === false) {
          return;
        }
        this.data = Metro2.utils.exec(o2.onLoad, [await response.json()], this);
        this._createEntries();
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        let entries;
        element2.addClass("table-component remote-table");
        element2.append(entries = $5("<div>").addClass("table-entry"));
        entries.html(`
                <div class="search-block row">
                    <div class="cell-sm-10">
                        <input name="search" type="text" data-role="input" 
                            data-prepend="${this.strings.label_search}" 
                            data-search-button="true" 
                            />
                    </div>
                    <div class="cell-sm-2">
                        <select name="rows-count" data-role="select" data-prepend="${this.strings.label_rows_count}" data-filter="false">
                            ${this.rowSteps.map((step) => `<option value="${step}" ${+step === this.rowsCount ? "selected" : ""}>${step}</option>`).join("")}
                        </select>
                    </div>
                </div>
                <table class="table ${o2.clsTable}">
                    <caption>${o2.caption}</caption>
                    <thead></thead>
                    <tbody></tbody>
                </table>
            `);
        this.header = entries.find("thead");
        this.body = entries.find("tbody");
        element2.append(
          this.pagination = $5("<div>").addClass("table-pagination")
        );
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.on("click", ".page-link", function() {
          const parent2 = $5(this).parent();
          if (parent2.hasClass("service")) {
            if (parent2.hasClass("prev-page")) {
              that.offset -= that.limit;
              if (that.offset < 0) {
                that.offset = 0;
              }
            } else {
              that.offset += that.limit;
            }
            that._loadData().then(() => {
            });
            return;
          }
          that.offset = $5(this).data("page") * that.limit - that.limit;
          that._loadData().then(() => {
          });
        });
        const searchFn = Hooks.useDebounce(() => {
          const val = element2.find("input[name=search]").val().trim();
          if (val === "") {
            this.search = "";
            this.url = o2.url;
            this._loadData().then(() => {
            });
            return;
          }
          if (val.length < 3) {
            return;
          }
          this.search = val;
          this.url = o2.searchUrl;
          this._loadData().then(() => {
          });
        }, 300);
        element2.on(Metro2.events.inputchange, "input[name=search]", searchFn);
        element2.on("change", "select[name=rows-count]", function() {
          that.limit = +$5(this).val();
          that.offset = 0;
          that._loadData().then(() => {
          });
        });
        element2.on("click", ".sortable-column", function() {
          const field = $5(this).attr("data-field");
          if (that.sortField === field) {
            that.sortOrder = that.sortOrder === "asc" ? "desc" : "asc";
          } else {
            that.sortField = field;
            that.sortOrder = "asc";
          }
          that._loadData().then(() => {
          });
        });
      },
      _createEntries: function() {
        const o2 = this.options;
        if (!this.data) {
          return;
        }
        const usePagination = Metro2.utils.isValue(this.data[o2.totalKey]);
        this.entries = this.data[o2.dataKey];
        this.total = this.data[o2.totalKey];
        this.header.clear();
        this.body.clear();
        const headerRow = $5("<tr>").addClass("table-header").appendTo(this.header);
        let hIndex = 0;
        for (let key of Object.keys(this.entries[0])) {
          if (this.fields.length && !this.fields.includes(key)) {
            continue;
          }
          const cellData = this.captions ? this.captions[hIndex] : key;
          const cell = $5("<th>").html(cellData).attr("data-field", key);
          if (o2.sortableFields && o2.sortableFields.includes(key)) {
            cell.addClass("sortable-column");
            if (this.sortField === key) {
              cell.addClass(`sort-${this.sortOrder}`);
            }
          }
          cell.appendTo(headerRow).addClass(`head-cell-${key}`);
          if (this.colSize[hIndex]) {
            cell.css("width", this.colSize[hIndex]);
          }
          Metro2.utils.exec(o2.onDrawHeadCell, [cell[0], cellData, key, hIndex, o2.sortableFields.includes(key), this.sortField === key, this.sortOrder], this);
          hIndex++;
        }
        this.entries.forEach((entry, index) => {
          const row = $5("<tr>").addClass("table-row");
          this.body.append(row);
          Metro2.utils.exec(o2.onDrawRow, [row, entry, index], this);
          let hIndex2 = 0;
          for (let key in entry) {
            if (this.fields.length && !this.fields.includes(key)) {
              continue;
            }
            const cell = $5("<td>").attr("data-label", this.captions ? this.captions[hIndex2] : key).addClass(`data-cell-${key}`).html(entry[key]);
            row.append(cell);
            Metro2.utils.exec(o2.onDrawCell, [cell[0], entry[key], key, entry, index], this);
            hIndex2++;
          }
        });
        if (usePagination && !o2.shortPagination) {
          Metro2.pagination({
            length: this.total,
            rows: this.limit,
            current: this.offset === 0 ? 1 : Math.round(this.offset / this.limit) + 1,
            target: this.pagination,
            clsPagination: o2.clsPagination
          });
        } else {
          this.pagination.html(`
                    <div class="short-pagination">
                        <div class="button service prev-page"><a href="javascript:void(0)" class="page-link">${this.strings.label_prev}</a></div>
                        <div class="button service next-page"><a href="javascript:void(0)" class="page-link">${this.strings.label_next}</a></div>
                    </div>
                `);
        }
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/resizable/resizable.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var ResizableDefaultConfig = {
      resizableDeferred: 0,
      canResize: true,
      resizeElement: ".resize-element",
      minWidth: 0,
      minHeight: 0,
      maxWidth: 0,
      maxHeight: 0,
      preserveRatio: false,
      onResizeStart: Metro2.noop,
      onResizeStop: Metro2.noop,
      onResize: Metro2.noop,
      onResizableCreate: Metro2.noop
    };
    Metro2.resizableSetup = function(options) {
      ResizableDefaultConfig = $5.extend({}, ResizableDefaultConfig, options);
    };
    if (typeof globalThis["metroResizableSetup"] !== "undefined") {
      Metro2.resizableSetup(globalThis["metroResizableSetup"]);
    }
    Metro2.Component("resizable", {
      init: function(options, elem) {
        this._super(elem, options, ResizableDefaultConfig, {
          resizer: null,
          id: Utils.elementId("resizable")
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("resizable-create");
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        element2.data("canResize", true);
        element2.addClass("resizable-element");
        if (Utils.isValue(o2.resizeElement) && element2.find(o2.resizeElement).length > 0) {
          this.resizer = element2.find(o2.resizeElement);
        } else {
          this.resizer = $5("<span>").addClass("resize-element").appendTo(element2);
        }
        element2.data("canResize", o2.canResize);
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        this.resizer.on(Metro2.events.start, function(e2) {
          if (element2.data("canResize") === false) {
            return;
          }
          var startXY = Utils.pageXY(e2);
          var startWidth = parseInt(element2.outerWidth());
          var startHeight = parseInt(element2.outerHeight());
          var size = { width: startWidth, height: startHeight };
          element2.addClass("stop-pointer");
          that._fireEvent("resize-start", {
            size
          });
          $5(document).on(Metro2.events.move, function(e3) {
            var moveXY = Utils.pageXY(e3);
            var size2 = {
              width: startWidth + moveXY.x - startXY.x,
              height: startHeight + moveXY.y - startXY.y
            };
            if (o2.maxWidth > 0 && size2.width > o2.maxWidth) {
              return true;
            }
            if (o2.minWidth > 0 && size2.width < o2.minWidth) {
              return true;
            }
            if (o2.maxHeight > 0 && size2.height > o2.maxHeight) {
              return true;
            }
            if (o2.minHeight > 0 && size2.height < o2.minHeight) {
              return true;
            }
            element2.css(size2);
            that._fireEvent("resize", {
              size: size2
            });
          }, { ns: that.id });
          $5(document).on(Metro2.events.stop, function() {
            element2.removeClass("stop-pointer");
            $5(document).off(Metro2.events.move, { ns: that.id });
            $5(document).off(Metro2.events.stop, { ns: that.id });
            var size2 = {
              width: parseInt(element2.outerWidth()),
              height: parseInt(element2.outerHeight())
            };
            that._fireEvent("resize-stop", {
              size: size2
            });
          }, { ns: that.id });
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      off: function() {
        this.element.data("canResize", false);
      },
      on: function() {
        this.element.data("canResize", true);
      },
      changeAttribute: function(attributeName) {
        var element2 = this.element, o2 = this.options;
        var canResize = function() {
          o2.canResize = JSON.parse(element2.attr("data-can-resize")) === true;
        };
        switch (attributeName) {
          case "data-can-resize":
            canResize();
            break;
        }
      },
      destroy: function() {
        this.resizer.off(Metro2.events.start);
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/resizer/resizer.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var ResizerDefaultConfig = {
      resizerDeferred: 0,
      onMediaPoint: Metro2.noop,
      onMediaPointEnter: Metro2.noop,
      onMediaPointLeave: Metro2.noop,
      onWindowResize: Metro2.noop,
      onElementResize: Metro2.noop,
      onResizerCreate: Metro2.noop
    };
    Metro2.resizerSetup = function(options) {
      ResizerDefaultConfig = $5.extend({}, ResizerDefaultConfig, options);
    };
    if (typeof globalThis["metroResizerSetup"] !== "undefined") {
      Metro2.resizerSetup(globalThis["metroResizerSetup"]);
    }
    Metro2.Component("resizer", {
      init: function(options, elem) {
        this._super(elem, options, ResizerDefaultConfig, {
          size: { width: 0, height: 0 },
          media: globalThis.METRO_MEDIA,
          id: Utils.elementId("resizer")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this.size = {
          width: element2.width(),
          height: element2.height()
        };
        this._createStructure();
        this._createEvents();
        this._fireEvent("resizer-create", {
          element: element2
        });
      },
      _createStructure: function() {
      },
      _createEvents: function() {
        var that = this, element2 = this.element;
        var win = $5.window();
        win.on("resize", function() {
          var windowWidth = win.width(), windowHeight = win.height();
          var elementWidth = element2.width(), elementHeight = element2.height();
          var oldSize = that.size;
          var point;
          that._fireEvent("window-resize", {
            width: windowWidth,
            height: windowHeight,
            media: globalThis.METRO_MEDIA
          });
          if (that.size.width !== elementWidth || that.size.height !== elementHeight) {
            that.size = {
              width: elementWidth,
              height: elementHeight
            };
            that._fireEvent("element-resize", {
              width: elementWidth,
              height: elementHeight,
              oldSize,
              media: globalThis.METRO_MEDIA
            });
          }
          if (that.media.length !== globalThis.METRO_MEDIA.length) {
            if (that.media.length > globalThis.METRO_MEDIA.length) {
              point = that.media.filter(function(x4) {
                return !globalThis.METRO_MEDIA.includes(x4);
              });
              that._fireEvent("media-point-leave", {
                point,
                media: globalThis.METRO_MEDIA
              });
            } else {
              point = globalThis.METRO_MEDIA.filter(function(x4) {
                return !that.media.includes(x4);
              });
              that._fireEvent("media-point-enter", {
                point,
                media: globalThis.METRO_MEDIA
              });
            }
            that.media = globalThis.METRO_MEDIA;
            that._fireEvent("media-point", {
              point,
              media: globalThis.METRO_MEDIA
            });
          }
        }, { ns: this.id });
      },
      changeAttribute: function() {
      },
      destroy: function() {
        $5(globalThis).off("resize", { ns: this.id });
      }
    });
  })(Metro, Dom);

  // source/components/ribbon-menu/ribbon-menu.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var RibbonMenuDefaultConfig = {
      ribbonmenuDeferred: 0,
      onStatic: Metro2.noop,
      onBeforeTab: Metro2.noop_true,
      onTab: Metro2.noop,
      onRibbonMenuCreate: Metro2.noop
    };
    Metro2.ribbonMenuSetup = function(options) {
      RibbonMenuDefaultConfig = $5.extend({}, RibbonMenuDefaultConfig, options);
    };
    if (typeof globalThis["metroRibbonMenuSetup"] !== "undefined") {
      Metro2.ribbonMenuSetup(globalThis["metroRibbonMenuSetup"]);
    }
    Metro2.Component("ribbon-menu", {
      init: function(options, elem) {
        this._super(elem, options, RibbonMenuDefaultConfig);
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("ribbon-menu-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var element2 = this.element;
        element2.addClass("ribbon-menu");
        var fluentGroups = element2.find(".ribbon-toggle-group");
        $5.each(fluentGroups, function() {
          var g4 = $5(this);
          g4.buttongroup({
            clsActive: "active"
          });
          var gw = 0;
          var btns = g4.find(".ribbon-icon-button");
          $5.each(btns, function() {
            var b4 = $5(this);
            var w5 = b4.outerWidth(true);
            if (w5 > gw) gw = w5;
          });
          g4.css("width", gw * Math.ceil(btns.length / 3) + 4);
        });
        element2.find(".section").addClass("non-active");
        var tabs = element2.find(".tabs-holder li:not(.static)");
        var active_tab = element2.find(".tabs-holder li.active");
        if (active_tab.length > 0) {
          this.open($5(active_tab[0]));
        } else {
          if (tabs.length > 0) {
            this.open($5(tabs[0]));
          }
        }
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.click, ".tabs-holder li a", function(e2) {
          var link = $5(this);
          var tab = $5(this).parent("li");
          if (tab.hasClass("static")) {
            if (o2.onStatic === Metro2.noop && link.attr("href") !== void 0) {
              document.location.href = link.attr("href");
            } else {
              that._fireEvent("static", {
                tab: tab[0]
              });
            }
          } else {
            if (Utils.exec(o2.onBeforeTab, [tab[0]], element2[0]) === true) {
              that.open(tab[0]);
            }
          }
          e2.preventDefault();
        });
      },
      open: function(tab) {
        var element2 = this.element;
        var $tab = $5(tab);
        var tabs = element2.find(".tabs-holder li");
        var sections = element2.find(".content-holder .section");
        var target = $tab.children("a").attr("href");
        var target_section = target !== "#" ? element2.find(target) : null;
        sections.addClass("non-active");
        tabs.removeClass("active");
        $tab.addClass("active");
        sections.removeClass("active");
        if (target_section) {
          target_section.addClass("active").removeClass("non-active");
        }
        this._fireEvent("tab", {
          tab: $tab[0]
        });
      },
      changeAttribute: function() {
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.click, ".tabs-holder li a");
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/ripple/ripple.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var RippleDefaultConfig = {
      rippleDeferred: 0,
      rippleColor: "#fff",
      rippleAlpha: 0.4,
      rippleTarget: "default",
      onRippleCreate: Metro2.noop
    };
    Metro2.rippleSetup = function(options) {
      RippleDefaultConfig = $5.extend({}, RippleDefaultConfig, options);
    };
    if (typeof globalThis["metroRippleSetup"] !== "undefined") {
      Metro2.rippleSetup(globalThis["metroRippleSetup"]);
    }
    var getRipple = function(target, color, alpha, event) {
      var el = $5(target);
      var rect = Utils.rect(el[0]);
      var x4, y3;
      if (el.length === 0) {
        return;
      }
      if (!Utils.isValue(color)) {
        color = "#fff";
      }
      if (!Utils.isValue(alpha)) {
        alpha = 0.4;
      }
      if (el.css("position") === "static") {
        el.css("position", "relative");
      }
      el.css({
        overflow: "hidden"
      });
      $5(".ripple").remove();
      var size = Math.max(el.outerWidth(), el.outerHeight());
      var ripple = $5("<span class='ripple'></span>").css({
        width: size,
        height: size
      });
      el.prepend(ripple);
      if (event) {
        x4 = event.pageX - el.offset().left - ripple.width() / 2;
        y3 = event.pageY - el.offset().top - ripple.height() / 2;
      } else {
        x4 = rect.width / 2 - ripple.width() / 2;
        y3 = rect.height / 2 - ripple.height() / 2;
      }
      ripple.css({
        background: Farbe.Routines.toRGBA(Farbe.Routines.parse(color), alpha),
        width: size,
        height: size,
        top: y3 + "px",
        left: x4 + "px"
      }).addClass("rippleEffect");
      setTimeout(function() {
        ripple.remove();
      }, 400);
    };
    Metro2.Component("ripple", {
      init: function(options, elem) {
        this._super(elem, options, RippleDefaultConfig);
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        var target = o2.rippleTarget === "default" ? null : o2.rippleTarget;
        element2.on(Metro2.events.click, target, function(e2) {
          getRipple(this, o2.rippleColor, o2.rippleAlpha, e2);
        });
        this._fireEvent("riopple-create", {
          element: element2
        });
      },
      changeAttribute: function(attributeName) {
        var element2 = this.element, o2 = this.options;
        function changeColor() {
          var color = element2.attr("data-ripple-color");
          if (!Farbe.Routines.isColor(color)) {
            return;
          }
          o2.rippleColor = color;
        }
        function changeAlpha() {
          var alpha = +element2.attr("data-ripple-alpha");
          if (isNaN(alpha)) {
            return;
          }
          o2.rippleColor = alpha;
        }
        switch (attributeName) {
          case "data-ripple-color":
            changeColor();
            break;
          case "data-ripple-alpha":
            changeAlpha();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element, o2 = this.options;
        var target = o2.rippleTarget === "default" ? null : o2.rippleTarget;
        element2.off(Metro2.events.click, target);
      }
    });
    Metro2.ripple = getRipple;
  })(Metro, Dom);

  // source/components/searcher/searcher.js
  (function(Metro2, $5) {
    "use strict";
    var SearcherDefaultConfig = {
      onSearcherCreate: Metro2.noop
    };
    Metro2.searcherSetup = function(options) {
      SearcherDefaultConfig = $5.extend({}, SearcherDefaultConfig, options);
    };
    if (typeof globalThis["metroSearcherSetup"] !== "undefined") {
      Metro2.searcherSetup(globalThis["metroSearcherSetup"]);
    }
    Metro2.Component("searcher", {
      init: function(options, elem) {
        this._super(elem, options, SearcherDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        var that = this, element2 = this.element, o2 = this.options;
        this._createStructure();
        this._createEvents();
        this._fireEvent("searcher-create");
      },
      _createStructure: function() {
        var that = this, element2 = this.element, o2 = this.options;
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/sidebar/sidebar.js
  (function(Metro2, $5) {
    "use strict";
    let SidebarDefaultConfig = {
      menuScrollbar: false,
      sidebarDeferred: 0,
      position: "left",
      shift: null,
      staticShift: null,
      toggle: null,
      duration: METRO_ANIMATION_DURATION,
      static: null,
      closeOutside: true,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onToggle: Metro2.noop,
      onStaticSet: Metro2.noop,
      onStaticLoss: Metro2.noop,
      onSidebarCreate: Metro2.noop
    };
    Metro2.sidebarSetup = function(options) {
      SidebarDefaultConfig = $5.extend({}, SidebarDefaultConfig, options);
    };
    if (typeof globalThis["metroSidebarSetup"] !== "undefined") {
      Metro2.sidebarSetup(globalThis["metroSidebarSetup"]);
    }
    Metro2.Component("sidebar", {
      init: function(options, elem) {
        this._super(elem, options, SidebarDefaultConfig, {
          toggle_element: null,
          id: Metro2.utils.elementId("sidebar")
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        $5(globalThis).resize();
        this._checkStatic();
        this._fireEvent("sidebar-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        const header = element2.find(".sidebar-header");
        const sheet = Metro2.sheet;
        const menu = element2.find(".sidebar-menu");
        const size = element2.outerWidth();
        element2.addClass("sidebar").addClass("on-" + o2.position);
        if (o2.menuScrollbar === false) {
          menu.addClass("hide-scroll");
        }
        if (o2.toggle !== null && $5(o2.toggle).length > 0) {
          this.toggle_element = $5(o2.toggle);
        }
        if (header.length > 0) {
          if (header.data("image")) {
            header.css({
              backgroundImage: "url(" + header.data("image") + ")"
            });
          }
        }
        if (o2.static !== null) {
          if (o2.staticShift !== null) {
            if (o2.position === "left") {
              Metro2.utils.addCssRule(sheet, "@media screen and " + Metro2.media_queries[o2.static.toUpperCase()], o2.staticShift + "{margin-left: " + size + "px; width: calc(100% - " + size + "px);}");
            } else {
              Metro2.utils.addCssRule(sheet, "@media screen and " + Metro2.media_queries[o2.static.toUpperCase()], o2.staticShift + "{margin-right: " + size + "px; width: calc(100% - " + size + "px);}");
            }
          }
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const toggle = this.toggle_element;
        if (toggle !== null) {
          toggle.on(Metro2.events.click, function(e2) {
            that.toggle();
            e2.stopPropagation();
          });
        } else if (o2.toggle) {
          $5.document().on("click", o2.toggle, function(e2) {
            that.toggle();
            e2.stopPropagation();
          });
        }
        if (o2.static !== null && Metro2.media_modes.includes(o2.static)) {
          $5(globalThis).on(Metro2.events.resize, function() {
            that._checkStatic();
          }, { ns: this.id });
        }
        element2.on(Metro2.events.click, ".sidebar-menu .js-sidebar-close", function(e2) {
          that.close();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, function(e2) {
          e2.stopPropagation();
        });
        $5(document).on(Metro2.events.click, function() {
          if (o2.closeOutside === true) {
            if (that.isOpen()) that.close();
          }
        });
      },
      _checkStatic: function() {
        const element2 = this.element, o2 = this.options;
        if (Metro2.utils.mediaExist(o2.static) && !element2.hasClass("static")) {
          element2.addClass("static");
          element2.data("opened", false).removeClass("open");
          if (o2.shift !== null) {
            $5.each(o2.shift.split(","), function() {
              $5(this).animate({
                draw: {
                  left: 0
                },
                dur: o2.duration
              });
            });
          }
          this._fireEvent("static-set");
        }
        if (!Metro2.utils.mediaExist(o2.static)) {
          element2.removeClass("static");
          this._fireEvent("static-loss");
        }
      },
      isOpen: function() {
        return this.element.data("opened") === true;
      },
      open: function() {
        const element2 = this.element, o2 = this.options;
        if (element2.hasClass("static")) {
          return;
        }
        element2.data("opened", true).addClass("open");
        if (o2.shift !== null) {
          $5(o2.shift).animate({
            draw: {
              left: element2.outerWidth()
            },
            dur: o2.duration
          });
        }
        this._fireEvent("open");
      },
      close: function() {
        const element2 = this.element, o2 = this.options;
        if (element2.hasClass("static")) {
          return;
        }
        element2.data("opened", false).removeClass("open");
        if (o2.shift !== null) {
          $5(o2.shift).animate({
            draw: {
              left: 0
            },
            dur: o2.duration
          });
        }
        this._fireEvent("close");
      },
      toggle: function() {
        if (this.isOpen()) {
          this.close();
        } else {
          this.open();
        }
        this._fireEvent("toggle");
      },
      changeAttribute: function() {
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        const toggle = this.toggle_element;
        if (toggle !== null) {
          toggle.off(Metro2.events.click);
        }
        if (o2.static !== null && Metro2.media_modes.includes(o2.static)) {
          $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        }
        element2.off(Metro2.events.click, ".js-sidebar-close");
        return element2;
      }
    });
    Metro2["sidebar"] = {
      isSidebar: function(el) {
        return Metro2.utils.isMetroObject(el, "sidebar");
      },
      open: function(el) {
        if (!this.isSidebar(el)) {
          return;
        }
        Metro2.getPlugin(el, "sidebar").open();
      },
      close: function(el) {
        if (!this.isSidebar(el)) {
          return;
        }
        Metro2.getPlugin(el, "sidebar").close();
      },
      toggle: function(el) {
        if (!this.isSidebar(el)) {
          return;
        }
        Metro2.getPlugin(el, "sidebar").toggle();
      },
      isOpen: function(el) {
        if (!this.isSidebar(el)) {
          return;
        }
        return Metro2.getPlugin(el, "sidebar").isOpen();
      }
    };
  })(Metro, Dom);

  // source/components/sidenav-counter/sidenav.js
  (function(Metro2, $5) {
    "use strict";
    var SidenavCounterDefaultConfig = {
      compacted: false,
      toggle: null,
      expandPoint: "fs",
      onMenuItemClick: Metro2.noop,
      onCollapse: Metro2.noop,
      onExpand: Metro2.noop,
      onSidenavCreate: Metro2.noop
    };
    Metro2.sidenavCounterSetup = function(options) {
      SidenavCounterDefaultConfig = $5.extend({}, SidenavCounterDefaultConfig, options);
    };
    if (typeof globalThis["metroSidenavCounterSetup"] !== "undefined") {
      Metro2.sidenavCounterSetup(globalThis["metroSidenavCounterSetup"]);
    }
    Metro2.Component("sidenav-counter", {
      init: function(options, elem) {
        this._super(elem, options, SidenavCounterDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        var that = this, element2 = this.element, o2 = this.options;
        this._createStructure();
        this._createEvents();
        this._fireEvent("sidenav-create");
      },
      _createStructure: function() {
        var that = this, element2 = this.element, o2 = this.options;
        element2.addClass("sidenav-counter");
        if (Metro2.utils.mediaExist(o2.expandPoint)) {
          element2.addClass("expanded");
        }
        const state2 = Metro2.storage.getItem("sidenav-counter:compacted");
        if (state2 === true) {
          element2.removeClass("expanded");
          element2.addClass("handmade");
        }
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        if (o2.toggle) {
          $5(o2.toggle).on("click", function() {
            element2.toggleClass("expanded");
            element2.toggleClass("handmade");
            Metro2.storage.setItem("sidenav-counter:compacted", !element2.hasClass("expanded"));
          });
        }
        $5(globalThis).on(Metro2.events.resize, () => {
          if (element2.hasClass("handmade")) {
            return;
          }
          if (Metro2.utils.mediaExist(o2.expandPoint)) {
            element2.addClass("expanded");
          } else {
            element2.removeClass("expanded");
          }
        }, { ns: this.id });
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/sorter/sorter.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var SorterDefaultConfig = {
      sorterDeferred: 0,
      thousandSeparator: ",",
      decimalSeparator: ",",
      sortTarget: null,
      sortSource: null,
      sortDir: "asc",
      sortStart: true,
      saveInitial: true,
      onSortStart: Metro2.noop,
      onSortStop: Metro2.noop,
      onSortItemSwitch: Metro2.noop,
      onSorterCreate: Metro2.noop
    };
    Metro2.sorterSetup = function(options) {
      SorterDefaultConfig = $5.extend({}, SorterDefaultConfig, options);
    };
    if (typeof globalThis["metroSorterSetup"] !== "undefined") {
      Metro2.sorterSetup(globalThis["metroSorterSetup"]);
    }
    Metro2.Component("sorter", {
      init: function(options, elem) {
        this._super(elem, options, SorterDefaultConfig, {
          initial: []
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._fireEvent("sorter-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        if (o2.sortTarget === null) {
          o2.sortTarget = element2.children()[0].tagName;
        }
        this.initial = element2.find(o2.sortTarget).get();
        if (o2.sortStart === true) {
          this.sort(o2.sortDir);
        }
      },
      _getItemContent: function(item) {
        var o2 = this.options;
        var data, inset, i3, format;
        if (Utils.isValue(o2.sortSource)) {
          data = "";
          inset = item.getElementsByClassName(o2.sortSource);
          if (inset.length > 0) for (i3 = 0; i3 < inset.length; i3++) {
            data += inset[i3].textContent;
          }
          format = inset[0].dataset.format;
        } else {
          data = item.textContent;
          format = item.dataset.format;
        }
        data = ("" + data).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, " ").trim();
        if (Utils.isValue(format)) {
          if (["number", "int", "float", "money"].indexOf(format) !== -1 && (o2.thousandSeparator !== "," || o2.decimalSeparator !== ".")) {
            data = Utils.parseNumber(data, o2.thousandSeparator, o2.decimalSeparator);
          }
          switch (format) {
            case "date":
              data = Utils.isDate(data) ? new Date(data) : "";
              break;
            case "number":
              data = Number(data);
              break;
            case "int":
              data = parseInt(data);
              break;
            case "float":
              data = parseFloat(data);
              break;
            case "money":
              data = Utils.parseMoney(data);
              break;
            case "card":
              data = Utils.parseCard(data);
              break;
            case "phone":
              data = Utils.parsePhone(data);
              break;
          }
        }
        return data;
      },
      sort: function(dir) {
        var that = this, element2 = this.element, o2 = this.options;
        var items;
        var id = Utils.elementId("temp");
        var prev;
        if (dir) {
          o2.sortDir = dir;
        }
        items = element2.find(o2.sortTarget).get();
        if (items.length === 0) {
          return;
        }
        prev = $5("<div>").attr("id", id).insertBefore($5(element2.find(o2.sortTarget)[0]));
        this._fireEvent("sort-start", {
          items
        });
        items.sort(function(a3, b4) {
          var c1 = that._getItemContent(a3);
          var c22 = that._getItemContent(b4);
          var result = 0;
          if (c1 < c22) {
            result = -1;
          }
          if (c1 > c22) {
            result = 1;
          }
          if (result !== 0) {
            that._fireEvent("sort-item-switch", {
              a: a3,
              b: b4,
              result
            });
          }
          return result;
        });
        if (o2.sortDir === "desc") {
          items.reverse();
        }
        element2.find(o2.sortTarget).remove();
        $5.each(items, function() {
          var $this = $5(this);
          $this.insertAfter(prev);
          prev = $this;
        });
        $5("#" + id).remove();
        this._fireEvent("sort-stop", {
          items
        });
      },
      reset: function() {
        var element2 = this.element, o2 = this.options;
        var items;
        var id = Utils.elementId("sorter");
        var prev;
        items = this.initial;
        if (items.length === 0) {
          return;
        }
        prev = $5("<div>").attr("id", id).insertBefore($5(element2.find(o2.sortTarget)[0]));
        element2.find(o2.sortTarget).remove();
        $5.each(items, function() {
          var $this = $5(this);
          $this.insertAfter(prev);
          prev = $this;
        });
        $5("#" + id).remove();
      },
      changeAttribute: function(attributeName) {
        var that = this, element2 = this.element, o2 = this.options;
        var changeSortDir = function() {
          var dir = element2.attr("data-sort-dir").trim();
          if (dir === "") return;
          o2.sortDir = dir;
          that.sort();
        };
        var changeSortContent = function() {
          var content = element2.attr("data-sort-content").trim();
          if (content === "") return;
          o2.sortContent = content;
          that.sort();
        };
        switch (attributeName) {
          case "data-sort-dir":
            changeSortDir();
            break;
          case "data-sort-content":
            changeSortContent();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2["sorter"] = {
      create: function(el, op) {
        return Utils.$()(el).sorter(op);
      },
      isSorter: function(el) {
        return Utils.isMetroObject(el, "sorter");
      },
      sort: function(el, dir) {
        if (!this.isSorter(el)) {
          return false;
        }
        if (dir === void 0) {
          dir = "asc";
        }
        Metro2.getPlugin(el, "sorter").sort(dir);
      },
      reset: function(el) {
        if (!this.isSorter(el)) {
          return false;
        }
        Metro2.getPlugin(el, "sorter").reset();
      }
    };
  })(Metro, Dom);

  // source/components/splitter/splitter.js
  (function(Metro2, $5) {
    "use strict";
    const SPLIT_MODE = {
      VERTICAL: "vertical",
      HORIZONTAL: "horizontal"
    };
    const Storage = Metro2.storage;
    let SplitterDefaultConfig = {
      splitterDeferred: 0,
      split: SPLIT_MODE.VERTICAL,
      // horizontal or vertical
      splitSizes: null,
      gutterSize: 5,
      gutterStyle: "default",
      // ribbed, dashed, dotted, default
      minSizes: null,
      children: "*",
      gutterClick: "expand",
      // TODO expand or collapse
      saveState: false,
      noResize: false,
      onResizeStart: Metro2.noop,
      onResizeStop: Metro2.noop,
      onResizeSplit: Metro2.noop,
      onResizeWindow: Metro2.noop,
      onSplitterCreate: Metro2.noop
    };
    Metro2.splitterSetup = function(options) {
      SplitterDefaultConfig = $5.extend({}, SplitterDefaultConfig, options);
    };
    if (typeof globalThis["metroSplitterSetup"] !== "undefined") {
      Metro2.splitterSetup(globalThis["metroSplitterSetup"]);
    }
    Metro2.Component("splitter", {
      init: function(options, elem) {
        this._super(elem, options, SplitterDefaultConfig, {
          storage: Metro2.utils.isValue(Storage) ? Storage : null,
          storageKey: "SPLITTER:",
          id: Metro2.utils.elementId("splitter")
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("splitter-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        const children = element2.children(o2.children).addClass("split-block");
        let i3, children_sizes = [];
        const resizeProp = o2.split === SPLIT_MODE.HORIZONTAL ? "height" : "width";
        element2.addClass("splitter");
        element2.addClass(o2.split.toLowerCase() === SPLIT_MODE.VERTICAL ? "vertical" : "horizontal");
        if (o2.gutterStyle !== "default") {
          element2.addClass(`gutter-style-${o2.gutterStyle}`);
        }
        if (o2.noResize === true) {
          element2.addClass("static-size");
        }
        for (i3 = 0; i3 < children.length - 1; i3++) {
          $5("<div>").addClass("gutter").css(resizeProp, o2.gutterSize).insertAfter($5(children[i3]));
        }
        this._setSize();
        if (Metro2.utils.isValue(o2.minSizes)) {
          if (("" + o2.minSizes).includes(",")) {
            children_sizes = o2.minSizes.toArray();
            for (i3 = 0; i3 < children_sizes.length; i3++) {
              $5(children[i3]).data("min-size", children_sizes[i3]);
              children[i3].style.setProperty("min-" + resizeProp, ("" + children_sizes[i3]).includes("%") ? children_sizes[i3] : ("" + children_sizes[i3]).replace("px", "") + "px", "important");
            }
          } else {
            $5.each(children, function() {
              this.style.setProperty("min-" + resizeProp, ("" + o2.minSizes).includes("%") ? o2.minSizes : ("" + o2.minSizes).replace("px", "") + "px", "important");
            });
          }
        }
        if (o2.saveState && this.storage !== null) {
          this._getSize();
        }
      },
      _setSize: function() {
        const element2 = this.element, o2 = this.options;
        let gutters, children_sizes;
        const children = element2.children(".split-block");
        const w5 = element2.width();
        gutters = element2.children(".gutter");
        if (!Metro2.utils.isValue(o2.splitSizes)) {
          children.css({
            flexBasis: `calc(${100 / children.length}% - ${gutters.length * o2.gutterSize}px)`
          });
        } else {
          children_sizes = ("" + o2.splitSizes).toArray();
          let remnant = 100;
          let i3 = 0;
          for (; i3 < children_sizes.length; i3++) {
            let s3 = children_sizes[i3];
            if (!s3.includes("%")) {
              s3 = +s3 * 100 / w5;
            } else {
              s3 = parseInt(s3);
            }
            remnant -= s3;
            $5(children[i3]).css({
              flexBasis: `calc(${s3}% - ${gutters.length * o2.gutterSize}px)`
            });
          }
          for (; i3 < children.length; i3++) {
            $5(children[i3]).css({
              flexBasis: `calc(${remnant / (children.length - i3)}% - ${gutters.length * o2.gutterSize}px)`
            });
          }
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const gutters = element2.children(".gutter");
        gutters.on(Metro2.events.startAll, function(e2) {
          if (o2.noResize === true) {
            return false;
          }
          const w5 = o2.split === SPLIT_MODE.VERTICAL ? element2.width() : element2.height();
          const gutter = $5(this);
          const prev_block = gutter.prev(".split-block");
          const next_block = gutter.next(".split-block");
          const prev_block_size = 100 * (o2.split === SPLIT_MODE.VERTICAL ? prev_block.outerWidth(true) : prev_block.outerHeight(true)) / w5;
          const next_block_size = 100 * (o2.split === SPLIT_MODE.VERTICAL ? next_block.outerWidth(true) : next_block.outerHeight(true)) / w5;
          const start_pos = Metro2.utils.getCursorPosition(element2[0], e2);
          gutter.addClass("active");
          prev_block.addClass("stop-pointer");
          next_block.addClass("stop-pointer");
          that._fireEvent("resize-start", {
            pos: start_pos,
            gutter: gutter[0],
            prevBlock: prev_block[0],
            nextBlock: next_block[0]
          });
          $5(globalThis).on(Metro2.events.moveAll, function(e3) {
            const pos = Metro2.utils.getCursorPosition(element2[0], e3);
            let new_pos;
            if (o2.split === SPLIT_MODE.VERTICAL) {
              new_pos = pos.x * 100 / w5 - start_pos.x * 100 / w5;
            } else {
              new_pos = pos.y * 100 / w5 - start_pos.y * 100 / w5;
            }
            prev_block.css("flex-basis", "calc(" + (prev_block_size + new_pos) + "% - " + gutters.length * o2.gutterSize + "px)");
            next_block.css("flex-basis", "calc(" + (next_block_size - new_pos) + "% - " + gutters.length * o2.gutterSize + "px)");
            that._fireEvent("resize-split", {
              pos,
              gutter: gutter[0],
              prevBlock: prev_block[0],
              nextBlock: next_block[0]
            });
          }, { ns: that.id });
          $5(globalThis).on(Metro2.events.stopAll, function(e3) {
            let cur_pos;
            prev_block.removeClass("stop-pointer");
            next_block.removeClass("stop-pointer");
            that._saveSize();
            gutter.removeClass("active");
            $5(globalThis).off(Metro2.events.moveAll, { ns: that.id });
            $5(globalThis).off(Metro2.events.stopAll, { ns: that.id });
            cur_pos = Metro2.utils.getCursorPosition(element2[0], e3);
            that._fireEvent("resize-stop", {
              pos: cur_pos,
              gutter: gutter[0],
              prevBlock: prev_block[0],
              nextBlock: next_block[0]
            });
          }, { ns: that.id });
        }, { passive: true });
        $5(globalThis).on(Metro2.events.resize, function() {
          const gutter = element2.children(".gutter");
          const prev_block = gutter.prev(".split-block");
          const next_block = gutter.next(".split-block");
          that._fireEvent("resize-window", {
            prevBlock: prev_block[0],
            nextBlock: next_block[0]
          });
        }, { ns: that.id });
      },
      _saveSize: function() {
        const element2 = this.element, o2 = this.options;
        const storage = this.storage, itemsSize = [];
        const id = element2.attr("id") || this.id;
        if (o2.saveState === true && storage !== null) {
          $5.each(element2.children(".split-block"), function() {
            const item = $5(this);
            itemsSize.push(item.css("flex-basis"));
          });
          if (storage)
            storage.setItem(this.storageKey + id, itemsSize);
        }
      },
      _getSize: function() {
        const element2 = this.element, o2 = this.options;
        let storage = this.storage, itemsSize = [];
        const id = element2.attr("id") || this.id;
        if (o2.saveState === true && storage !== null) {
          itemsSize = storage.getItem(this.storageKey + id);
          $5.each(element2.children(".split-block"), function(i3, v4) {
            const item = $5(v4);
            if (Metro2.utils.isValue(itemsSize) && Metro2.utils.isValue(itemsSize[i3])) item.css("flex-basis", itemsSize[i3]);
          });
        }
      },
      size: function(size) {
        const that = this, o2 = this.options;
        if (Metro2.utils.isValue(size)) {
          o2.splitSizes = size;
          that._setSize();
        }
        return this;
      },
      changeAttribute: function(attributeName) {
        const that = this, element2 = this.element;
        function changeSize() {
          const size = element2.attr("data-split-sizes");
          that.size(size);
        }
        if (attributeName === "data-split-sizes") {
          changeSize();
        }
      },
      destroy: function() {
        const element2 = this.element;
        const gutters = element2.children(".gutter");
        gutters.off(Metro2.events.start);
        return element2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/stepper/stepper.js
  (function(Metro2, $5) {
    "use strict";
    var StepperDefaultConfig = {
      stepperDeferred: 0,
      view: Metro2.stepperView.SQUARE,
      // square, cycle, diamond
      steps: 3,
      step: 1,
      stepClick: false,
      clsStepper: "",
      clsStep: "",
      clsComplete: "",
      clsCurrent: "",
      onStep: Metro2.noop,
      onStepClick: Metro2.noop,
      onStepperCreate: Metro2.noop
    };
    Metro2.stepperSetup = function(options) {
      StepperDefaultConfig = $5.extend({}, StepperDefaultConfig, options);
    };
    if (typeof globalThis["metroStepperSetup"] !== "undefined") {
      Metro2.stepperSetup(globalThis["metroStepperSetup"]);
    }
    Metro2.Component("stepper", {
      init: function(options, elem) {
        this._super(elem, options, StepperDefaultConfig, {
          current: 0
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        if (o2.step <= 0) {
          o2.step = 1;
        }
        this._createStepper();
        this._createEvents();
        this._fireEvent("stepper-create", {
          element: element2
        });
      },
      _createStepper: function() {
        var element2 = this.element, o2 = this.options;
        var i3;
        element2.addClass("stepper").addClass(o2.view).addClass(o2.clsStepper);
        for (i3 = 1; i3 <= o2.steps; i3++) {
          $5("<span>").addClass("step").addClass(o2.clsStep).data("step", i3).html("<span>" + i3 + "</span>").appendTo(element2);
        }
        this.current = 1;
        this.toStep(o2.step);
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.click, ".step", function() {
          var step = $5(this).data("step");
          if (o2.stepClick === true) {
            that.toStep(step);
            that._fireEvent("step-click", {
              step
            });
          }
        });
      },
      next: function() {
        var element2 = this.element;
        var steps = element2.find(".step");
        if (this.current + 1 > steps.length) {
          return;
        }
        this.current++;
        this.toStep(this.current);
      },
      prev: function() {
        if (this.current - 1 === 0) {
          return;
        }
        this.current--;
        this.toStep(this.current);
      },
      last: function() {
        var element2 = this.element;
        this.toStep(element2.find(".step").length);
      },
      first: function() {
        this.toStep(1);
      },
      toStep: function(step) {
        var element2 = this.element, o2 = this.options;
        var target = $5(element2.find(".step").get(step - 1));
        var prevStep = this.current;
        if (target.length === 0) {
          return;
        }
        this.current = step;
        element2.find(".step").removeClass("complete current").removeClass(o2.clsCurrent).removeClass(o2.clsComplete);
        target.addClass("current").addClass(o2.clsCurrent);
        target.prevAll().addClass("complete").addClass(o2.clsComplete);
        this._fireEvent("step", {
          step: this.current,
          prev: prevStep
        });
      },
      changeAttribute: function() {
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.click, ".step");
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/storage/storage.js
  (function(Metro2) {
    "use strict";
    const MetroStorage = function(type) {
      return new MetroStorage.init(type);
    };
    MetroStorage.prototype = {
      setKey: function(key) {
        this.key = key;
      },
      getKey: function() {
        return this.key;
      },
      setItem: function(key, value) {
        this.storage.setItem(this.key + ":" + key, JSON.stringify(value));
      },
      getItem: function(key, default_value, reviver) {
        let result, value;
        value = this.storage.getItem(this.key + ":" + key);
        try {
          result = JSON.parse(value, reviver);
        } catch (e2) {
          result = null;
        }
        return Metro2.utils.nvl(result, default_value);
      },
      getItemPart: function(key, sub_key, default_value, reviver) {
        let i3;
        let val = this.getItem(key, default_value, reviver);
        sub_key = sub_key.split("->");
        for (i3 = 0; i3 < sub_key.length; i3++) {
          val = val[sub_key[i3]];
        }
        return val;
      },
      delItem: function(key) {
        this.storage.removeItem(this.key + ":" + key);
      },
      size: function(unit) {
        let divider;
        switch (unit) {
          case "m":
          case "M": {
            divider = 1024 * 1024;
            break;
          }
          case "k":
          case "K": {
            divider = 1024;
            break;
          }
          default:
            divider = 1;
        }
        return JSON.stringify(this.storage).length / divider;
      }
    };
    MetroStorage.init = function(type) {
      this.key = "";
      this.storage = type ? type : globalThis.localStorage;
      return this;
    };
    MetroStorage.init.prototype = MetroStorage.prototype;
    Metro2.storage = MetroStorage(globalThis.localStorage);
    Metro2.session = MetroStorage(globalThis.sessionStorage);
  })(Metro);

  // source/components/streamer/streamer.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var StreamerDefaultConfig = {
      streamerDeferred: 0,
      wheel: true,
      wheelStep: 20,
      duration: METRO_ANIMATION_DURATION,
      defaultClosedIcon: "",
      defaultOpenIcon: "",
      changeUri: true,
      encodeLink: true,
      closed: false,
      chromeNotice: false,
      startFrom: null,
      slideToStart: true,
      startSlideSleep: 1e3,
      source: null,
      data: null,
      eventClick: "select",
      selectGlobal: true,
      streamSelect: false,
      excludeSelectElement: null,
      excludeClickElement: null,
      excludeElement: null,
      excludeSelectClass: "",
      excludeClickClass: "",
      excludeClass: "",
      onDataLoad: Metro2.noop,
      onDataLoaded: Metro2.noop,
      onDataLoadError: Metro2.noop,
      onDrawEvent: Metro2.noop,
      onDrawGlobalEvent: Metro2.noop,
      onDrawStream: Metro2.noop,
      onStreamClick: Metro2.noop,
      onStreamSelect: Metro2.noop,
      onEventClick: Metro2.noop,
      onEventSelect: Metro2.noop,
      onEventsScroll: Metro2.noop,
      onStreamerCreate: Metro2.noop
    };
    Metro2.streamerSetup = function(options) {
      StreamerDefaultConfig = $5.extend({}, StreamerDefaultConfig, options);
    };
    if (typeof globalThis["metroStreamerSetup"] !== "undefined") {
      Metro2.streamerSetup(globalThis["metroStreamerSetup"]);
    }
    Metro2.Component("streamer", {
      init: function(options, elem) {
        this._super(elem, options, StreamerDefaultConfig, {
          data: null,
          scroll: 0,
          scrollDir: "left",
          events: null
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        element2.addClass("streamer");
        if (element2.attr("id") === void 0) {
          element2.attr("id", Utils.elementId("streamer"));
        }
        if (o2.source === null && o2.data === null) {
          return false;
        }
        $5("<div>").addClass("streams").appendTo(element2);
        $5("<div>").addClass("events-area").appendTo(element2);
        if (o2.source !== null) {
          this._fireEvent("data-load", {
            source: o2.source
          });
          this._loadSource();
        } else {
          this.data = o2.data;
          this.build();
        }
      },
      _loadSource: function() {
        var that = this, o2 = this.options;
        fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then(function(data) {
          that._fireEvent("data-loaded", {
            source: o2.source,
            data
          });
          that.data = data;
          that.build();
        }).catch(function(error) {
          that._fireEvent("data-load-error", {
            source: o2.source,
            error
          });
        });
      },
      build: function() {
        var that = this, element2 = this.element, o2 = this.options, data = this.data;
        var streams = element2.find(".streams").html("");
        var events_area = element2.find(".events-area").html("");
        var fake_timeline;
        var timeline = $5("<ul>").addClass("streamer-timeline").html("").appendTo(events_area);
        var streamer_events = $5("<div>").addClass("streamer-events").appendTo(events_area);
        var event_group_main = $5("<div>").addClass("event-group").appendTo(streamer_events);
        var StreamerIDS = Utils.getURIParameter(null, "StreamerIDS");
        if (StreamerIDS !== null && o2.encodeLink === true) {
          StreamerIDS = atob(StreamerIDS);
        }
        var StreamerIDS_i = StreamerIDS ? StreamerIDS.split("|")[0] : null;
        var StreamerIDS_a = StreamerIDS ? StreamerIDS.split("|")[1].split(",") : [];
        if (data.actions !== void 0) {
          var actions = $5("<div>").addClass("streamer-actions").appendTo(streams);
          $5.each(data.actions, function() {
            var item = this;
            var button = $5("<button>").addClass("streamer-action").addClass(item.cls).html(item.html);
            if (item.onclick) button.on(Metro2.events.click, function() {
              Utils.exec(item.onclick, [element2]);
            });
            button.appendTo(actions);
          });
        }
        timeline.html("");
        if (data.timeline === void 0) {
          data.timeline = {
            start: "09:00",
            stop: "18:00",
            step: 20
          };
        }
        var start = /* @__PURE__ */ new Date(), stop = /* @__PURE__ */ new Date();
        var start_time_array = data.timeline.start ? data.timeline.start.split(":") : [9, 0];
        var stop_time_array = data.timeline.stop ? data.timeline.stop.split(":") : [18, 0];
        var step = data.timeline.step ? parseInt(data.timeline.step) * 60 : 1200;
        start.setHours(start_time_array[0]);
        start.setMinutes(start_time_array[1]);
        start.setSeconds(0);
        stop.setHours(stop_time_array[0]);
        stop.setMinutes(stop_time_array[1]);
        stop.setSeconds(0);
        var i3, t, h3, v4, m4, j4, fm, li, fli, fli_w;
        for (i3 = start.getTime() / 1e3; i3 <= stop.getTime() / 1e3; i3 += step) {
          t = new Date(i3 * 1e3);
          h3 = t.getHours();
          m4 = t.getMinutes();
          v4 = Str.lpad(h3, "0", 2) + ":" + Str.lpad(m4, "0", 2);
          li = $5("<li>").data("time", v4).addClass("js-time-point-" + v4.replace(":", "-")).html("<em>" + v4 + "</em>").appendTo(timeline);
          fli_w = li.width() / parseInt(data.timeline.step);
          fake_timeline = $5("<ul>").addClass("streamer-fake-timeline").html("").appendTo(li);
          for (j4 = 0; j4 < parseInt(data.timeline.step); j4++) {
            fm = m4 + j4;
            v4 = Str.lpad(h3, "0", 2) + ":" + Str.lpad(fm, "0", 2);
            fli = $5("<li>").data("time", v4).addClass("js-fake-time-point-" + v4.replace(":", "-")).html("|").appendTo(fake_timeline);
            fli.css({
              width: fli_w
            });
          }
        }
        if (data.streams !== void 0) {
          $5.each(data.streams, function(stream_index) {
            var stream_height = 75, rows = 0;
            var stream_item = this;
            var stream = $5("<div>").addClass("stream").addClass(this.cls).appendTo(streams);
            stream.addClass(stream_item.cls).data("one", false).data("data", stream_item.data);
            $5("<div>").addClass("stream-title").html(stream_item.title).appendTo(stream);
            $5("<div>").addClass("stream-secondary").html(stream_item.secondary).appendTo(stream);
            $5(stream_item.icon).addClass("stream-icon").appendTo(stream);
            var bg = Farbe.Routines.toHEX(Utils.getStyleOne(stream, "background-color"));
            var fg = Farbe.Routines.toHEX(Utils.getStyleOne(stream, "color"));
            var stream_events = $5("<div>").addClass("stream-events").data("background-color", bg).data("text-color", fg).appendTo(event_group_main);
            if (stream_item.events !== void 0) {
              $5.each(stream_item.events, function(event_index) {
                var event_item = this;
                var row = event_item.row === void 0 ? 1 : parseInt(event_item.row);
                var _icon;
                var sid = stream_index + ":" + event_index;
                var custom_html = event_item.custom !== void 0 ? event_item.custom : "";
                var custom_html_open = event_item.custom_open !== void 0 ? event_item.custom_open : "";
                var custom_html_close = event_item.custom_close !== void 0 ? event_item.custom_close : "";
                var event;
                if (event_item.skip !== void 0 && Utils.bool(event_item.skip)) {
                  return;
                }
                event = $5("<div>").data("origin", event_item).data("sid", sid).data("data", event_item.data).data("time", event_item.time).data("target", event_item.target).addClass("stream-event").addClass("size-" + event_item.size + (["half", "one-third"].includes(event_item.size) ? "" : "x")).addClass(event_item.cls).appendTo(stream_events);
                var time_point = timeline.find(".js-fake-time-point-" + this.time.replace(":", "-"));
                var left = time_point.offset().left - stream_events.offset().left;
                var top = 75 * (row - 1);
                if (row > rows) {
                  rows = row;
                }
                event.css({
                  position: "absolute",
                  left,
                  top
                });
                if (Utils.isNull(event_item.html)) {
                  var slide = $5("<div>").addClass("stream-event-slide").appendTo(event);
                  var slide_logo = $5("<div>").addClass("slide-logo").appendTo(slide);
                  var slide_data = $5("<div>").addClass("slide-data").appendTo(slide);
                  if (event_item.icon !== void 0) {
                    if (Utils.isTag(event_item.icon)) {
                      $5(event_item.icon).addClass("icon").appendTo(slide_logo);
                    } else {
                      $5("<img>").addClass("icon").attr("src", event_item.icon).attr("alt", "").appendTo(slide_logo);
                    }
                  }
                  $5("<span>").addClass("time").css({
                    backgroundColor: bg,
                    color: fg
                  }).html(event_item.time).appendTo(slide_logo);
                  $5("<div>").addClass("title").html(event_item.title).appendTo(slide_data);
                  $5("<div>").addClass("subtitle").html(event_item.subtitle).appendTo(slide_data);
                  $5("<div>").addClass("desc").html(event_item.desc).appendTo(slide_data);
                  if (o2.closed === false && (element2.attr("id") === StreamerIDS_i && StreamerIDS_a.indexOf(sid) !== -1) || event_item.selected === true || parseInt(event_item.selected) === 1) {
                    event.addClass("selected");
                  }
                  if (o2.closed === true || event_item.closed === true || parseInt(event_item.closed) === 1) {
                    _icon = event_item.closedIcon !== void 0 ? Utils.isTag(event_item.closedIcon) ? event_item.closedIcon : "<span>" + event_item.closedIcon + "</span>" : Utils.isTag(o2.defaultClosedIcon) ? o2.defaultClosedIcon : "<span>" + o2.defaultClosedIcon + "</span>";
                    $5(_icon).addClass("state-icon").addClass(event_item.clsClosedIcon).appendTo(slide);
                    event.data("closed", true).data("target", event_item.target);
                    event.append(custom_html_open);
                  } else {
                    _icon = event_item.openIcon !== void 0 ? Utils.isTag(event_item.openIcon) ? event_item.openIcon : "<span>" + event_item.openIcon + "</span>" : Utils.isTag(o2.defaultOpenIcon) ? o2.defaultOpenIcon : "<span>" + o2.defaultOpenIcon + "</span>";
                    $5(_icon).addClass("state-icon").addClass(event_item.clsOpenIcon).appendTo(slide);
                    event.data("closed", false);
                    event.append(custom_html_close);
                  }
                  event.append(custom_html);
                } else {
                  event.html(event_item.html);
                }
                that._fireEvent("draw-event", {
                  event: event[0]
                });
              });
              var last_child = stream_events.find(".stream-event").last();
              if (last_child.length > 0) stream_events.outerWidth(last_child[0].offsetLeft + last_child.outerWidth());
            }
            stream_events.css({
              height: stream_height * rows
            });
            element2.find(".stream").eq(stream_events.index()).css({
              height: stream_height * rows
            });
            that._fireEvent("draw-stream", {
              stream: stream[0]
            });
          });
        }
        if (data.global !== void 0) {
          var streamer_events_left = streamer_events.offset().left;
          $5.each(["before", "after"], function() {
            var global_item = this;
            if (data.global[global_item] !== void 0) {
              $5.each(data.global[global_item], function() {
                var event_item = this;
                var group = $5("<div>").addClass("event-group").addClass("size-" + event_item.size + (["half", "one-third"].includes(event_item.size) ? "" : "x"));
                var events = $5("<div>").addClass("stream-events global-stream").appendTo(group);
                var event = $5("<div>").addClass("stream-event").appendTo(events);
                event.addClass("global-event").addClass(event_item.cls).data("time", event_item.time).data("origin", event_item).data("data", event_item.data);
                $5("<div>").addClass("event-title").html(event_item.title).appendTo(event);
                $5("<div>").addClass("event-subtitle").html(event_item.subtitle).appendTo(event);
                $5("<div>").addClass("event-html").html(event_item.html).appendTo(event);
                var left, t2 = timeline.find(".js-fake-time-point-" + this.time.replace(":", "-"));
                if (t2.length > 0) {
                  left = t2.offset().left - streamer_events_left;
                }
                group.css({
                  position: "absolute",
                  left,
                  height: "100%"
                }).appendTo(streamer_events);
                that._fireEvent("draw-global-event", {
                  event: event[0]
                });
              });
            }
          });
        }
        element2.data("stream", -1);
        element2.find(".events-area").scrollLeft(0);
        this.events = element2.find(".stream-event");
        this._createEvents();
        if (o2.startFrom !== null && o2.slideToStart === true) {
          setTimeout(function() {
            that.slideTo(o2.startFrom);
          }, o2.startSlideSleep);
        }
        this._fireEvent("streamer-create");
        this._fireScroll();
      },
      _fireScroll: function() {
        var that = this, element2 = this.element;
        var scrollable = element2.find(".events-area");
        var oldScroll = this.scroll;
        if (scrollable.length === 0) {
          return void 0;
        }
        this.scrollDir = this.scroll < scrollable[0].scrollLeft ? "left" : "right";
        this.scroll = scrollable[0].scrollLeft;
        this._fireEvent("events-scroll", {
          scrollLeft: scrollable[0].scrollLeft,
          oldScroll,
          scrollDir: that.scrollDir,
          events: $5.toArray(this.events)
        });
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        function disableScroll() {
          var scrollTop = globalThis.pageYOffset || document.documentElement.scrollTop;
          var scrollLeft = globalThis.pageXOffset || document.documentElement.scrollLeft;
          globalThis.onscroll = function() {
            globalThis.scrollTo(scrollLeft, scrollTop);
          };
        }
        function enableScroll() {
          globalThis.onscroll = function() {
          };
        }
        element2.off(Metro2.events.click, ".stream-event").on(Metro2.events.click, ".stream-event", function(e2) {
          var event = $5(this);
          if (o2.excludeClass !== "" && event.hasClass(o2.excludeClass)) {
            return;
          }
          if (o2.excludeElement !== null && $5(e2.target).is(o2.excludeElement)) {
            return;
          }
          if (o2.closed === false && event.data("closed") !== true && o2.eventClick === "select") {
            if (o2.excludeSelectClass !== "" && event.hasClass(o2.excludeSelectClass)) {
            } else {
              if (o2.excludeSelectElement !== null && $5(e2.target).is(o2.excludeSelectElement)) {
              } else {
                if (event.hasClass("global-event")) {
                  if (o2.selectGlobal === true) {
                    event.toggleClass("selected");
                  }
                } else {
                  event.toggleClass("selected");
                }
                if (o2.changeUri === true) {
                  that._changeURI();
                }
                that._fireEvent("event-select", {
                  event: event[0],
                  selected: event.hasClass("selected")
                });
              }
            }
          } else {
            if (o2.excludeClickClass !== "" && event.hasClass(o2.excludeClickClass)) {
            } else {
              if (o2.excludeClickElement !== null && $5(e2.target).is(o2.excludeClickElement)) {
              } else {
                that._fireEvent("event-click", {
                  event: event[0]
                });
                if (o2.closed === true || event.data("closed") === true) {
                  var target = event.data("target");
                  if (target) {
                    globalThis.location.href = target;
                  }
                }
              }
            }
          }
        });
        element2.off(Metro2.events.click, ".stream").on(Metro2.events.click, ".stream", function() {
          var stream = $5(this);
          var index = stream.index();
          if (o2.streamSelect === false) {
            return;
          }
          if (element2.data("stream") === index) {
            element2.find(".stream-event").removeClass("disabled");
            element2.data("stream", -1);
          } else {
            element2.data("stream", index);
            element2.find(".stream-event").addClass("disabled");
            that.enableStream(stream);
            that._fireEvent("stream-select", {
              stream
            });
          }
          that._fireEvent("stream-click", {
            stream
          });
        });
        if (o2.wheel === true) {
          element2.find(".events-area").off(Metro2.events.mousewheel).on(Metro2.events.mousewheel, function(e2) {
            if (e2.deltaY === void 0) {
              return;
            }
            var scroll, scrollable = $5(this);
            var dir = e2.deltaY > 0 ? -1 : 1;
            var step = o2.wheelStep;
            scroll = scrollable.scrollLeft() - dir * step;
            scrollable.scrollLeft(scroll);
          }, {
            passive: true
          });
          element2.find(".events-area").off("mouseenter").on("mouseenter", function() {
            disableScroll();
          });
          element2.find(".events-area").off("mouseleave").on("mouseleave", function() {
            enableScroll();
          });
        }
        element2.find(".events-area").last().off("scroll").on("scroll", function() {
          that._fireScroll();
        });
        if ($5.touchable === true) {
          element2.off(Metro2.events.click, ".stream").on(Metro2.events.click, ".stream", function() {
            var stream = $5(this);
            stream.toggleClass("focused");
            $5.each(element2.find(".stream"), function() {
              if ($5(this).is(stream)) return;
              $5(this).removeClass("focused");
            });
          });
        }
      },
      _changeURI: function() {
        var link = this.getLink();
        history.pushState({}, document.title, link);
      },
      slideTo: function(time) {
        var element2 = this.element, o2 = this.options;
        var target;
        if (time === void 0) {
          target = $5(element2.find(".streamer-timeline li")[0]);
        } else {
          target = $5(element2.find(".streamer-timeline .js-time-point-" + time.replace(":", "-"))[0]);
        }
        element2.find(".events-area").animate({
          draw: {
            scrollLeft: target[0].offsetLeft - element2.find(".streams .stream").outerWidth()
          },
          dur: o2.duration
        });
      },
      enableStream: function(stream) {
        var element2 = this.element;
        var index = stream.index() - 1;
        stream.removeClass("disabled").data("streamDisabled", false);
        element2.find(".stream-events").eq(index).find(".stream-event").removeClass("disabled");
      },
      disableStream: function(stream) {
        var element2 = this.element;
        var index = stream.index() - 1;
        stream.addClass("disabled").data("streamDisabled", true);
        element2.find(".stream-events").eq(index).find(".stream-event").addClass("disabled");
      },
      toggleStream: function(stream) {
        if (stream.data("streamDisabled") === true) {
          this.enableStream(stream);
        } else {
          this.disableStream(stream);
        }
      },
      getLink: function() {
        var element2 = this.element, o2 = this.options;
        var events = element2.find(".stream-event");
        var a3 = [];
        var link;
        var origin = globalThis.location.href;
        $5.each(events, function() {
          var event = $5(this);
          if (event.data("sid") === void 0 || !event.hasClass("selected")) {
            return;
          }
          a3.push(event.data("sid"));
        });
        link = element2.attr("id") + "|" + a3.join(",");
        if (o2.encodeLink === true) {
          link = btoa(link);
        }
        return Utils.updateURIParameter(origin, "StreamerIDS", link);
      },
      getTimes: function() {
        var element2 = this.element;
        var times = element2.find(".streamer-timeline > li");
        var result = [];
        $5.each(times, function() {
          result.push($5(this).data("time"));
        });
        return result;
      },
      getEvents: function(event_type, include_global) {
        var element2 = this.element;
        var items, events = [];
        switch (event_type) {
          case "selected":
            items = element2.find(".stream-event.selected");
            break;
          case "non-selected":
            items = element2.find(".stream-event:not(.selected)");
            break;
          default:
            items = element2.find(".stream-event");
        }
        $5.each(items, function() {
          var item = $5(this);
          var origin;
          if (include_global !== true && item.parent().hasClass("global-stream")) return;
          origin = item.data("origin");
          events.push(origin);
        });
        return events;
      },
      source: function(s3) {
        var element2 = this.element;
        if (s3 === void 0) {
          return this.options.source;
        }
        element2.attr("data-source", s3);
        this.options.source = s3;
        this.changeSource();
      },
      dataSet: function(s3) {
        if (s3 === void 0) {
          return this.options.data;
        }
        this.options.data = s3;
        this.changeData(s3);
      },
      getStreamerData: function() {
        return this.data;
      },
      toggleEvent: function(event) {
        var o2 = this.options;
        event = $5(event);
        if (event.hasClass("global-event") && o2.selectGlobal !== true) {
          return;
        }
        if (event.hasClass("selected")) {
          this.selectEvent(event, false);
        } else {
          this.selectEvent(event, true);
        }
      },
      selectEvent: function(event, state2) {
        var that = this, o2 = this.options;
        if (state2 === void 0) {
          state2 = true;
        }
        event = $5(event);
        if (event.hasClass("global-event") && o2.selectGlobal !== true) {
          return;
        }
        if (state2 === true) event.addClass("selected");
        else event.removeClass("selected");
        if (o2.changeUri === true) {
          that._changeURI();
        }
        this._fireEvent("event-select", {
          event: event[0],
          selected: state2
        });
      },
      changeSource: function() {
        var element2 = this.element, o2 = this.options;
        var new_source = element2.attr("data-source");
        if (String(new_source).trim() === "") {
          return;
        }
        o2.source = new_source;
        this._fireEvent("data-load", {
          source: o2.source
        });
        this._loadSource();
        this._fireEvent("source-change");
      },
      changeData: function(data) {
        var element2 = this.element, o2 = this.options;
        var old_data = this.data;
        o2.data = typeof data === "object" ? data : JSON.parse(element2.attr("data-data"));
        this.data = o2.data;
        this.build();
        this._fireEvent("data-change", {
          oldData: old_data,
          newData: o2.data
        });
      },
      changeStreamSelectOption: function() {
        var element2 = this.element, o2 = this.options;
        o2.streamSelect = element2.attr("data-stream-select").toLowerCase() === "true";
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-source":
            this.changeSource();
            break;
          case "data-data":
            this.changeData();
            break;
          case "data-stream-select":
            this.changeStreamSelectOption();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.click, ".stream-event");
        element2.off(Metro2.events.click, ".stream");
        element2.find(".events-area").off(Metro2.events.mousewheel);
        element2.find(".events-area").last().off("scroll");
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/swipe/swipe.js
  (function(Metro2, $5) {
    "use strict";
    let SwipeDefaultConfig = {
      swipeThreshold: 32,
      onSwipe: Metro2.noop,
      onSwipeRight: Metro2.noop,
      onSwipeLeft: Metro2.noop,
      onSwipeUp: Metro2.noop,
      onSwipeDown: Metro2.noop,
      onSwipeCreate: Metro2.noop
    };
    Metro2.swipeSetup = function(options) {
      SwipeDefaultConfig = $5.extend({}, SwipeDefaultConfig, options);
    };
    if (typeof globalThis["metroSwipeSetup"] !== "undefined") {
      Metro2.swipeSetup(globalThis["metroSwipeSetup"]);
    }
    Metro2.Component("swipe", {
      init: function(options, elem) {
        this._super(elem, options, SwipeDefaultConfig, {});
        return this;
      },
      _create: function() {
        this.element.css({
          userSelect: "none"
        });
        this._createEvents();
        this._fireEvent("swipe-create");
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.on("touchstart mousedown", function(e2) {
          let start = Metro2.utils.pageXY(e2);
          let swipe = {
            x: 0,
            y: 0
          };
          element2.on("touchmove mousemove", function(e3) {
            let changes = Metro2.utils.pageXY(e3);
            swipe.x = changes.x - start.x;
            swipe.y = changes.y - start.y;
          });
          element2.on("touchend mouseup", function(e3) {
            let direction = "";
            if (Math.abs(swipe.x) > o2.swipeThreshold || Math.abs(swipe.y) > o2.swipeThreshold) {
              if (Math.abs(swipe.x) > Math.abs(swipe.y)) {
                if (swipe.x > 0) {
                  direction = "right";
                  that._fireEvent("swipe-right", {
                    start,
                    swipe
                  });
                } else {
                  direction = "left";
                  that._fireEvent("swipe-left", {
                    start,
                    swipe
                  });
                }
              } else {
                if (swipe.y > 0) {
                  direction = "down";
                  that._fireEvent("swipe-down", {
                    start,
                    swipe
                  });
                } else {
                  direction = "up";
                  that._fireEvent("swipe-up", {
                    start,
                    swipe
                  });
                }
              }
              that._fireEvent("swipe", {
                start,
                swipe,
                direction
              });
            }
            element2.off("touchmove mousemove");
            element2.off("touchend mouseup");
          });
        });
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/switch/switch.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var SwitchDefaultConfig = {
      switchDeferred: 0,
      material: false,
      prepend: "",
      append: "",
      clsSwitch: "",
      clsCheck: "",
      clsCaption: "",
      onoff: false,
      on: "",
      off: "",
      showOnOff: false,
      onSwitchCreate: Metro2.noop
    };
    Metro2.switchSetup = function(options) {
      SwitchDefaultConfig = $5.extend({}, SwitchDefaultConfig, options);
    };
    if (typeof globalThis["metroSwitchSetup"] !== "undefined") {
      Metro2.switchSetup(globalThis["metroSwitchSetup"]);
    }
    Metro2.Component("switch", {
      init: function(options, elem) {
        this._super(elem, options, SwitchDefaultConfig, {});
        return this;
      },
      _create: function() {
        const element2 = this.element, o2 = this.options;
        const strings = this.strings;
        const container = element2.wrap("<label>").addClass("switch").addClass(element2[0].className).addClass(o2.clsSwitch);
        element2.attr("type", "checkbox");
        if (element2.attr("readonly")) {
          element2.on("click", function(e2) {
            e2.preventDefault();
          });
        }
        this.component = container;
        element2[0].className = "";
        if (o2.prepend) {
          container.prepend($5("<span>").addClass("caption-prepend").addClass(o2.clsPrepend).addClass(o2.clsCaption).html(o2.prepend));
        }
        if (o2.append) {
          container.append($5("<span>").addClass("caption-append").addClass(o2.clsAppend).addClass(o2.clsCaption).html(o2.append));
        }
        if (o2.onoff === true) {
          element2.attr("data-on", o2.on || strings.label_on);
          element2.attr("data-off", o2.off || strings.label_off);
        } else {
          element2.removeAttr("data-on");
          element2.removeAttr("data-off");
        }
        if (o2.material === true) {
          container.addClass("material");
        }
        this._fireEvent("switch-create");
      },
      toggle: function(v4) {
        const element2 = this.element;
        if (element2.is(":disabled")) return this;
        if (!Utils.isValue(v4)) {
          element2.prop("checked", !Utils.bool(element2.prop("checked")));
        } else {
          element2.prop("checked", v4 === 1);
        }
        return this;
      },
      changeAttribute: function(attr, newVal) {
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/typer/typer.js
  (function(Metro2, $5) {
    "use strict";
    var TyperDefaultConfig = {
      splitter: ",",
      variance: 0,
      delay: 100,
      blinkDelay: 400,
      deleteDelay: 800,
      loop: true,
      cursor: "_",
      colors: "",
      onType: Metro2.noop,
      onTyperCreate: Metro2.noop
    };
    Metro2.typerSetup = function(options) {
      TyperDefaultConfig = $5.extend({}, TyperDefaultConfig, options);
    };
    if (typeof globalThis["metroTyperSetup"] !== "undefined") {
      Metro2.typerSetup(globalThis["metroTyperSetup"]);
    }
    Metro2.Component("typer", {
      init: function(options, elem) {
        this._super(elem, options, TyperDefaultConfig, {
          // define instance vars here
          original: null,
          lines: null,
          text: null,
          cursor: null,
          on: true,
          interval: null,
          colors: null,
          colorIndex: 0
        });
        return this;
      },
      _create: function() {
        const element2 = this.element, o2 = this.options;
        element2.addClass("typer");
        this.original = element2.text();
        this.words = this.original.split(o2.splitter).pack();
        this.colors = o2.colors.split(",").pack();
        this.cursor = $5("<span>").addClass("typer-cursor").html(o2.cursor).insertAfter(element2);
        this.interval = setInterval(() => this._blink(), +o2.blinkDelay);
        this.progress = { word: 0, char: 0, building: true, looped: 0 };
        element2.clear();
        this.start();
      },
      _blink: function() {
        if (this.on) {
          this.cursor[0].style.opacity = 0;
          this.on = false;
        } else {
          this.cursor[0].style.opacity = 1;
          this.on = true;
        }
      },
      doTyping: function() {
        const that = this, element2 = this.element, elem = this.elem, o2 = this.options;
        let atWordEnd;
        const p3 = this.progress;
        const w5 = p3.word;
        const c3 = p3.char;
        const curr = [...this.words[w5]].slice(0, c3).join("");
        const timeout = (2 * Math.random() - 1) * o2.variance + o2.delay;
        {
          this.cursor[0].style.opacity = "1";
          this.on = true;
          clearInterval(this.interval);
          this.interval = setInterval(() => this._blink(), +o2.blinkDelay);
        }
        element2.html(curr);
        if (p3.building) {
          atWordEnd = p3.char === this.words[w5].length;
          if (atWordEnd) {
            p3.building = false;
          } else {
            p3.char += 1;
          }
        } else {
          if (p3.char === 0) {
            p3.building = true;
            p3.word = (p3.word + 1) % this.words.length;
            if (this.colors.length) {
              this.colorIndex = (this.colorIndex + 1) % this.colors.length;
              elem.style.color = this.colors[this.colorIndex];
            }
          } else {
            p3.char -= 1;
          }
        }
        if (p3.word === this.words.length - 1) {
          p3.looped += 1;
        }
        if (!p3.building && this.loop <= p3.looped) {
          this.typing = false;
        }
        setTimeout(() => {
          if (this.typing) {
            this.doTyping();
          }
        }, atWordEnd ? o2.deleteDelay : timeout);
      },
      start: function() {
        if (!this.typing) {
          this.typing = true;
          this.doTyping();
        }
      },
      stop: function() {
        this.typing = false;
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/table/table.js
  var TABLE_COL_OPTIONS = {
    title: void 0,
    format: void 0,
    formatMask: void 0,
    name: void 0,
    colspan: null,
    size: void 0,
    sortable: false,
    sortDir: void 0,
    clsColumn: void 0,
    cls: void 0,
    show: true,
    required: true,
    field: void 0,
    fieldType: void 0,
    validator: void 0,
    template: void 0,
    type: "data"
  };
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var TableDefaultConfig = {
      caption: "",
      cardMode: "",
      useCurrentSlice: false,
      showInspectorButton: false,
      inspectorButtonIcon: "\u{1F527}",
      tableDeferred: 0,
      templateBeginToken: "<%",
      templateEndToken: "%>",
      paginationDistance: 5,
      paginationIslandSize: 3,
      paginationShortTrack: 10,
      horizontalScroll: false,
      horizontalScrollStop: null,
      check: false,
      checkType: "checkbox",
      checkColIndex: 0,
      checkName: null,
      checkStoreKey: "TABLE:$1:KEYS",
      rownum: false,
      rownumTitle: "#",
      filters: null,
      filtersOperator: "and",
      head: null,
      body: null,
      source: null,
      static: false,
      searchMinLength: 1,
      searchThreshold: 500,
      searchFields: null,
      showRowsSteps: true,
      showSearch: true,
      showTableInfo: true,
      showPagination: true,
      paginationShortMode: true,
      showActivity: true,
      muteTable: true,
      showSkip: false,
      rows: 10,
      rowsSteps: "10,25,50,100",
      staticView: false,
      viewSaveMode: "client",
      viewSavePath: "TABLE:$1:OPTIONS",
      sortDir: "asc",
      decimalSeparator: ".",
      thousandSeparator: ",",
      tableRowsCountTitle: null,
      tableSearchTitle: null,
      tableSearchPlaceholder: "",
      tableInfoTitle: null,
      paginationPrevTitle: null,
      paginationNextTitle: null,
      allRecordsTitle: null,
      inspectorTitle: null,
      tableSkipTitle: null,
      emptyTableTitle: null,
      activityType: "atom",
      activityStyle: "color",
      activityTimeout: 100,
      searchWrapper: null,
      rowsWrapper: null,
      infoWrapper: null,
      paginationWrapper: null,
      skipWrapper: null,
      cellWrapper: true,
      clsComponent: "",
      clsTableContainer: "",
      clsTable: "",
      clsHead: "",
      clsHeadRow: "",
      clsHeadCell: "",
      clsBody: "",
      clsBodyRow: "",
      clsBodyCell: "",
      clsCellWrapper: "",
      clsFooter: "",
      clsFooterRow: "",
      clsFooterCell: "",
      clsTableTop: "",
      clsRowsCount: "",
      clsSearch: "",
      clsTableBottom: "",
      clsTableInfo: "",
      clsTablePagination: "",
      clsPagination: "",
      clsTableSkip: "",
      clsTableSkipInput: "",
      clsTableSkipButton: "",
      clsEvenRow: "",
      clsOddRow: "",
      clsRow: "",
      clsEmptyTableTitle: "",
      onDraw: Metro2.noop,
      onDrawRow: Metro2.noop,
      onDrawCell: Metro2.noop,
      onAppendRow: Metro2.noop,
      onAppendCell: Metro2.noop,
      onSortStart: Metro2.noop,
      onSortStop: Metro2.noop,
      onSortItemSwitch: Metro2.noop,
      onSearch: Metro2.noop,
      onRowsCountChange: Metro2.noop,
      onDataLoad: Metro2.noop,
      onDataLoadError: Metro2.noop,
      onDataLoaded: Metro2.noop,
      onDataLoadEnd: Metro2.noop,
      onDataSaveError: Metro2.noop,
      onFilterRowAccepted: Metro2.noop,
      onFilterRowDeclined: Metro2.noop,
      onCheckClick: Metro2.noop,
      onCheckClickAll: Metro2.noop,
      onCheckDraw: Metro2.noop,
      onViewSave: Metro2.noop,
      onViewGet: Metro2.noop,
      onViewCreated: Metro2.noop,
      onTableCreate: Metro2.noop,
      onSkip: Metro2.noop
    };
    Metro2.tableSetup = function(options) {
      TableDefaultConfig = $5.extend({}, TableDefaultConfig, options);
    };
    if (typeof globalThis["metroTableSetup"] !== "undefined") {
      Metro2.tableSetup(globalThis["metroTableSetup"]);
    }
    Metro2.Component("table", {
      init: function(options, elem) {
        this._super(elem, options, TableDefaultConfig, {
          currentPage: 1,
          pagesCount: 1,
          searchString: "",
          data: null,
          activity: null,
          loadActivity: null,
          busy: false,
          filters: [],
          wrapperInfo: null,
          wrapperSearch: null,
          wrapperRows: null,
          wrapperPagination: null,
          wrapperSkip: null,
          filterIndex: null,
          filtersIndexes: [],
          component: null,
          inspector: null,
          view: {},
          viewDefault: {},
          input_interval: null,
          searchFields: [],
          id: Utils.elementId("table"),
          sort: {
            dir: "asc",
            colIndex: 0
          },
          service: [],
          heads: [],
          items: [],
          foots: [],
          filteredItems: [],
          currentSlice: [],
          index: {}
        });
        return this;
      },
      _create: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var id = Utils.elementId("table");
        var table_component, table_container, activity;
        if (!element2.id()) {
          console.warn(`To use all table component features, please set an ID for the table element!`);
          element2.id(id);
        }
        if (Utils.isValue(o2.searchFields)) {
          this.searchFields = o2.searchFields.toArray();
        }
        if (Utils.isValue(o2.head)) {
          var _head = o2.head;
          o2.head = Utils.isObject(o2.head);
          if (!o2.head) {
            console.warn("Head " + _head + " defined but not exists!");
            o2.head = null;
          }
        }
        if (Utils.isValue(o2.body)) {
          var _body = o2.body;
          o2.body = Utils.isObject(o2.body);
          if (!o2.body) {
            console.warn("Body " + _body + " defined but not exists!");
            o2.body = null;
          }
        }
        if (o2.static === true) {
          o2.showPagination = false;
          o2.showRowsSteps = false;
          o2.showSearch = false;
          o2.showTableInfo = false;
          o2.showSkip = false;
          o2.rows = -1;
        }
        table_component = $5("<div>").addClass("table-component");
        table_component.insertBefore(element2);
        table_container = $5("<div>").addClass("table-container").addClass(o2.clsTableContainer).appendTo(table_component);
        element2.appendTo(table_container);
        if (o2.horizontalScroll === true) {
          table_container.addClass("horizontal-scroll");
        }
        if (!Utils.isNull(o2.horizontalScrollStop) && Utils.mediaExist(o2.horizontalScrollStop)) {
          table_container.removeClass("horizontal-scroll");
        }
        table_component.addClass(o2.clsComponent);
        this.activity = $5("<div>").addClass("table-progress").appendTo(table_component);
        activity = $5("<div>").appendTo(this.activity);
        Metro2.makePlugin(activity, "activity", {
          type: o2.activityType,
          style: o2.activityStyle
        });
        if (o2.showActivity !== true) {
          this.activity.css({
            visibility: "hidden"
          });
        }
        this.component = table_component[0];
        if (o2.source !== null) {
          this._fireEvent("data-load", {
            source: o2.source
          });
          var objSource = Utils.isObject(o2.source);
          if (objSource !== false && $5.isPlainObject(objSource)) {
            that._build(objSource);
          } else {
            this.activity.show(function() {
              fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then(function(data) {
                that.activity.hide();
                if (typeof data !== "object") {
                  throw new Error("Data for table is not a object");
                }
                that._fireEvent("data-loaded", {
                  source: o2.source,
                  data
                });
                that._build(data);
              }).catch(function(error) {
                that.activity.hide();
                that._fireEvent("data-load-error", {
                  source: o2.source,
                  error
                });
              });
            });
          }
        } else {
          that._build();
        }
      },
      _createIndex: function() {
        var that = this, colIndex = this.options.checkColIndex;
        setImmediate(function() {
          that.items.forEach(function(v4, i3) {
            that.index[v4[colIndex]] = i3;
          });
        });
      },
      _build: function(data) {
        var that = this, element2 = this.element, o2 = this.options;
        var view, id = element2.attr("id"), viewPath;
        o2.rows = +o2.rows;
        this.items = [];
        this.heads = [];
        this.foots = [];
        if (Array.isArray(o2.head)) {
          this.heads = o2.head;
        }
        if (Array.isArray(o2.body)) {
          this.items = o2.body;
        }
        if (Utils.isValue(data)) {
          this._createItemsFromJSON(data);
        } else {
          this._createItemsFromHTML();
        }
        this._createIndex();
        this.view = this._createView();
        this.viewDefault = Utils.objectClone(this.view);
        viewPath = o2.viewSavePath.replace("$1", id);
        if (o2.viewSaveMode.toLowerCase() === "client") {
          view = Metro2.storage.getItem(viewPath);
          if (Utils.isValue(view) && Utils.objectLength(view) === Utils.objectLength(this.view)) {
            this.view = view;
            this._fireEvent("view-get", {
              source: "client",
              view
            });
          }
          this._final();
        } else {
          fetch(viewPath).then(Metro2.fetch.status).then(Metro2.fetch.json).then(function(view2) {
            if (Utils.isValue(view2) && Utils.objectLength(view2) === Utils.objectLength(that.view)) {
              that.view = view2;
              that._fireEvent("view-get", {
                source: "server",
                view: view2
              });
            }
            that._final();
          }).catch(function(error) {
            that._final();
            console.warn("Warning! Error loading view for table " + element2.attr("id") + ": " + error);
          });
        }
      },
      _final: function() {
        var element2 = this.element, o2 = this.options;
        var id = element2.attr("id");
        Metro2.storage.delItem(o2.checkStoreKey.replace("$1", id));
        this._service();
        this._createStructure();
        this._createInspector();
        this._createEvents();
        this._fireEvent("table-create", {
          element: element2
        });
      },
      _service: function() {
        var o2 = this.options;
        this.service = [
          {
            // Rownum
            ...TABLE_COL_OPTIONS,
            title: o2.rownumTitle,
            clsColumn: "rownum-cell " + (o2.rownum !== true ? "d-none" : ""),
            cls: "rownum-cell " + (o2.rownum !== true ? "d-none" : ""),
            type: "rownum"
          },
          {
            // Checkbox
            ...TABLE_COL_OPTIONS,
            title: o2.checkType === "checkbox" ? "<input type='checkbox' data-role='checkbox' class='table-service-check-all' data-style='" + o2.checkStyle + "'>" : "",
            clsColumn: "check-cell " + (o2.check !== true ? "d-none" : ""),
            cls: "check-cell " + (o2.check !== true ? "d-none" : ""),
            type: "rowcheck"
          }
        ];
      },
      _createView: function() {
        var view;
        view = {};
        $5.each(this.heads, function(i3) {
          if (Utils.isValue(this.cls)) {
            this.cls = this.cls.replace("hidden", "");
          }
          if (Utils.isValue(this.clsColumn)) {
            this.clsColumn = this.clsColumn.replace("hidden", "");
          }
          view[i3] = {
            index: i3,
            "index-view": i3,
            show: !Utils.isValue(this.show) ? true : this.show,
            size: Utils.isValue(this.size) ? this.size : ""
          };
        });
        this._fireEvent("view-created", {
          view
        });
        return view;
      },
      _createInspectorItems: function(table) {
        var that = this, o2 = this.options;
        var j4, tds = [], row;
        var cells = this.heads;
        table.html("");
        for (j4 = 0; j4 < cells.length; j4++) {
          tds[j4] = null;
        }
        $5.each(cells, function(i3) {
          row = $5("<tr>");
          row.data("index", i3);
          row.data("index-view", i3);
          $5("<td>").html(
            "<input type='checkbox' data-style='" + o2.checkStyle + "' data-role='checkbox' name='column_show_check[]' value='" + i3 + "' " + (Utils.bool(that.view[i3]["show"]) ? "checked" : "") + ">"
          ).appendTo(row);
          $5("<td>").html(`<div>${this.title}</div>`).appendTo(row);
          $5("<td>").html("<input type='number' data-role='spinner' name='column_size' value='" + that.view[i3]["size"] + "' data-index='" + i3 + "'>").appendTo(row);
          $5("<td>").html(
            "<button class='button square js-table-inspector-field-up' type='button'>\u2191</button><button class='button square js-table-inspector-field-down' type='button'>\u2193</button>"
          ).appendTo(row);
          tds[that.view[i3]["index-view"]] = row;
        });
        for (j4 = 0; j4 < cells.length; j4++) {
          tds[j4].appendTo(table);
        }
      },
      _createInspector: function() {
        var o2 = this.options, strings = this.strings;
        var inspector, table_wrap, table, tbody, actions;
        inspector = $5("<div data-role='draggable' data-drag-element='.table-inspector-header' data-drag-area='body'>").addClass("table-inspector");
        inspector.attr("for", this.element.attr("id"));
        $5("<div class='table-inspector-header'>" + (o2.inspectorTitle || strings.label_inspector) + "</div>").appendTo(inspector);
        table_wrap = $5("<div>").addClass("table-wrap").appendTo(inspector);
        table = $5("<table>").addClass("table subcompact");
        tbody = $5("<tbody>").appendTo(table);
        table.appendTo(table_wrap);
        this._createInspectorItems(tbody);
        actions = $5("<div class='table-inspector-actions'>").appendTo(inspector);
        $5("<button class='button primary js-table-inspector-save' type='button'>").html(strings.label_save).appendTo(actions);
        $5("<button class='button secondary js-table-inspector-reset ml-2 mr-2' type='button'>").html(strings.label_reset).appendTo(actions);
        $5("<button class='button link js-table-inspector-cancel place-right' type='button'>").html(strings.label_cancel).appendTo(actions);
        inspector.data("open", false);
        this.inspector = inspector;
        $5("body").append(inspector);
        this._createInspectorEvents();
      },
      _resetInspector: function() {
        var inspector = this.inspector;
        var table = inspector.find("table tbody");
        this._createInspectorItems(table);
        this._createInspectorEvents();
      },
      _createHeadsFromHTML: function() {
        var that = this, element2 = this.element;
        var head = element2.find("thead");
        if (head.length > 0) {
          $5.each(head.find("tr > *"), function() {
            var item = $5(this);
            var dir, head_item, item_class;
            if (item.hasClass("rownum-cell") || item.hasClass("check-cell")) return;
            if (Utils.isValue(item.data("sort-dir"))) {
              dir = item.data("sort-dir");
            } else {
              if (item.hasClass("sort-asc")) {
                dir = "asc";
              } else if (item.hasClass("sort-desc")) {
                dir = "desc";
              } else {
                dir = void 0;
              }
            }
            item_class = item[0].className.replace("sortable-column", "");
            item_class = item_class.replace("sort-asc", "");
            item_class = item_class.replace("sort-desc", "");
            item_class = item_class.replace("hidden", "");
            head_item = {
              type: "data",
              title: item.html(),
              name: Utils.isValue(item.data("name")) ? item.data("name") : item.text().replace(" ", "_"),
              sortable: item.hasClass("sortable-column") || Utils.isValue(item.data("sortable")) && JSON.parse(item.data("sortable")) === true,
              sortDir: dir,
              format: Utils.isValue(item.data("format")) ? item.data("format") : "string",
              formatMask: Utils.isValue(item.data("format-mask")) ? item.data("format-mask") : null,
              clsColumn: Utils.isValue(item.data("cls-column")) ? item.data("cls-column") : "",
              cls: item_class,
              colspan: item.attr("colspan"),
              size: Utils.isValue(item.data("size")) ? item.data("size") : "",
              show: !(item.hasClass("hidden") || Utils.isValue(item.data("show")) && JSON.parse(item.data("show")) === false),
              required: Utils.isValue(item.data("required")) ? JSON.parse(item.data("required")) === true : false,
              field: Utils.isValue(item.data("field")) ? item.data("field") : "input",
              fieldType: Utils.isValue(item.data("field-type")) ? item.data("field-type") : "text",
              validator: Utils.isValue(item.data("validator")) ? item.data("validator") : null,
              template: Utils.isValue(item.data("template")) ? item.data("template") : null
            };
            that.heads.push(head_item);
          });
        }
      },
      _createFootsFromHTML: function() {
        var that = this, element2 = this.element;
        var foot = element2.find("tfoot");
        if (foot.length > 0)
          $5.each(foot.find("tr > *"), function() {
            var item = $5(this);
            var foot_item;
            foot_item = {
              title: item.html(),
              name: Utils.isValue(item.data("name")) ? item.data("name") : false,
              cls: item[0].className,
              colspan: item.attr("colspan")
            };
            that.foots.push(foot_item);
          });
      },
      _createItemsFromHTML: function() {
        var that = this, element2 = this.element;
        var body = element2.find("tbody");
        if (body.length > 0)
          $5.each(body.find("tr"), function() {
            var row = $5(this);
            var tr4 = [];
            $5.each(row.children("td"), function() {
              var td = $5(this);
              tr4.push(td.html());
            });
            that.items.push(tr4);
          });
        this._createHeadsFromHTML();
        this._createFootsFromHTML();
      },
      _createItemsFromJSON: function(source) {
        var that = this;
        if (typeof source === "string") {
          source = JSON.parse(source);
        }
        if (source.header !== void 0) {
          that.heads = source.header;
        } else {
          this._createHeadsFromHTML();
        }
        if (source.data !== void 0) {
          $5.each(source.data, function() {
            var row = this;
            var tr4 = [];
            $5.each(row, function() {
              var td = this;
              tr4.push(td);
            });
            that.items.push(tr4);
          });
        }
        if (source.footer !== void 0) {
          this.foots = source.footer;
        } else {
          this._createFootsFromHTML();
        }
      },
      _createTableHeader: function() {
        var element2 = this.element, o2 = this.options;
        var head = element2.find("thead");
        var tr4, th, tds = [], j4, cells;
        var view = o2.staticView ? this._createView() : this.view;
        if (head.length === 0) {
          head = $5("<thead>");
          element2.prepend(head);
        }
        head.clear().addClass(o2.clsHead);
        if (o2.caption) {
          $5("<caption>").html(o2.caption).insertBefore(head);
        }
        if (this.heads.length === 0) {
          return head;
        }
        tr4 = $5("<tr>").addClass(o2.clsHeadRow).appendTo(head);
        $5.each(this.service, function() {
          var item = this, classes = [];
          var th2 = $5("<th>");
          if (Utils.isValue(item.title)) {
            th2.html(item.title);
          }
          if (Utils.isValue(item.size)) {
            th2.css({ width: item.size });
          }
          if (Utils.isValue(item.cls)) {
            classes.push(item.cls);
          }
          classes.push(o2.clsHeadCell);
          th2.addClass(classes.join(" "));
          tr4.append(th2);
        });
        cells = this.heads;
        for (j4 = 0; j4 < cells.length; j4++) {
          tds[j4] = null;
        }
        $5.each(cells, function(cell_index) {
          var item = this;
          var classes = [];
          var th2 = $5("<th>");
          th2.data("index", cell_index);
          if (Utils.isValue(item.title)) {
            th2.html(item.title);
          }
          if (Utils.isValue(item.format)) {
            th2.attr("data-format", item.format);
          }
          if (Utils.isValue(item.formatMask)) {
            th2.attr("data-format-mask", item.formatMask);
          }
          if (Utils.isValue(item.name)) {
            th2.attr("data-name", item.name);
          }
          if (Utils.isValue(item.colspan)) {
            th2.attr("colspan", item.colspan);
          }
          if (Utils.isValue(item.size)) {
            th2.attr("data-size", item.size);
          }
          if (Utils.isValue(item.sortable)) {
            th2.attr("data-sortable", item.sortable);
          }
          if (Utils.isValue(item.sortDir)) {
            th2.attr("data-sort-dir", item.sortDir);
          }
          if (Utils.isValue(item.clsColumn)) {
            th2.attr("data-cls-column", item.clsColumn);
          }
          if (Utils.isValue(item.cls)) {
            th2.attr("data-cls", item.cls);
          }
          if (Utils.isValue(item.show)) {
            th2.attr("data-show", item.show);
          }
          if (Utils.isValue(item.required)) {
            th2.attr("data-required", item.required);
          }
          if (Utils.isValue(item.field)) {
            th2.attr("data-field", item.field);
          }
          if (Utils.isValue(item.fieldType)) {
            th2.attr("data-field-type", item.fieldType);
          }
          if (Utils.isValue(item.validator)) {
            th2.attr("data-validator", item.validator);
          }
          if (Utils.isValue(item.template)) {
            th2.attr("data-template", item.template);
          }
          if (Utils.isValue(view[cell_index]["size"])) {
            th2.css({ width: view[cell_index]["size"] });
          }
          if (item.sortable === true) {
            classes.push("sortable-column");
            if (Utils.isValue(item.sortDir)) {
              classes.push("sort-" + item.sortDir);
            }
          }
          if (Utils.isValue(item.cls)) {
            $5.each(item.cls.toArray(), function() {
              classes.push(this);
            });
          }
          if (Utils.bool(view[cell_index]["show"]) === false) {
            if (classes.indexOf("hidden") === -1) classes.push("hidden");
          }
          classes.push(o2.clsHeadCell);
          if (Utils.bool(view[cell_index]["show"])) {
            Utils.arrayDelete(classes, "hidden");
          }
          th2.addClass(classes.join(" "));
          tds[view[cell_index]["index-view"]] = th2;
        });
        for (j4 = 0; j4 < cells.length; j4++) {
          tds[j4].appendTo(tr4);
        }
      },
      _createTableBody: function() {
        var body, head, element2 = this.element;
        head = element2.find("thead");
        body = element2.find("tbody");
        if (body.length === 0) {
          body = $5("<tbody>").addClass(this.options.clsBody);
          if (head.length !== 0) {
            body.insertAfter(head);
          } else {
            element2.append(body);
          }
        }
        body.clear();
      },
      _createTableFooter: function() {
        var element2 = this.element, o2 = this.options;
        var foot = element2.find("tfoot");
        var tr4, th;
        if (foot.length === 0) {
          foot = $5("<tfoot>").appendTo(element2);
        }
        foot.clear().addClass(o2.clsFooter);
        if (this.foots.length === 0) {
          return;
        }
        tr4 = $5("<tr>").addClass(o2.clsHeadRow).appendTo(foot);
        $5.each(this.foots, function() {
          var item = this;
          th = $5("<th>").appendTo(tr4);
          if (item.title) {
            th.html(item.title);
          }
          if (item.name) {
            th.addClass("foot-column-name-" + item.name);
          }
          if (item.cls) {
            th.addClass(item.cls);
          }
          if (Utils.isValue(item.colspan)) {
            th.attr("colspan", item.colspan);
          }
          th.appendTo(tr4);
        });
      },
      _createTopBlock: function() {
        var that = this, element2 = this.element, o2 = this.options, strings = this.strings;
        var top_block = $5("<div>").addClass("table-top").addClass(o2.clsTableTop).insertBefore(element2.parent());
        var search_block, search_input, rows_block, rows_select;
        search_block = Utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $5("<div>").addClass("table-search-block").addClass(o2.clsSearch).appendTo(top_block);
        search_block.addClass(o2.clsSearch);
        search_input = $5("<input>").attr("type", "text").attr("placeholder", o2.tableSearchPlaceholder).appendTo(search_block);
        Metro2.makePlugin(search_input, "input", {
          prepend: o2.tableSearchTitle || strings.label_search
        });
        if (o2.showSearch !== true) {
          search_block.hide();
        }
        rows_block = Utils.isValue(this.wrapperRows) ? this.wrapperRows : $5("<div>").addClass("table-rows-block").appendTo(top_block);
        rows_block.addClass(o2.clsRowsCount);
        rows_select = $5("<select>").appendTo(rows_block);
        $5.each(o2.rowsSteps.toArray(), function() {
          var val = parseInt(this);
          var option = $5("<option>").attr("value", val).text(val === -1 ? o2.allRecordsTitle || strings.label_all : val).appendTo(rows_select);
          if (val === parseInt(o2.rows)) {
            option.attr("selected", "selected");
          }
        });
        Metro2.makePlugin(rows_select, "select", {
          filter: false,
          prepend: o2.tableRowsCountTitle || strings.label_rows_count,
          onChange: function(val) {
            val = parseInt(val);
            if (val === parseInt(o2.rows)) {
              return;
            }
            o2.rows = val;
            that.currentPage = 1;
            that._draw();
            that._fireEvent("rows-count-change", {
              val
            });
          }
        });
        if (o2.showInspectorButton) {
          $5("<button>").addClass("button inspector-button").attr("type", "button").html(o2.inspectorButtonIcon).insertAfter(rows_block);
        }
        if (o2.showRowsSteps !== true) {
          rows_block.hide();
        }
        return top_block;
      },
      _createBottomBlock: function() {
        var element2 = this.element, o2 = this.options, strings = this.strings;
        var bottom_block = $5("<div>").addClass("table-bottom").addClass(o2.clsTableBottom).insertAfter(element2.parent());
        var info4, pagination, skip;
        info4 = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : $5("<div>").addClass("table-info").appendTo(bottom_block);
        info4.addClass(o2.clsTableInfo);
        if (o2.showTableInfo !== true) {
          info4.hide();
        }
        pagination = Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : $5("<div>").addClass("table-pagination").appendTo(bottom_block);
        pagination.addClass(o2.clsTablePagination);
        if (o2.showPagination !== true) {
          pagination.hide();
        }
        skip = Utils.isValue(this.wrapperSkip) ? this.wrapperSkip : $5("<div>").appendTo(bottom_block);
        skip.addClass("table-skip").addClass(o2.clsTableSkip);
        $5(`<input type='text' data-role='input' placeholder="${strings.label_enter_page}">`).addClass("table-skip-input").addClass(o2.clsTableSkipInput).appendTo(skip);
        $5("<button>").addClass("button table-skip-button").addClass(o2.clsTableSkipButton).html(o2.tableSkipTitle || strings.label_goto_page).appendTo(skip);
        if (o2.showSkip !== true) {
          skip.hide();
        }
        return bottom_block;
      },
      _createStructure: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var columns;
        var w_search = $5(o2.searchWrapper), w_info = $5(o2.infoWrapper), w_rows = $5(o2.rowsWrapper), w_paging = $5(o2.paginationWrapper), w_skip = $5(o2.skipWrapper);
        if (w_search.length > 0) {
          this.wrapperSearch = w_search;
        }
        if (w_info.length > 0) {
          this.wrapperInfo = w_info;
        }
        if (w_rows.length > 0) {
          this.wrapperRows = w_rows;
        }
        if (w_paging.length > 0) {
          this.wrapperPagination = w_paging;
        }
        if (w_skip.length > 0) {
          this.wrapperSkip = w_skip;
        }
        element2.addClass(o2.clsTable);
        this._createTableHeader();
        this._createTableBody();
        this._createTableFooter();
        this._createTopBlock();
        this._createBottomBlock();
        var need_sort = false;
        if (this.heads.length > 0)
          $5.each(this.heads, function(i3) {
            var item = this;
            if (!need_sort && ["asc", "desc"].indexOf(item.sortDir) > -1) {
              need_sort = true;
              that.sort.colIndex = i3;
              that.sort.dir = item.sortDir;
            }
          });
        if (need_sort) {
          columns = element2.find("thead th");
          this._resetSortClass(columns);
          $5(columns.get(this.sort.colIndex + that.service.length)).addClass("sort-" + this.sort.dir);
          this.sorting();
        }
        var filter_func;
        if (Utils.isValue(o2.filters) && typeof o2.filters === "string") {
          $5.each(o2.filters.toArray(), function() {
            filter_func = Utils.isFunc(this);
            if (filter_func !== false) {
              that.filtersIndexes.push(that.addFilter(filter_func));
            }
          });
        }
        this.currentPage = 1;
        this._draw();
      },
      _resetSortClass: function(el) {
        $5(el).removeClass("sort-asc sort-desc");
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var component = element2.closest(".table-component");
        var table_container = component.find(".table-container");
        var search = component.find(".table-search-block input");
        var skip_button = o2.skipWrapper ? $5(o2.skipWrapper).find(".table-skip-button") : component.find(".table-skip-button");
        var skip_input = o2.skipWrapper ? $5(o2.skipWrapper).find(".table-skip-input") : component.find(".table-skip-input");
        var customSearch;
        var id = element2.attr("id");
        var inspectorButton = component.find(".inspector-button");
        inspectorButton.on(Metro2.events.click, function() {
          that.toggleInspector();
        });
        skip_button.on(Metro2.events.click, function() {
          var skipTo = parseInt(skip_input.val().trim());
          if (isNaN(skipTo) || skipTo <= 0 || skipTo > that.pagesCount) {
            skip_input.val("");
            return false;
          }
          skip_input.val("");
          that._fireEvent("skip", {
            skipTo,
            skipFrom: that.currentPage
          });
          that.page(skipTo);
        });
        $5(globalThis).on(
          Metro2.events.resize,
          function() {
            if (o2.horizontalScroll === true) {
              if (!Utils.isNull(o2.horizontalScrollStop) && Utils.mediaExist(o2.horizontalScrollStop)) {
                table_container.removeClass("horizontal-scroll");
              } else {
                table_container.addClass("horizontal-scroll");
              }
            }
          },
          { ns: this.id }
        );
        element2.on(Metro2.events.click, ".sortable-column", function() {
          if (o2.muteTable === true) element2.addClass("disabled");
          if (that.busy) {
            return false;
          }
          that.busy = true;
          var col = $5(this);
          that.activity.show(function() {
            setImmediate(function() {
              that.currentPage = 1;
              that.sort.colIndex = col.data("index");
              if (!col.hasClass("sort-asc") && !col.hasClass("sort-desc")) {
                that.sort.dir = o2.sortDir;
              } else {
                if (col.hasClass("sort-asc")) {
                  that.sort.dir = "desc";
                } else {
                  that.sort.dir = "asc";
                }
              }
              that._resetSortClass(element2.find(".sortable-column"));
              col.addClass("sort-" + that.sort.dir);
              that.sorting();
              that._draw(function() {
                that.busy = false;
                if (o2.muteTable === true) element2.removeClass("disabled");
              });
            });
          });
        });
        element2.on(Metro2.events.click, ".table-service-check input", function() {
          var check = $5(this);
          var status = check.is(":checked");
          var val = "" + check.val();
          var store_key = o2.checkStoreKey.replace("$1", id);
          var storage = Metro2.storage;
          var data = storage.getItem(store_key);
          var is_radio = check.attr("type") === "radio";
          if (is_radio) {
            data = [];
          }
          if (status) {
            if (!Utils.isValue(data)) {
              data = [val];
            } else {
              if (Array(data).indexOf(val) === -1) {
                data.push(val);
              }
            }
          } else {
            if (Utils.isValue(data)) {
              Utils.arrayDelete(data, val);
            } else {
              data = [];
            }
          }
          storage.setItem(store_key, data);
          that._fireEvent("check-click", {
            check: this,
            status,
            data
          });
        });
        element2.on(Metro2.events.click, ".table-service-check-all input", function() {
          var checked = $5(this).is(":checked");
          var store_key = o2.checkStoreKey.replace("$1", id);
          var storage = Metro2.storage;
          var data = [];
          var stored_keys;
          if (o2.useCurrentSlice === true) {
            stored_keys = storage.getItem(store_key, []);
            if (checked) {
              $5.each(that.currentSlice, function() {
                if (stored_keys.indexOf("" + this[o2.checkColIndex]) === -1) {
                  stored_keys.push("" + this[o2.checkColIndex]);
                }
              });
            } else {
              $5.each(that.currentSlice, function() {
                var key = "" + this[o2.checkColIndex];
                if (stored_keys.indexOf(key) !== -1) {
                  Metro2.utils.arrayDelete(stored_keys, key);
                }
              });
            }
            data = stored_keys;
          } else {
            if (checked) {
              $5.each(that.filteredItems, function() {
                if (data.indexOf(this[o2.checkColIndex]) !== -1) return;
                data.push("" + this[o2.checkColIndex]);
              });
            } else {
              data = [];
            }
          }
          storage.setItem(store_key, data);
          that._draw();
          that._fireEvent("check-click-all", {
            check: this,
            status: checked,
            data
          });
        });
        var _search = function() {
          that.searchString = this.value.trim().toLowerCase();
          that.currentPage = 1;
          that._draw();
        };
        _search = Hooks.useDebounce(_search, o2.searchThreshold);
        search.on(Metro2.events.inputchange, _search);
        if (Utils.isValue(this.wrapperSearch)) {
          customSearch = this.wrapperSearch.find("input");
          if (customSearch.length > 0) {
            customSearch.on(Metro2.events.inputchange, _search);
          }
        }
        function pageLinkClick(l3) {
          var link = $5(l3);
          var item = link.parent();
          if (that.filteredItems.length === 0) {
            return;
          }
          if (item.hasClass("active")) {
            return;
          }
          if (item.hasClass("service")) {
            if (link.data("page") === "prev") {
              that.currentPage--;
              if (that.currentPage === 0) {
                that.currentPage = 1;
              }
            } else {
              that.currentPage++;
              if (that.currentPage > that.pagesCount) {
                that.currentPage = that.pagesCount;
              }
            }
          } else {
            that.currentPage = link.data("page");
          }
          that._draw();
        }
        component.on(Metro2.events.click, ".pagination .page-link", function() {
          pageLinkClick(this);
        });
        if (Utils.isValue(this.wrapperPagination)) {
          this.wrapperPagination.on(Metro2.events.click, ".pagination .page-link", function() {
            pageLinkClick(this);
          });
        }
        this._createInspectorEvents();
        element2.on(Metro2.events.click, ".js-table-crud-button", function() {
        });
      },
      _createInspectorEvents: function() {
        var that = this, inspector = this.inspector;
        this._removeInspectorEvents();
        inspector.on(Metro2.events.click, ".js-table-inspector-field-up", function() {
          var button = $5(this), tr4 = button.closest("tr");
          var tr_prev = tr4.prev("tr");
          var index = tr4.data("index");
          var index_view;
          if (tr_prev.length === 0) {
            return;
          }
          tr4.insertBefore(tr_prev);
          tr4.addClass("flash");
          setTimeout(function() {
            tr4.removeClass("flash");
          }, 1e3);
          index_view = tr4.index();
          tr4.data("index-view", index_view);
          that.view[index]["index-view"] = index_view;
          $5.each(tr4.nextAll(), function() {
            var t = $5(this);
            index_view++;
            t.data("index-view", index_view);
            that.view[t.data("index")]["index-view"] = index_view;
          });
          that._createTableHeader();
          that._draw();
        });
        inspector.on(Metro2.events.click, ".js-table-inspector-field-down", function() {
          var button = $5(this), tr4 = button.closest("tr");
          var tr_next = tr4.next("tr");
          var index = tr4.data("index");
          var index_view;
          if (tr_next.length === 0) {
            return;
          }
          tr4.insertAfter(tr_next);
          tr4.addClass("flash");
          setTimeout(function() {
            tr4.removeClass("flash");
          }, 1e3);
          index_view = tr4.index();
          tr4.data("index-view", index_view);
          that.view[index]["index-view"] = index_view;
          $5.each(tr4.prevAll(), function() {
            var t = $5(this);
            index_view--;
            t.data("index-view", index_view);
            that.view[t.data("index")]["index-view"] = index_view;
          });
          that._createTableHeader();
          that._draw();
        });
        inspector.on(Metro2.events.click, "input[type=checkbox]", function() {
          var check = $5(this);
          var status = check.is(":checked");
          var index = check.val();
          var op = ["cls", "clsColumn"];
          if (status) {
            $5.each(op, function() {
              var a3;
              a3 = Utils.isValue(that.heads[index][this]) ? that.heads[index][this].toArray(" ") : [];
              Utils.arrayDelete(a3, "hidden");
              that.heads[index][this] = a3.join(" ");
              that.view[index]["show"] = true;
            });
          } else {
            $5.each(op, function() {
              var a3;
              a3 = Utils.isValue(that.heads[index][this]) ? that.heads[index][this].toArray(" ") : [];
              if (a3.indexOf("hidden") === -1) {
                a3.push("hidden");
              }
              that.heads[index][this] = a3.join(" ");
              that.view[index]["show"] = false;
            });
          }
          that._createTableHeader();
          that._draw();
        });
        inspector.find("input[type=number]").on(Metro2.events.inputchange, function() {
          var input = $5(this);
          var index = input.attr("data-index");
          var val = parseInt(input.val());
          that.view[index]["size"] = val === 0 ? "" : val;
          that._createTableHeader();
        });
        inspector.on(Metro2.events.click, ".js-table-inspector-save", function() {
          that._saveTableView();
          that.openInspector(false);
        });
        inspector.on(Metro2.events.click, ".js-table-inspector-cancel", function() {
          that.openInspector(false);
        });
        inspector.on(Metro2.events.click, ".js-table-inspector-reset", function() {
          that.resetView();
        });
      },
      _removeInspectorEvents: function() {
        var inspector = this.inspector;
        inspector.off(Metro2.events.click, ".js-table-inspector-field-up");
        inspector.off(Metro2.events.click, ".js-table-inspector-field-down");
        inspector.off(Metro2.events.click, "input[type=checkbox]");
        inspector.off(Metro2.events.click, ".js-table-inspector-save");
        inspector.off(Metro2.events.click, ".js-table-inspector-cancel");
        inspector.off(Metro2.events.click, ".js-table-inspector-reset");
        inspector.off(Metro2.events.inputchange, "input[type=number]");
      },
      _saveTableView: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var view = this.view;
        var id = element2.attr("id");
        var viewPath = o2.viewSavePath.replace("$1", id);
        var storage = Metro2.storage;
        if (o2.viewSaveMode.toLowerCase() === "client") {
          storage.setItem(viewPath, view);
          this._fireEvent("view-save", {
            target: "client",
            path: o2.viewSavePath,
            view
          });
        } else {
          var post_data = {
            id: element2.attr("id"),
            view
          };
          fetch(viewPath, {
            method: "POST",
            body: JSON.stringify(post_data),
            header: {
              "Content-type": "application/json;charset=utf-8"
            }
          }).then(Metro2.fetch.status).then(Metro2.fetch.text).then(function(data) {
            that._fireEvent("view-save", {
              target: "server",
              path: o2.viewSavePath,
              view,
              post_data,
              response: data
            });
          }).catch(function(error) {
            that._fireEvent("data-save-error", {
              source: o2.viewSavePath,
              error,
              post_data
            });
          });
        }
      },
      _info: function(start, stop, length) {
        var element2 = this.element, o2 = this.options, strings = this.strings;
        var component = element2.closest(".table-component");
        var info4 = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".table-info");
        var text;
        if (info4.length === 0) {
          return;
        }
        if (stop > length) {
          stop = length;
        }
        if (this.items.length === 0) {
          start = stop = length = 0;
        }
        text = o2.tableInfoTitle || strings.label_table_info;
        text = text.replace("$1", start);
        text = text.replace("$2", stop);
        text = text.replace("$3", length);
        info4.html(text);
      },
      _paging: function(length) {
        var element2 = this.element, o2 = this.options, strings = this.strings;
        var component = element2.closest(".table-component");
        this.pagesCount = Math.ceil(length / o2.rows);
        Metro2.pagination({
          length,
          rows: o2.rows,
          current: this.currentPage,
          target: Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".table-pagination"),
          claPagination: o2.clsPagination,
          prevTitle: o2.paginationPrevTitle || strings.label_prev,
          nextTitle: o2.paginationNextTitle || strings.label_next,
          distance: o2.paginationDistance,
          islandSize: o2.paginationIslandSize,
          shortTrack: o2.paginationShortTrack
        });
      },
      _filter: function() {
        var that = this, o2 = this.options;
        var items;
        if (Utils.isValue(this.searchString) && that.searchString.length >= o2.searchMinLength || this.filters.length > 0) {
          items = this.items.filter(function(row) {
            var row_data = "", result, search_result, i3, j4 = 0;
            if (that.filters.length > 0) {
              result = o2.filtersOperator.toLowerCase() === "and";
              for (i3 = 0; i3 < that.filters.length; i3++) {
                if (Utils.isNull(that.filters[i3])) continue;
                j4++;
                result = o2.filtersOperator.toLowerCase() === "and" ? result && Utils.exec(that.filters[i3], [row, that.heads]) : result || Utils.exec(that.filters[i3], [row, that.heads]);
              }
              if (j4 === 0) result = true;
            } else {
              result = true;
            }
            if (that.searchFields.length > 0) {
              $5.each(that.heads, function(i4, v4) {
                if (that.searchFields.indexOf(v4.name) > -1) {
                  row_data += "\u2022" + row[i4];
                }
              });
            } else {
              row_data = row.join("\u2022");
            }
            row_data = row_data.replace(/[\n\r]+|[\s]{2,}/g, " ").trim().toLowerCase();
            search_result = Utils.isValue(that.searchString) && that.searchString.length >= o2.searchMinLength ? ~row_data.indexOf(that.searchString) : true;
            result = result && search_result;
            if (result) {
              that._fireEvent("filter-row-accepted", {
                row
              });
            } else {
              that._fireEvent("filter-row-declined", {
                row
              });
            }
            return result;
          });
        } else {
          items = this.items;
        }
        this._fireEvent("search", {
          search: that.searchString,
          items
        });
        this.filteredItems = items;
        return items;
      },
      _draw: function(cb) {
        var that = this, element2 = this.element, o2 = this.options, strings = this.strings;
        var body = element2.find("tbody");
        var i3, j4, tr4, td, check, cells, tds, is_even_row;
        var start = parseInt(o2.rows) === -1 ? 0 : o2.rows * (this.currentPage - 1), stop = parseInt(o2.rows) === -1 ? this.items.length - 1 : start + o2.rows - 1;
        var items, checkedItems = [];
        var stored_keys = Metro2.storage.getItem(o2.checkStoreKey.replace("$1", element2.attr("id")));
        var view = o2.staticView ? this.viewDefault : this.view;
        body.html("");
        if (!this.heads.length) {
          console.warn("Heads is not defined for table ID " + element2.attr("id"));
          return;
        }
        items = this._filter();
        this.currentSlice = items.slice(start, stop + 1);
        checkedItems = [];
        if (items.length > 0) {
          for (i3 = start; i3 <= stop; i3++) {
            cells = items[i3];
            tds = [];
            if (!Utils.isValue(cells)) {
              continue;
            }
            tr4 = $5("<tr>").addClass(o2.clsBodyRow);
            tr4.data("original", cells);
            is_even_row = i3 % 2 === 0;
            td = $5("<td>").attr("data-label", "#").attr("aria-label", "#").html(i3 + 1);
            if (that.service[0].clsColumn !== void 0) {
              td.addClass(that.service[0].clsColumn);
            }
            td.appendTo(tr4);
            td = $5("<td>").attr("data-label", "CHK").attr("aria-label", "CHK");
            if (o2.checkType === "checkbox") {
              check = $5(
                "<input type='checkbox' data-style='" + o2.checkStyle + "' data-role='checkbox' name='" + (Utils.isValue(o2.checkName) ? o2.checkName : "table_row_check") + "[]' value='" + items[i3][o2.checkColIndex] + "'>"
              );
            } else {
              check = $5(
                "<input type='radio' data-style='" + o2.checkStyle + "' data-role='radio' name='" + (Utils.isValue(o2.checkName) ? o2.checkName : "table_row_check") + "' value='" + items[i3][o2.checkColIndex] + "'>"
              );
            }
            if (Utils.isValue(stored_keys) && Array.isArray(stored_keys) && stored_keys.indexOf("" + items[i3][o2.checkColIndex]) > -1) {
              check.prop("checked", true);
              checkedItems.push(cells);
            }
            check.addClass("table-service-check");
            this._fireEvent("check-draw", {
              check
            });
            check.appendTo(td);
            if (that.service[1].clsColumn !== void 0) {
              td.addClass(that.service[1].clsColumn);
            }
            td.appendTo(tr4);
            for (j4 = 0; j4 < cells.length; j4++) {
              tds[j4] = null;
            }
            $5.each(cells, function(cell_index) {
              var val = this;
              var td2 = $5("<td>").attr("data-label", that.heads[cell_index].title).attr("aria-label", that.heads[cell_index].title);
              if (Utils.isValue(that.heads[cell_index].template)) {
                val = that.heads[cell_index].template.replace(/%VAL%/g, val);
              }
              td2.html(val);
              td2.addClass(o2.clsBodyCell);
              if (Utils.isValue(that.heads[cell_index].clsColumn)) {
                td2.addClass(that.heads[cell_index].clsColumn);
              }
              if (Utils.bool(view[cell_index].show) === false) {
                td2.addClass("hidden");
              }
              if (Utils.bool(view[cell_index].show)) {
                td2.removeClass("hidden");
              }
              td2.data("original", this);
              tds[view[cell_index]["index-view"]] = td2;
              that._fireEvent("draw-cell", {
                td: td2,
                val,
                cellIndex: cell_index,
                head: that.heads[cell_index],
                items: cells
              });
              if (o2.cellWrapper === true) {
                val = $5("<div>").addClass("data-wrapper").addClass(o2.clsCellWrapper).html(td2.html());
                td2.html("").append(val);
              }
            });
            for (j4 = 0; j4 < cells.length; j4++) {
              tds[j4].appendTo(tr4);
              that._fireEvent("append-cell", {
                td: tds[j4],
                tr: tr4,
                index: j4
              });
            }
            that._fireEvent("draw-row", {
              tr: tr4,
              view: that.view,
              heads: that.heads,
              items: cells
            });
            tr4.addClass(o2.clsRow).addClass(is_even_row ? o2.clsEvenRow : o2.clsOddRow).appendTo(body);
            that._fireEvent("append-row", {
              tr: tr4
            });
          }
          $5(this.component).find(".table-service-check-all input").prop("checked", checkedItems.length);
        } else {
          j4 = 0;
          $5.each(view, function() {
            if (this.show) j4++;
          });
          if (o2.check === true) {
            j4++;
          }
          if (o2.rownum === true) {
            j4++;
          }
          tr4 = $5("<tr>").addClass(o2.clsBodyRow).appendTo(body);
          td = $5("<td>").attr("colspan", j4).addClass("text-center").html(
            $5("<span>").addClass(o2.clsEmptyTableTitle).html(o2.emptyTableTitle || strings.label_empty)
          );
          td.appendTo(tr4);
        }
        this._info(start + 1, stop + 1, items.length);
        this._paging(items.length);
        if (this.activity) this.activity.hide();
        this._fireEvent("draw");
        if (cb !== void 0) {
          Utils.exec(cb, null, element2[0]);
        }
      },
      _getItemContent: function(row) {
        var o2 = this.options, locale = this.locale;
        var result, col = row[this.sort.colIndex];
        var format = this.heads[this.sort.colIndex].format;
        var formatMask = !Utils.isNull(this.heads) && !Utils.isNull(this.heads[this.sort.colIndex]) && Utils.isValue(this.heads[this.sort.colIndex]["formatMask"]) ? this.heads[this.sort.colIndex]["formatMask"] : "%Y-%m-%d";
        var thousandSeparator = this.heads && this.heads[this.sort.colIndex] && this.heads[this.sort.colIndex]["thousandSeparator"] ? this.heads[this.sort.colIndex]["thousandSeparator"] : o2.thousandSeparator;
        var decimalSeparator = this.heads && this.heads[this.sort.colIndex] && this.heads[this.sort.colIndex]["decimalSeparator"] ? this.heads[this.sort.colIndex]["decimalSeparator"] : o2.decimalSeparator;
        result = ("" + col).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, " ").trim();
        if (Utils.isValue(result) && Utils.isValue(format)) {
          if (["number", "int", "float", "money"].indexOf(format) !== -1) {
            result = Utils.parseNumber(result, thousandSeparator, decimalSeparator);
          }
          switch (format) {
            case "date":
              result = formatMask ? Datetime.from(result, formatMask, locale) : datetime(result);
              break;
            case "number":
              result = +result;
              break;
            case "int":
              result = parseInt(result);
              break;
            case "float":
              result = parseFloat(result);
              break;
            case "money":
              result = Utils.parseMoney(result);
              break;
            case "card":
              result = Utils.parseCard(result);
              break;
            case "phone":
              result = Utils.parsePhone(result);
              break;
          }
        }
        return result;
      },
      addItem: function(item, redraw) {
        if (!Array.isArray(item)) {
          console.warn("Item is not an array and can't be added");
          return this;
        }
        this.items.push(item);
        if (redraw !== false) this.draw();
      },
      addItems: function(items, redraw) {
        if (!Array.isArray(items)) {
          console.warn("Items is not an array and can't be added");
          return this;
        }
        items.forEach(function(item) {
          if (Array.isArray(item)) this.items.push(item, false);
        });
        this.draw();
        if (redraw !== false) this.draw();
      },
      updateItem: function(key, field, value) {
        var item = this.items[this.index[key]];
        var fieldIndex = null;
        if (Utils.isNull(item)) {
          console.warn("Item is undefined for update");
          return this;
        }
        if (isNaN(field)) {
          this.heads.forEach(function(v4, i3) {
            if (v4["name"] === field) {
              fieldIndex = i3;
            }
          });
        }
        if (Utils.isNull(fieldIndex)) {
          console.warn("Item is undefined for update. Field " + field + " not found in data structure");
          return this;
        }
        item[fieldIndex] = value;
        this.items[this.index[key]] = item;
        return this;
      },
      getItem: function(key) {
        return this.items[this.index[key]];
      },
      deleteItem: function(fieldIndex, value) {
        var i3, deleteIndexes = [];
        var is_func = Utils.isFunc(value);
        for (i3 = 0; i3 < this.items.length; i3++) {
          if (is_func) {
            if (Utils.exec(value, [this.items[i3][fieldIndex]])) {
              deleteIndexes.push(i3);
            }
          } else {
            if (this.items[i3][fieldIndex] === value) {
              deleteIndexes.push(i3);
            }
          }
        }
        this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);
        return this;
      },
      deleteItemByName: function(fieldName, value) {
        var i3, fieldIndex, deleteIndexes = [];
        var is_func = Utils.isFunc(value);
        for (i3 = 0; i3 < this.heads.length; i3++) {
          if (this.heads[i3]["name"] === fieldName) {
            fieldIndex = i3;
            break;
          }
        }
        for (i3 = 0; i3 < this.items.length; i3++) {
          if (is_func) {
            if (Utils.exec(value, [this.items[i3][fieldIndex]])) {
              deleteIndexes.push(i3);
            }
          } else {
            if (this.items[i3][fieldIndex] === value) {
              deleteIndexes.push(i3);
            }
          }
        }
        this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);
        return this;
      },
      draw: function() {
        this._draw();
        return this;
      },
      sorting: function(dir) {
        var that = this;
        if (Utils.isValue(dir)) {
          this.sort.dir = dir;
        }
        this._fireEvent("sort-start", {
          items: this.items
        });
        this.items.sort(function(a3, b4) {
          var c1 = that._getItemContent(a3);
          var c22 = that._getItemContent(b4);
          var result = 0;
          if (c1 < c22) {
            result = that.sort.dir === "asc" ? -1 : 1;
          }
          if (c1 > c22) {
            result = that.sort.dir === "asc" ? 1 : -1;
          }
          if (result !== 0) {
            that._fireEvent("sort-item-switch", {
              a: a3,
              b: b4,
              result
            });
          }
          return result;
        });
        this._fireEvent("sort-stop", {
          items: this.items
        });
        return this;
      },
      search: function(val) {
        this.searchString = val.trim().toLowerCase();
        this.currentPage = 1;
        this._draw();
        return this;
      },
      _rebuild: function(review) {
        var that = this, element2 = this.element;
        var need_sort = false, sortable_columns;
        this._createIndex();
        if (review === true) {
          this.view = this._createView();
        }
        this._createTableHeader();
        this._createTableBody();
        this._createTableFooter();
        if (this.heads.length > 0)
          $5.each(this.heads, function(i3) {
            var item = this;
            if (!need_sort && ["asc", "desc"].indexOf(item.sortDir) > -1) {
              need_sort = true;
              that.sort.colIndex = i3;
              that.sort.dir = item.sortDir;
            }
          });
        if (need_sort) {
          sortable_columns = element2.find(".sortable-column");
          this._resetSortClass(sortable_columns);
          $5(sortable_columns.get(that.sort.colIndex)).addClass("sort-" + that.sort.dir);
          this.sorting();
        }
        that.currentPage = 1;
        that._draw();
      },
      setHeads: function(data) {
        this.heads = data;
        return this;
      },
      setHeadItem: function(name2, data) {
        var i3, index;
        for (i3 = 0; i3 < this.heads.length; i3++) {
          if (this.heads[i3].name === name2) {
            index = i3;
            break;
          }
        }
        this.heads[index] = data;
        return this;
      },
      setItems: function(data) {
        this.items = data;
        return this;
      },
      setData: function(data) {
        var that = this, o2 = this.options;
        this.activity.show(function() {
          that.items = [];
          that.heads = [];
          that.foots = [];
          if (Array.isArray(o2.head)) {
            that.heads = o2.head;
          }
          if (Array.isArray(o2.body)) {
            that.items = o2.body;
          }
          that._createItemsFromJSON(data);
          that._rebuild(true);
          that.activity.hide();
        });
        return this;
      },
      loadData: function(source, review) {
        var that = this, element2 = this.element, o2 = this.options;
        if (!Utils.isValue(review)) {
          review = true;
        }
        element2.html("");
        if (!Utils.isValue(source)) {
          this._rebuild(review);
        } else {
          o2.source = source;
          this._fireEvent("data-load", {
            source: o2.source
          });
          that.activity.show(function() {
            fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then(function(data) {
              that.activity.hide();
              that.items = [];
              that.heads = [];
              that.foots = [];
              that._fireEvent("data-loaded", {
                source: o2.source,
                data
              });
              if (Array.isArray(o2.head)) {
                that.heads = o2.head;
              }
              if (Array.isArray(o2.body)) {
                that.items = o2.body;
              }
              that._createItemsFromJSON(data);
              that._rebuild(review);
              that._resetInspector();
              that._fireEvent("data-load-end", {
                source: o2.source,
                data
              });
            }).catch(function(error) {
              that.activity.hide();
              that._fireEvent("data-load-error", {
                source: o2.source,
                error
              });
            });
          });
        }
      },
      reload: function(review) {
        this.loadData(this.options.source, review);
      },
      clear: function() {
        this.items = [];
        return this.draw();
      },
      next: function() {
        if (this.items.length === 0) return;
        this.currentPage++;
        if (this.currentPage > this.pagesCount) {
          this.currentPage = this.pagesCount;
          return;
        }
        this._draw();
        return this;
      },
      prev: function() {
        if (this.items.length === 0) return;
        this.currentPage--;
        if (this.currentPage === 0) {
          this.currentPage = 1;
          return;
        }
        this._draw();
        return this;
      },
      first: function() {
        if (this.items.length === 0) return;
        this.currentPage = 1;
        this._draw();
        return this;
      },
      last: function() {
        if (this.items.length === 0) return;
        this.currentPage = this.pagesCount;
        this._draw();
        return this;
      },
      page: function(num) {
        if (num <= 0) {
          num = 1;
        }
        if (num > this.pagesCount) {
          num = this.pagesCount;
        }
        this.currentPage = num;
        this._draw();
        return this;
      },
      addFilter: function(f5, redraw) {
        var filterIndex = null, i3, func = Utils.isFunc(f5);
        if (func === false) {
          return;
        }
        for (i3 = 0; i3 < this.filters.length; i3++) {
          if (Utils.isNull(this.filters[i3])) {
            filterIndex = i3;
            this.filters[i3] = func;
            break;
          }
        }
        if (Utils.isNull(filterIndex)) {
          this.filters.push(func);
          filterIndex = this.filters.length - 1;
        }
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return filterIndex;
      },
      removeFilter: function(key, redraw) {
        this.filters[key] = null;
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return this;
      },
      removeFilters: function(redraw) {
        this.filters = [];
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return this;
      },
      getItems: function() {
        return this.items;
      },
      getHeads: function() {
        return this.heads;
      },
      getView: function() {
        return this.view;
      },
      getFilteredItems: function() {
        return this.filteredItems.length > 0 ? this.filteredItems : this.items;
      },
      getSelectedItems: function() {
        var element2 = this.element, o2 = this.options;
        var stored_keys = Metro2.storage.getItem(o2.checkStoreKey.replace("$1", element2.attr("id")));
        var selected = [];
        if (!Utils.isValue(stored_keys)) {
          return [];
        }
        $5.each(this.items, function() {
          if (stored_keys.indexOf("" + this[o2.checkColIndex]) !== -1) {
            selected.push(this);
          }
        });
        return selected;
      },
      getStoredKeys: function() {
        var element2 = this.element, o2 = this.options;
        return Metro2.storage.getItem(o2.checkStoreKey.replace("$1", element2.attr("id")), []);
      },
      clearSelected: function(redraw) {
        var element2 = this.element, o2 = this.options;
        Metro2.storage.setItem(o2.checkStoreKey.replace("$1", element2.attr("id")), []);
        element2.find("table-service-check-all input").prop("checked", false);
        if (redraw === true) this._draw();
      },
      getFilters: function() {
        return this.filters;
      },
      getFiltersIndexes: function() {
        return this.filtersIndexes;
      },
      openInspector: function(mode) {
        var ins = this.inspector;
        if (mode) {
          ins.show(0, function() {
            ins.css({
              top: ($5(globalThis).height() - ins.outerHeight(true)) / 2 + pageYOffset,
              left: ($5(globalThis).width() - ins.outerWidth(true)) / 2 + pageXOffset
            }).data("open", true);
          });
        } else {
          ins.hide().data("open", false);
        }
      },
      closeInspector: function() {
        this.openInspector(false);
      },
      toggleInspector: function() {
        this.openInspector(!this.inspector.data("open"));
      },
      resetView: function() {
        this.view = this._createView();
        this._createTableHeader();
        this._createTableFooter();
        this._draw();
        this._resetInspector();
        this._saveTableView();
      },
      rebuildIndex: function() {
        this._createIndex();
      },
      getIndex: function() {
        return this.index;
      },
      export: function(to2, mode, filename, options) {
        var Export = Metro2.export;
        var that = this, o2 = this.options;
        var table = document.createElement("table");
        var head = $5("<thead>").appendTo(table);
        var body = $5("<tbody>").appendTo(table);
        var i3, j4, cells, tds = [], items, tr4, td;
        var start, stop;
        if (typeof Export.tableToCSV !== "function") {
          return;
        }
        mode = Utils.isValue(mode) ? mode.toLowerCase() : "all-filtered";
        filename = Utils.isValue(filename) ? filename : Utils.elementId("table") + "-export.csv";
        tr4 = $5("<tr>");
        cells = this.heads;
        for (j4 = 0; j4 < cells.length; j4++) {
          tds[j4] = null;
        }
        $5.each(cells, function(cell_index) {
          var item = this;
          if (Utils.bool(that.view[cell_index]["show"]) === false) {
            return;
          }
          td = $5("<th>");
          if (Utils.isValue(item.title)) {
            td.html(item.title);
          }
          tds[that.view[cell_index]["index-view"]] = td;
        });
        for (j4 = 0; j4 < cells.length; j4++) {
          if (Utils.isValue(tds[j4])) tds[j4].appendTo(tr4);
        }
        tr4.appendTo(head);
        if (mode === "checked") {
          items = this.getSelectedItems();
          start = 0;
          stop = items.length - 1;
        } else if (mode === "view") {
          items = this._filter();
          start = parseInt(o2.rows) === -1 ? 0 : o2.rows * (this.currentPage - 1);
          stop = parseInt(o2.rows) === -1 ? items.length - 1 : start + o2.rows - 1;
        } else if (mode === "all") {
          items = this.items;
          start = 0;
          stop = items.length - 1;
        } else {
          items = this._filter();
          start = 0;
          stop = items.length - 1;
        }
        for (i3 = start; i3 <= stop; i3++) {
          if (Utils.isValue(items[i3])) {
            tr4 = $5("<tr>");
            cells = items[i3];
            for (j4 = 0; j4 < cells.length; j4++) {
              tds[j4] = null;
            }
            $5.each(cells, function(cell_index) {
              if (Utils.bool(that.view[cell_index].show) === false) {
                return;
              }
              td = $5("<td>").html(this);
              tds[that.view[cell_index]["index-view"]] = td;
            });
            for (j4 = 0; j4 < cells.length; j4++) {
              if (Utils.isValue(tds[j4])) tds[j4].appendTo(tr4);
            }
            tr4.appendTo(body);
          }
        }
        Export.tableToCSV(table, filename, options);
        table.remove();
      },
      changeAttribute: function(attributeName) {
        var that = this, element2 = this.element, o2 = this.options;
        function dataCheck() {
          o2.check = Utils.bool(element2.attr("data-check"));
          that._service();
          that._createTableHeader();
          that._draw();
        }
        function dataRownum() {
          o2.rownum = Utils.bool(element2.attr("data-rownum"));
          that._service();
          that._createTableHeader();
          that._draw();
        }
        switch (attributeName) {
          case "data-check":
            dataCheck();
            break;
          case "data-rownum":
            dataRownum();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element;
        var component = element2.closest(".table-component");
        var search_input = component.find("input");
        var rows_select = component.find("select");
        search_input.data("input").destroy();
        rows_select.data("select").destroy();
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.off(Metro2.events.click, ".sortable-column");
        element2.off(Metro2.events.click, ".table-service-check input");
        element2.off(Metro2.events.click, ".table-service-check-all input");
        search_input.off(Metro2.events.inputchange);
        if (Utils.isValue(this.wrapperSearch)) {
          var customSearch = this.wrapperSearch.find("input");
          if (customSearch.length > 0) {
            customSearch.off(Metro2.events.inputchange);
          }
        }
        component.off(Metro2.events.click, ".pagination .page-link");
        if (Utils.isValue(this.wrapperPagination)) {
          this.wrapperPagination.off(Metro2.events.click, ".pagination .page-link");
        }
        element2.off(Metro2.events.click, ".js-table-crud-button");
        this._removeInspectorEvents();
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/tabs-material/tabs-material.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var MaterialTabsDefaultConfig = {
      wheelStep: 20,
      materialtabsDeferred: 0,
      deep: false,
      fixedTabs: false,
      duration: 300,
      appBar: false,
      clsComponent: "",
      clsTabs: "",
      clsTab: "",
      clsTabActive: "",
      clsMarker: "",
      onBeforeTabOpen: Metro2.noop_true,
      onTabOpen: Metro2.noop,
      onTabsScroll: Metro2.noop,
      onTabsCreate: Metro2.noop
    };
    Metro2.materialTabsSetup = function(options) {
      MaterialTabsDefaultConfig = $5.extend({}, MaterialTabsDefaultConfig, options);
    };
    if (typeof globalThis["metroMaterialTabsSetup"] !== "undefined") {
      Metro2.materialTabsSetup(globalThis["metroMaterialTabsSetup"]);
    }
    Metro2.Component("material-tabs", {
      init: function(options, elem) {
        this._super(elem, options, MaterialTabsDefaultConfig, {
          marker: null,
          scroll: 0,
          scrollDir: "left"
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("tabs-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        var tabs = element2.find("li"), active_tab = element2.find("li.active");
        var wrapper = $5("<div>").addClass("tabs-material-wrapper").addClass(o2.clsComponent).insertBefore(element2);
        if (o2.appBar === true) {
          wrapper.addClass("app-bar-present");
        }
        if (o2.appBar === "more") {
          wrapper.addClass("app-bar-present-more");
        }
        element2.appendTo(wrapper);
        element2.addClass("tabs-material").addClass(o2.clsTabs);
        tabs.addClass(o2.clsTab);
        if (o2.deep === true) {
          element2.addClass("deep");
        }
        if (o2.fixedTabs === true) {
          element2.addClass("fixed-tabs");
        }
        this.marker = element2.find(".tab-marker");
        if (this.marker.length === 0) {
          this.marker = $5("<span>").addClass("tab-marker").addClass(o2.clsMarker).appendTo(element2);
        }
        this.openTab(active_tab.length === 0 ? tabs[0] : active_tab[0]);
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.click, "li", function(e2) {
          var tab = $5(this);
          var active_tab = element2.find("li.active");
          var tab_next = tab.index() > active_tab.index();
          var target = tab.children("a").attr("href");
          e2.preventDefault();
          if (Utils.isValue(target) && target[0] === "#") {
            if (tab.hasClass("active")) return;
            if (tab.hasClass("disabled")) return;
            if (Utils.exec(o2.onBeforeTabOpen, [tab, target, tab_next], this) === false) return;
            that.openTab(tab, tab_next);
          }
        });
        element2.on(Metro2.events.scroll, function() {
          var oldScroll = that.scroll;
          that.scrollDir = that.scroll < element2[0].scrollLeft ? "left" : "right";
          that.scroll = element2[0].scrollLeft;
          that._fireEvent("tabs-scroll", {
            scrollLeft: element2[0].scrollLeft,
            oldScroll,
            scrollDir: that.scrollDir
          });
        });
        element2.on(Metro2.events.mousewheel, function(e2) {
          if (e2.deltaY === void 0) {
            return;
          }
          var scroll, scrollable = $5(this);
          var dir = e2.deltaY > 0 ? -1 : 1;
          var step = o2.wheelStep;
          scroll = scrollable.scrollLeft() - dir * step;
          scrollable.scrollLeft(scroll);
        }, {
          passive: true
        });
      },
      openTab: function(tab, tab_next) {
        var element2 = this.element, o2 = this.options;
        var tabs = element2.find("li");
        var magic = 52, shift2, width, tab_width, target, tab_left, scroll, scrollLeft;
        tab = $5(tab);
        $5.each(tabs, function() {
          var target2 = $5(this).find("a").attr("href");
          if (!Utils.isValue(target2)) return;
          if (target2[0] === "#" && target2.length > 1) {
            $5(target2).hide();
          }
        });
        width = element2.width();
        scroll = element2.scrollLeft();
        tab_left = tab.position().left;
        tab_width = tab.width();
        shift2 = tab_left + tab_width;
        tabs.removeClass("active").removeClass(o2.clsTabActive);
        tab.addClass("active").addClass(o2.clsTabActive);
        if (shift2 + magic > width + scroll) {
          scrollLeft = scroll + magic * 2;
        } else if (tab_left < scroll) {
          scrollLeft = tab_left - magic * 2;
        } else {
          scrollLeft = scroll;
        }
        element2.animate({
          draw: {
            scrollLeft
          },
          dur: o2.duration
        });
        this.marker.animate({
          draw: {
            left: tab_left,
            width: tab_width
          },
          dur: o2.duration
        });
        target = tab.find("a").attr("href");
        if (Utils.isValue(target)) {
          if (target[0] === "#" && target.length > 1) {
            $5(target).show();
          }
        }
        this._fireEvent("tab-open", {
          tab: tab[0],
          target,
          tab_next
        });
      },
      open: function(tab_num) {
        var element2 = this.element;
        var tabs = element2.find("li");
        var active_tab = element2.find("li.active");
        var tab = tabs.eq(tab_num - 1);
        var tab_next = tabs.index(tab) > tabs.index(active_tab);
        this.openTab(tab, tab_next);
      },
      changeAttribute: function() {
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.click, "li");
        element2.off(Metro2.events.scroll);
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/tag-input/tag-input.js
  (function(Metro2, $5) {
    "use strict";
    let TagInputDefaultConfig = {
      autocomplete: null,
      autocompleteUnique: true,
      autocompleteUrl: null,
      autocompleteUrlMethod: "GET",
      autocompleteUrlKey: null,
      autocompleteDivider: ",",
      autocompleteListHeight: 200,
      label: "",
      size: "normal",
      taginputDeferred: 0,
      static: false,
      clearButton: true,
      clearButtonIcon: "\u274C",
      randomColor: false,
      maxTags: 0,
      tagSeparator: ",",
      tagTrigger: "Enter, Space, Comma",
      backspace: true,
      clsComponent: "",
      clsInput: "",
      clsClearButton: "",
      clsTag: "",
      clsTagTitle: "",
      clsTagAction: "",
      clsLabel: "",
      onBeforeTagAdd: Metro2.noop_true,
      onTagAdd: Metro2.noop,
      onBeforeTagRemove: Metro2.noop_true,
      onTagRemove: Metro2.noop,
      onTag: Metro2.noop,
      onClear: Metro2.noop,
      onTagTrigger: Metro2.noop,
      onTagInputCreate: Metro2.noop
    };
    Metro2.tagInputSetup = function(options) {
      TagInputDefaultConfig = $5.extend({}, TagInputDefaultConfig, options);
    };
    if (typeof globalThis["metroTagInputSetup"] !== "undefined") {
      Metro2.tagInputSetup(globalThis["metroTagInputSetup"]);
    }
    Metro2.Component("tag-input", {
      init: function(options, elem) {
        this._super(elem, options, TagInputDefaultConfig, {
          values: [],
          triggers: [],
          autocomplete: []
        });
        return this;
      },
      _create: function() {
        this.triggers = ("" + this.options.tagTrigger).toArray(",");
        if (this.triggers.includes("Space") || this.triggers.includes("Spacebar")) {
          this.triggers.push(" ");
          this.triggers.push("Spacebar");
        }
        if (this.triggers.includes("Comma")) {
          this.triggers.push(",");
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("tag-input-create", {
          element: this.element
        });
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        let container, input, clearButton;
        const values = element2.val().trim();
        container = element2.wrap("<div>").addClass("tag-input " + element2[0].className).addClass(o2.clsComponent);
        container.addClass("input-" + o2.size);
        element2[0].className = "";
        element2.addClass("original-input");
        input = $5("<input type='text'>").addClass("input-wrapper").addClass(o2.clsInput).attr("size", 1);
        input.appendTo(container);
        if (o2.clearButton !== false && !element2[0].readOnly) {
          container.addClass("padding-for-clear");
          clearButton = $5("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(container);
        }
        if (Metro2.utils.isValue(values)) {
          $5.each(values.toArray(o2.tagSeparator), function() {
            that._addTag(this);
          });
        }
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(container);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        if (o2.static === true || element2.attr("readonly") !== void 0) {
          container.addClass("static-mode");
        }
        if (!Metro2.utils.isNull(o2.autocomplete) || !Metro2.utils.isNull(o2.autocompleteUrl)) {
          $5("<div>").addClass("autocomplete-list").css({
            maxHeight: o2.autocompleteListHeight,
            display: "none"
          }).appendTo(container);
        }
        if (Metro2.utils.isValue(o2.autocomplete)) {
          const autocomplete_obj = Metro2.utils.isObject(o2.autocomplete);
          if (autocomplete_obj !== false) {
            this.autocomplete = autocomplete_obj;
          } else {
            this.autocomplete = o2.autocomplete.toArray(
              o2.autocompleteDivider
            );
          }
        }
        if (Metro2.utils.isValue(o2.autocompleteUrl)) {
          fetch(o2.autocompleteUrl, {
            method: o2.autocompleteUrlMethod
          }).then(function(response) {
            return response.text();
          }).then(function(data) {
            var newData = [];
            try {
              newData = JSON.parse(data);
              if (o2.autocompleteUrlKey) {
                newData = newData[o2.autocompleteUrlKey];
              }
            } catch (e2) {
              newData = data.split("\n");
            }
            that.autocomplete = that.autocomplete.concat(newData);
          });
        }
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const container = element2.closest(".tag-input");
        const input = container.find(".input-wrapper");
        const autocompleteList = container.find(".autocomplete-list");
        input.on(Metro2.events.focus, function() {
          container.addClass("focused");
        });
        input.on(Metro2.events.blur, function() {
          container.removeClass("focused");
        });
        input.on(Metro2.events.inputchange, function() {
          input.attr("size", Math.ceil(input.val().length / 2) + 2);
        });
        input.on(Metro2.events.keydown, function(e2) {
          var val = input.val().trim();
          var key = e2.key;
          if (key === "Enter") e2.preventDefault();
          if (o2.backspace === true && key === "Backspace" && val.length === 0) {
            if (that.values.length > 0) {
              that.values.splice(-1, 1);
              element2.siblings(".tag").last().remove();
              element2.val(that.values.join(o2.tagSeparator));
            }
            return;
          }
          if (val === "") {
            return;
          }
          if (!that.triggers.includes(key)) {
            return;
          }
          that._fireEvent("tag-trigger", {
            key
          });
          input.val("");
          that._addTag(val);
          input.attr("size", 1);
        });
        input.on(Metro2.events.keyup, function(e2) {
          const val = input.val();
          const key = e2.key;
          if (that.triggers.includes(key) && val[val.length - 1] === key) {
            input.val(val.slice(0, -1));
          }
        });
        container.on(Metro2.events.click, ".tag .action", function() {
          const tag = $5(this).closest(".tag");
          that._delTag(tag);
        });
        container.on(Metro2.events.click, function() {
          input.focus();
        });
        container.on(
          Metro2.events.click,
          ".input-clear-button",
          function() {
            const val = element2.val();
            that.clear();
            that._fireEvent("clear", {
              val
            });
          }
        );
        input.on(Metro2.events.input, function() {
          const val = this.value.toLowerCase();
          that._drawAutocompleteList(val);
        });
        container.on(
          Metro2.events.click,
          ".autocomplete-list .item",
          function() {
            const val = $5(this).attr("data-autocomplete-value");
            input.val("");
            that._addTag(val);
            input.attr("size", 1);
            autocompleteList.css({
              display: "none"
            });
            that._fireEvent("autocomplete-select", {
              value: val
            });
          }
        );
      },
      _drawAutocompleteList: function(val) {
        const that = this, element2 = this.element, o2 = this.options;
        const container = element2.closest(".tag-input");
        const input = container.find(".input-wrapper");
        const autocompleteList = container.find(".autocomplete-list");
        let items;
        if (autocompleteList.length === 0) {
          return;
        }
        autocompleteList.html("");
        items = this.autocomplete.filter(function(item) {
          return item.toLowerCase().indexOf(val) > -1;
        });
        autocompleteList.css({
          display: items.length > 0 ? "block" : "none",
          left: input.position().left
        });
        $5.each(items, function() {
          if (o2.autocompleteUnique && that.values.indexOf(this) !== -1) {
            return;
          }
          const v4 = this;
          let index = v4.toLowerCase().indexOf(val), content;
          const item = $5("<div>").addClass("item").attr("data-autocomplete-value", v4);
          if (index === 0) {
            content = "<strong>" + v4.substr(0, val.length) + "</strong>" + v4.substr(val.length);
          } else {
            content = v4.substr(0, index) + "<strong>" + v4.substr(index, val.length) + "</strong>" + v4.substr(index + val.length);
          }
          item.html(content).appendTo(autocompleteList);
          that._fireEvent("draw-autocomplete-item", {
            item
          });
        });
      },
      _addTag: function(val) {
        const element2 = this.element, o2 = this.options;
        const container = element2.closest(".tag-input");
        const input = container.find(".input-wrapper");
        let tag, title, remover;
        let tagSize, tagStatic;
        if (container.hasClass("input-large")) {
          tagSize = "large";
        } else if (container.hasClass("input-small")) {
          tagSize = "small";
        }
        if (o2.maxTags > 0 && this.values.length === o2.maxTags) {
          return;
        }
        if (("" + val).trim() === "") {
          return;
        }
        if (!Metro2.utils.exec(o2.onBeforeTagAdd, [val, this.values], element2[0])) {
          return;
        }
        tag = $5("<span>").addClass("tag").addClass(tagSize).addClass(o2.clsTag).insertBefore(input);
        tag.data("value", val);
        tagStatic = o2.static || container.hasClass("static-mode") || element2.readonly || element2.disabled || container.hasClass("disabled");
        if (tagStatic) {
          tag.addClass("static");
        }
        title = $5("<span>").addClass("title").addClass(o2.clsTagTitle).html(val);
        remover = $5("<span>").addClass("action").addClass(o2.clsTagAction).html("&times;");
        title.appendTo(tag);
        remover.appendTo(tag);
        if (o2.randomColor === true) {
          let colors = Object.values(
            Object.assign(
              {},
              Farbe.StandardColors,
              Farbe.MetroColors
            )
          ), bg, fg, bg_r;
          bg = colors[$5.random(0, colors.length - 1)];
          bg_r = Farbe.Routines.darken(bg, 15);
          fg = Farbe.Routines.isDark(bg) ? "#ffffff" : "#000000";
          tag.css({
            backgroundColor: bg,
            color: fg
          });
          remover.css({
            backgroundColor: bg_r,
            color: fg
          });
        }
        this.values.push(val);
        element2.val(this.values.join(o2.tagSeparator));
        this._fireEvent("tag-add", {
          tag: tag[0],
          val,
          values: this.values
        });
        this._fireEvent("tag", {
          tag: tag[0],
          val,
          values: this.values
        });
      },
      _delTag: function(tag) {
        const element2 = this.element, o2 = this.options;
        const val = tag.data("value");
        if (!Metro2.utils.exec(
          o2.onBeforeTagRemove,
          [tag, val, this.values],
          element2[0]
        )) {
          return;
        }
        Metro2.utils.arrayDelete(this.values, val);
        element2.val(this.values.join(o2.tagSeparator));
        this._fireEvent("tag-remove", {
          tag: tag[0],
          val,
          values: this.values
        });
        this._fireEvent("tag", {
          tag: tag[0],
          val,
          values: this.values
        });
        tag.remove();
      },
      tags: function() {
        return this.values;
      },
      val: function(v4) {
        const that = this, element2 = this.element, o2 = this.options;
        const container = element2.closest(".tag-input");
        let newValues = [];
        if (!Metro2.utils.isValue(v4)) {
          return this.tags();
        }
        this.values = [];
        container.find(".tag").remove();
        if (typeof v4 === "string") {
          newValues = ("" + v4).toArray(o2.tagSeparator);
        } else {
          if (Array.isArray(v4)) {
            newValues = v4;
          }
        }
        $5.each(newValues, function() {
          that._addTag(this);
        });
        return this;
      },
      append: function(v4) {
        const that = this, o2 = this.options;
        let newValues = this.values;
        if (typeof v4 === "string") {
          newValues = ("" + v4).toArray(o2.tagSeparator);
        } else {
          if (Array.isArray(v4)) {
            newValues = v4;
          }
        }
        $5.each(newValues, function() {
          that._addTag(this);
        });
        return this;
      },
      clear: function() {
        const element2 = this.element;
        const container = element2.closest(".tag-input");
        this.values = [];
        element2.val("").trigger("change");
        container.find(".tag").remove();
        return this;
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      toggleStatic: function(val) {
        const container = this.element.closest(".tag-input");
        let staticMode;
        if (Metro2.utils.isValue(val)) {
          staticMode = Metro2.utils.bool(val);
        } else {
          staticMode = !container.hasClass("static-mode");
        }
        if (staticMode) {
          container.addClass("static-mode");
        } else {
          container.removeClass("static-mode");
        }
      },
      setAutocompleteList: function(l3) {
        const autocomplete_list = Metro2.utils.isObject(l3);
        if (autocomplete_list !== false) {
          this.autocomplete = autocomplete_list;
        } else if (typeof l3 === "string") {
          this.autocomplete = l3.toArray(this.options.autocompleteDivider);
        }
      },
      changeAttribute: function(attributeName) {
        const that = this, element2 = this.element, o2 = this.options;
        const changeValue = function() {
          var val = element2.attr("value").trim();
          that.clear();
          if (!Metro2.utils.isValue(val)) {
            return;
          }
          that.val(val.toArray(o2.tagSeparator));
        };
        switch (attributeName) {
          case "value":
            changeValue();
            break;
          case "disabled":
            this.toggleState();
            break;
          case "static":
            this.toggleStatic();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        const container = element2.closest(".tag-input");
        const input = container.find(".input-wrapper");
        input.off(Metro2.events.focus);
        input.off(Metro2.events.blur);
        input.off(Metro2.events.keydown);
        container.off(Metro2.events.click, ".tag .action");
        container.off(Metro2.events.click);
        if (o2.label) {
          container.prev("label").remove();
        }
        container.remove();
      }
    });
    $5(document).on(Metro2.events.click, function() {
      $5(".tag-input .autocomplete-list").hide();
    });
  })(Metro, Dom);

  // source/components/task-bar/task-bar.js
  (function(Metro2, $5) {
    "use strict";
    let TaskBarDefaultConfig = {
      onTaskClick: Metro2.noop,
      onMyObjectCreate: Metro2.noop
    };
    Metro2.taskBarSetup = function(options) {
      TaskBarDefaultConfig = $5.extend({}, TaskBarDefaultConfig, options);
    };
    if (typeof globalThis["metroTaskBarSetup"] !== "undefined") {
      Metro2.taskBarSetup(globalThis["metroTaskBarSetup"]);
    }
    Metro2.Component("task-bar", {
      init: function(options, elem) {
        this._super(elem, options, TaskBarDefaultConfig, {
          // define instance vars here
          tasks: [],
          systemTray: [],
          widgets: []
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("task-bar-create");
      },
      _createStructure: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.addClass("task-bar");
        element2.append($5("<div>").addClass("widgets"));
        element2.append($5("<div>").addClass("tasks"));
        element2.append($5("<div>").addClass("system-tray"));
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.click, ".task", function() {
          const task = that.tasks[$5(this).index()];
          for (const t of that.tasks) {
            t.active = false;
          }
          task.active = true;
          that._renderTasks();
          that._fireEvent("task-click", {
            task,
            element: task.ref
          });
        });
        element2.on(Metro2.events.click, ".system-tray-item", function() {
          const item = that.systemTray[$5(this).index()];
          that._fireEvent("system-tray-click", {
            item
          });
        });
        element2.on(Metro2.events.click, ".widget", function() {
          const item = that.widgets[$5(this).index()];
          that._fireEvent("widget-click", {
            item
          });
        });
      },
      _renderTasks: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const tasks = element2.find(".tasks").clear();
        for (const task of this.tasks) {
          const taskItem = $5("<div>").addClass("task").attr("title", task.title).html(task.icon);
          if (task.active) {
            taskItem.addClass("active");
          }
          tasks.append(taskItem);
        }
      },
      _renderSystemTray: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const systemTray = element2.find(".system-tray").clear();
        for (const item of this.systemTray) {
          systemTray.append($5(item).addClass("system-tray-item"));
        }
      },
      _renderWidgets: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const widgets = element2.find(".widgets").clear();
        for (const widget of this.widgets) {
          widgets.append($5(widget).addClass("widget"));
        }
      },
      /*
      * task = {
      *   title: "Task title",
      *   description: "Task description",
      *   icon: "<span class='mif-cogs'></span>",
      *   ref: null, // Reference to the element in the DOM
      * }
      * */
      addTask: function(task, active = false) {
        if (active) {
          for (const t of this.tasks) {
            t.active = false;
          }
        }
        this.tasks.push({ ...task, active });
        this._renderTasks();
      },
      removeTask: function(task) {
        this.tasks = this.tasks.filter((t) => t.ref !== task);
        this._renderTasks();
      },
      activateTask: function(ref) {
        const tasks = this.tasks.filter((t) => t.ref === ref);
        if (tasks.length === 0) {
          return;
        }
        const task = tasks[0];
        for (const t of this.tasks) {
          t.active = false;
        }
        task.active = true;
        this._renderTasks();
      },
      /*
      * item = HTMLElement
      * */
      addToSystemTray: function(item) {
        this.systemTray.push(item);
        this._renderSystemTray();
      },
      /*
      * widget = HTMLElement
      * */
      addWidget: function(widget) {
        this.widgets.push(widget);
        this._renderWidgets();
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/template/template.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var Engine = function(html, options, conf) {
      var ReEx, re3 = "<%(.+?)%>", reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g, code = "with(obj) { var r=[];\n", cursor = 0, result, match;
      var add2 = function(line, js) {
        js ? code += line.match(reExp) ? line + "\n" : "r.push(" + line + ");\n" : code += line !== "" ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : "";
        return add2;
      };
      if (Utils.isValue(conf)) {
        if ($5.hasProp(conf, "beginToken")) {
          re3 = re3.replace("<%", conf.beginToken);
        }
        if ($5.hasProp(conf, "endToken")) {
          re3 = re3.replace("%>", conf.endToken);
        }
      }
      ReEx = new RegExp(re3, "g");
      match = ReEx.exec(html);
      while (match) {
        add2(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
        match = ReEx.exec(html);
      }
      add2(html.substr(cursor, html.length - cursor));
      code = (code + 'return r.join(""); }').replace(/[\r\t\n]/g, " ");
      try {
        result = new Function("obj", code).apply(options, [options]);
      } catch (err) {
        console.error("'" + err.message + "'", " in \n\nCode:\n", code, "\n");
      }
      return result;
    };
    var TemplateDefaultConfig = {
      templateData: null,
      onTemplateCompile: Metro2.noop,
      onTemplateCreate: Metro2.noop
    };
    Metro2.templateSetup = function(options) {
      TemplateDefaultConfig = $5.extend({}, TemplateDefaultConfig, options);
    };
    if (typeof globalThis["metroTemplateSetup"] !== "undefined") {
      Metro2.templateSetup(globalThis["metroTemplateSetup"]);
    }
    Metro2.Component("template", {
      init: function(options, elem) {
        this._super(elem, options, TemplateDefaultConfig, {
          template: null,
          data: {}
        });
        return this;
      },
      _compile: function() {
        var element2 = this.element;
        var template, compiled;
        template = this.template.replace(/(&lt;%)/gm, "<%").replace(/(%&gt;)/gm, "%>").replace(/(&lt;)/gm, "<").replace(/(&gt;)/gm, ">");
        compiled = Engine(template, this.data);
        element2.html(compiled);
        this._fireEvent("template-compile", {
          template,
          compiled,
          element: element2
        });
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        this.template = element2.html();
        this.data = Utils.isObject(o2.templateData) || {};
        this._compile();
        this._fireEvent("template-create", {
          element: element2
        });
      },
      buildWith: function(obj) {
        var data = Utils.isObject(obj);
        if (!data) {
          return;
        }
        this.data = data;
        this._compile();
      },
      changeAttribute: function(a3, v4) {
        if (a3 === "data-template-data") {
          this.options.templateData = v4;
          this.data = Utils.isObject(v4) || {};
          this._compile();
        }
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2.template = Engine;
  })(Metro, Dom);

  // source/components/textarea/textarea.js
  (function(Metro2, $5) {
    "use strict";
    let TextareaDefaultConfig = {
      label: "",
      textareaDeferred: 0,
      charsCounter: null,
      charsCounterTemplate: "$1",
      defaultValue: "",
      prepend: "",
      append: "",
      clearButton: true,
      clearButtonIcon: "\u274C",
      autoSize: true,
      maxHeight: 0,
      clsPrepend: "",
      clsAppend: "",
      clsComponent: "",
      clsTextarea: "",
      clsLabel: "",
      onChange: Metro2.noop,
      onTextareaCreate: Metro2.noop
    };
    Metro2.textareaSetup = function(options) {
      TextareaDefaultConfig = $5.extend({}, TextareaDefaultConfig, options);
    };
    if (typeof globalThis["metroTextareaSetup"] !== "undefined") {
      Metro2.textareaSetup(globalThis["metroTextareaSetup"]);
    }
    Metro2.Component("textarea", {
      init: function(options, elem) {
        this._super(elem, options, TextareaDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("textarea-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const that = this, element2 = this.element, elem = this.elem, o2 = this.options;
        const container = $5("<div>").addClass("textarea " + element2[0].className);
        const fakeTextarea = $5("<textarea>").addClass("fake-textarea");
        let clearButton;
        container.insertBefore(element2);
        element2.appendTo(container);
        fakeTextarea.appendTo(container);
        if (o2.clearButton !== false && !element2[0].readOnly) {
          clearButton = $5("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(container);
        }
        if (element2.attr("dir") === "rtl") {
          container.addClass("rtl").attr("dir", "rtl");
        }
        if (o2.prepend !== "") {
          const prepend = $5("<div>").html(o2.prepend);
          prepend.addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
        }
        if (o2.append !== "") {
          const append = $5("<div>").html(o2.append);
          append.addClass("append").addClass(o2.clsAppend).appendTo(container);
          clearButton.css({
            right: append.outerWidth() + 4
          });
        }
        elem.className = "";
        if (Metro2.utils.isValue(o2.defaultValue) && element2.val().trim() === "") {
          element2.val(o2.defaultValue);
        }
        container.addClass(o2.clsComponent);
        element2.addClass(o2.clsTextarea);
        if (o2.label) {
          const label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(container);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        fakeTextarea.val(element2.val());
        if (o2.autoSize === true) {
          container.addClass("autosize no-scroll-vertical");
          setTimeout(function() {
            that.resize();
          }, 100);
        }
        this.component = container;
      },
      _createEvents: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const textarea = element2.closest(".textarea");
        const fakeTextarea = textarea.find(".fake-textarea");
        const chars_counter = $5(o2.charsCounter);
        textarea.on(Metro2.events.click, ".input-clear-button", function(e2) {
          element2.val(Metro2.utils.isValue(o2.defaultValue) ? o2.defaultValue : "").trigger("change").trigger("keyup").focus();
          e2.preventDefault();
          e2.stopPropagation();
        });
        if (o2.autoSize) {
          element2.on(Metro2.events.inputchange + " " + Metro2.events.keyup, function() {
            fakeTextarea.val(this.value);
            that.resize();
          });
        }
        element2.on(Metro2.events.blur, function() {
          textarea.removeClass("focused");
        });
        element2.on(Metro2.events.focus, function() {
          textarea.addClass("focused");
        });
        element2.on(Metro2.events.keyup, function() {
          if (Metro2.utils.isValue(o2.charsCounter) && chars_counter.length > 0) {
            if (chars_counter[0].tagName === "INPUT") {
              chars_counter.val(that.length());
            } else {
              chars_counter.html(o2.charsCounterTemplate.replace("$1", that.length()));
            }
          }
          that._fireEvent("change", {
            val: element2.val(),
            length: that.length()
          });
        });
      },
      resize: function() {
        const element2 = this.element, o2 = this.options, textarea = element2.closest(".textarea"), fakeTextarea = textarea.find(".fake-textarea"), currentHeight = fakeTextarea[0].scrollHeight;
        if (o2.maxHeight && currentHeight >= o2.maxHeight) {
          textarea.removeClass("no-scroll-vertical");
          return;
        }
        if (o2.maxHeight && currentHeight < o2.maxHeight) {
          textarea.addClass("no-scroll-vertical");
        }
        fakeTextarea[0].style.cssText = "height:auto;";
        fakeTextarea[0].style.cssText = "height:" + fakeTextarea[0].scrollHeight + "px";
        element2[0].style.cssText = "height:" + fakeTextarea[0].scrollHeight + "px";
      },
      clear: function() {
        this.element.val("").trigger("change").trigger("keyup").focus();
      },
      toDefault: function() {
        this.element.val(Metro2.utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "").trigger("change").trigger("keyup").focus();
      },
      length: function() {
        var characters = this.elem.value.split("");
        return characters.length;
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element, o2 = this.options;
        const textarea = element2.closest(".textarea");
        textarea.off(Metro2.events.click, ".input-clear-button");
        if (o2.autoSize) {
          element2.off(Metro2.events.inputchange + " " + Metro2.events.keyup);
        }
        element2.off(Metro2.events.blur);
        element2.off(Metro2.events.focus);
        element2.off(Metro2.events.keyup);
        if (o2.label) {
          this.component.prev("label").remove();
        }
        this.component.remove();
      }
    });
  })(Metro, Dom);

  // source/components/theme-switcher/theme-switcher.js
  (function(Metro2, $5) {
    "use strict";
    let ThemeSwitcherDefaultConfig = {
      state: Metro2.theme.LIGHT,
      target: "html",
      saveState: true,
      saveStateKey: "THEME:SWITCHER",
      clsDark: "",
      darkSymbol: "\u{1F319}",
      lightSymbol: "\u{1F31E}",
      mode: "switch",
      onThemeSwitcherCreate: Metro2.noop,
      onChangeTheme: Metro2.noop
    };
    Metro2.themeSwitcherSetup = function(options) {
      ThemeSwitcherDefaultConfig = $5.extend({}, ThemeSwitcherDefaultConfig, options);
    };
    if (typeof globalThis["metroThemeSwitcherSetup"] !== "undefined") {
      Metro2.themeSwitcherSetup(globalThis["metroThemeSwitcherSetup"]);
    }
    Metro2.Component("theme-switcher", {
      init: function(options, elem) {
        this._super(elem, options, ThemeSwitcherDefaultConfig, {
          container: null,
          state: null,
          target: null
        });
        this.state = this.options.state;
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("theme-switcher-create");
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        let initState = "light";
        if (o2.saveState) {
          initState = Metro2.storage.getItem(o2.saveStateKey, false);
        }
        element2.attr("data-light-symbol", o2.lightSymbol);
        element2.attr("data-dark-symbol", o2.darkSymbol);
        Metro2.makePlugin(element2, "switch");
        this.container = element2.wrap($5("<label>").addClass("theme-switcher"));
        this.container.addClass(`mode-${o2.mode}`);
        this.target = $5(o2.target);
        if (this.target.length === 0) {
          this.target = $5("html");
        }
        this._setState(o2.saveState ? initState : o2.state === Metro2.theme.DARK);
        this._updateState();
      },
      _createEvents: function() {
        this.container.on("click", () => {
          this._updateState();
        });
        this._observeClass();
      },
      _observeClass: function() {
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === "attributes") {
              if (mutation.attributeName === "class") {
                this.elem.checked = this.target[0].classList.contains("dark-side");
              }
            }
          });
        });
        observer.observe(this.target[0], {
          attributes: true,
          attributeFilter: ["class"]
        });
      },
      _setState: function(state2 = false) {
        this.elem.checked = state2;
      },
      _updateState: function() {
        const usingMeta = $5.meta("metro:theme").length > 0;
        const o2 = this.options, elem = this.elem, target = this.target;
        if (usingMeta) {
          return;
        }
        if (elem.checked) {
          target.addClass("dark-side").addClass(this.options.clsDark);
        } else {
          target.removeClass("dark-side").addClass(this.options.clsDark);
        }
        if (o2.saveState) {
          Metro2.storage.setItem(o2.saveStateKey, elem.checked);
        }
        this._fireEvent("change-theme", { state: elem.checked });
      },
      val: function(value) {
        if (typeof value === void 0) {
          return this.elem.checked ? Metro2.theme.DARK : Metro2.theme.LIGHT;
        }
        this._setState(typeof value === "boolean" ? value : value === Metro2.theme.DARK);
        this._updateState();
      },
      changeAttribute: function(attr, newValue) {
        if (attr === "data-target") {
          this.target = $5(newValue);
          this._updateState();
        }
      },
      destroy: function() {
        this.container.remove();
      }
    });
  })(Metro, Dom);

  // source/components/tile/tile.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var effects = [
      "slide-up",
      "slide-down",
      "slide-left",
      "slide-right",
      "fade",
      "zoom",
      "swirl",
      "switch"
    ];
    var TileDefaultConfig = {
      tileDeferred: 0,
      size: "medium",
      cover: "",
      coverPosition: "center",
      effect: "",
      // slide-up, slide-down, slide-left, slide-right, fade, zoom, swirl, switch
      effectInterval: 3e3,
      effectDuration: 500,
      target: null,
      canTransform: true,
      onTileClick: Metro2.noop,
      onTileCreate: Metro2.noop
    };
    Metro2.tileSetup = function(options) {
      TileDefaultConfig = $5.extend({}, TileDefaultConfig, options);
    };
    if (typeof globalThis["metroTileSetup"] !== "undefined") {
      Metro2.tileSetup(globalThis["metroTileSetup"]);
    }
    Metro2.Component("tile", {
      init: function(options, elem) {
        this._super(elem, options, TileDefaultConfig, {
          effectInterval: false,
          images: [],
          slides: [],
          currentSlide: -1,
          unload: false
        });
        return this;
      },
      _create: function() {
        var element2 = this.element;
        this._createTile();
        this._createEvents();
        this._fireEvent("tile-create", {
          element: element2
        });
      },
      _createTile: function() {
        function switchImage(el, img_src, i4) {
          setTimeout(function() {
            el.fadeOut(500, function() {
              el.css("background-image", "url(" + img_src + ")");
              el.fadeIn();
            });
          }, i4 * 300);
        }
        var that = this, element2 = this.element, o2 = this.options;
        var slides = element2.find(".slide");
        var slides2 = element2.find(".slide-front, .slide-back");
        element2.addClass("tile-" + o2.size);
        if (o2.effect.indexOf("hover-") > -1) {
          element2.addClass("effect-" + o2.effect);
          $5.each(slides2, function() {
            var slide = $5(this);
            if (slide.data("cover") !== void 0) {
              that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
            }
          });
        }
        if (effects.includes(o2.effect) && slides.length > 1) {
          $5.each(slides, function(i4) {
            var slide = $5(this);
            that.slides.push(this);
            if (slide.data("cover") !== void 0) {
              that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
            }
            if (i4 > 0) {
              if (["slide-up", "slide-down"].indexOf(o2.effect) > -1) slide.css("top", "100%");
              if (["slide-left", "slide-right"].indexOf(o2.effect) > -1) slide.css("left", "100%");
              if (["fade", "zoom", "swirl", "switch"].indexOf(o2.effect) > -1) slide.css("opacity", 0);
            }
          });
          this.currentSlide = 0;
          this._runEffects();
        }
        if (o2.cover !== "") {
          this._setCover(element2, o2.cover);
        }
        if (o2.effect === "image-set") {
          element2.addClass("image-set");
          $5.each(element2.children("img"), function() {
            that.images.push(this);
            $5(this).remove();
          });
          var temp = this.images.slice();
          for (var i3 = 0; i3 < 5; i3++) {
            var rnd_index = $5.random(0, temp.length - 1);
            var div = $5("<div>").addClass("img -js-img-" + i3).css("background-image", "url(" + temp[rnd_index].src + ")");
            element2.prepend(div);
            temp.splice(rnd_index, 1);
          }
          var a3 = [0, 1, 4, 3, 2];
          setInterval(function() {
            var temp2 = that.images.slice();
            var bg = Farbe.Routines.randomColor();
            element2.css("background-color", bg);
            for (var i4 = 0; i4 < a3.length; i4++) {
              var rnd_index2 = $5.random(0, temp2.length - 1);
              var div2 = element2.find(".-js-img-" + a3[i4]);
              switchImage(div2, temp2[rnd_index2].src, i4);
              temp2.splice(rnd_index2, 1);
            }
            a3 = a3.reverse();
          }, 5e3);
        }
      },
      _runEffects: function() {
        var that = this, o2 = this.options;
        if (this.effectInterval === false) this.effectInterval = setInterval(function() {
          var current, next;
          current = $5(that.slides[that.currentSlide]);
          that.currentSlide++;
          if (that.currentSlide === that.slides.length) {
            that.currentSlide = 0;
          }
          next = that.slides[that.currentSlide];
          if (effects.includes(o2.effect)) {
            Metro2.Effects[Str.camelCase(o2.effect)]($5(current)[0], $5(next)[0], { duration: o2.effectDuration });
          }
        }, o2.effectInterval);
      },
      _stopEffects: function() {
        $5.clearInterval(this.effectInterval);
        this.effectInterval = false;
      },
      _setCover: function(to2, src, pos) {
        if (!Utils.isValue(pos)) {
          pos = this.options.coverPosition;
        }
        to2.css({
          backgroundImage: "url(" + src + ")",
          backgroundSize: "cover",
          backgroundRepeat: "no-repeat",
          backgroundPosition: pos
        });
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options;
        element2.on(Metro2.events.startAll, function(e2) {
          var tile = $5(this);
          var dim = { w: element2.width(), h: element2.height() };
          var X4 = Utils.pageXY(e2).x - tile.offset().left, Y4 = Utils.pageXY(e2).y - tile.offset().top;
          var side;
          if (Utils.isRightMouse(e2) === false) {
            if (X4 < dim.w * 1 / 3 && (Y4 < dim.h * 1 / 2 || Y4 > dim.h * 1 / 2)) {
              side = "left";
            } else if (X4 > dim.w * 2 / 3 && (Y4 < dim.h * 1 / 2 || Y4 > dim.h * 1 / 2)) {
              side = "right";
            } else if (X4 > dim.w * 1 / 3 && X4 < dim.w * 2 / 3 && Y4 > dim.h / 2) {
              side = "bottom";
            } else {
              side = "top";
            }
            if (o2.canTransform === true) tile.addClass("transform-" + side);
            if (o2.target !== null) {
              setTimeout(function() {
                document.location.href = o2.target;
              }, 100);
            }
            that._fireEvent("tile-click", {
              side
            });
          }
        });
        element2.on([Metro2.events.stopAll, Metro2.events.leave].join(" "), function() {
          $5(this).removeClass("transform-left").removeClass("transform-right").removeClass("transform-top").removeClass("transform-bottom");
        });
      },
      changeAttribute: function() {
      },
      destroy: function() {
        var element2 = this.element;
        element2.off(Metro2.events.startAll);
        element2.off([Metro2.events.stopAll, Metro2.events.leave].join(" "));
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/timepicker/timepicker.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var TimePickerDefaultConfig = {
      label: "",
      timepickerDeferred: 0,
      hoursStep: 1,
      minutesStep: 1,
      secondsStep: 1,
      value: null,
      distance: 3,
      hours: true,
      minutes: true,
      seconds: true,
      showLabels: true,
      scrollSpeed: 4,
      copyInlineStyles: false,
      openMode: "auto",
      clsPicker: "",
      clsPart: "",
      clsHours: "",
      clsMinutes: "",
      clsSeconds: "",
      clsLabel: "",
      clsButton: "",
      clsOkButton: "",
      clsCancelButton: "",
      okButtonIcon: "\u2713",
      cancelButtonIcon: "\u{10102}",
      onSet: Metro2.noop,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onScroll: Metro2.noop,
      onTimePickerCreate: Metro2.noop
    };
    Metro2.timePickerSetup = function(options) {
      TimePickerDefaultConfig = $5.extend({}, TimePickerDefaultConfig, options);
    };
    if (typeof globalThis["metroTimePickerSetup"] !== "undefined") {
      Metro2.timePickerSetup(globalThis["metroTimePickerSetup"]);
    }
    Metro2.Component("time-picker", {
      init: function(options, elem) {
        this._super(elem, options, TimePickerDefaultConfig, {
          picker: null,
          isOpen: false,
          value: [],
          listTimer: {
            hours: null,
            minutes: null,
            seconds: null
          },
          id: Utils.elementId("time-picker")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        var i3;
        if (o2.distance < 1) {
          o2.distance = 1;
        }
        if (o2.hoursStep < 1) {
          o2.hoursStep = 1;
        }
        if (o2.hoursStep > 23) {
          o2.hoursStep = 23;
        }
        if (o2.minutesStep < 1) {
          o2.minutesStep = 1;
        }
        if (o2.minutesStep > 59) {
          o2.minutesStep = 59;
        }
        if (o2.secondsStep < 1) {
          o2.secondsStep = 1;
        }
        if (o2.secondsStep > 59) {
          o2.secondsStep = 59;
        }
        if (element2.val() === "" && !Utils.isValue(o2.value)) {
          o2.value = datetime().format("HH:mm:ss");
        }
        this.value = (element2.val() !== "" ? element2.val() : "" + o2.value).toArray(":");
        for (i3 = 0; i3 < 3; i3++) {
          if (this.value[i3] === void 0 || this.value[i3] === null) {
            this.value[i3] = 0;
          } else {
            this.value[i3] = parseInt(this.value[i3]);
          }
        }
        this._normalizeValue();
        this._createStructure();
        this._createEvents();
        this._set();
        this._fireEvent("time-picker-create", {
          element: element2
        });
      },
      _normalizeValue: function() {
        var o2 = this.options;
        if (o2.hoursStep > 1) {
          this.value[0] = Utils.nearest(this.value[0], o2.hoursStep, true);
        }
        if (o2.minutesStep > 1) {
          this.value[1] = Utils.nearest(this.value[1], o2.minutesStep, true);
        }
        if (o2.minutesStep > 1) {
          this.value[2] = Utils.nearest(this.value[2], o2.secondsStep, true);
        }
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options, strings = this.strings;
        var picker, hours, minutes, seconds, i3;
        var timeWrapper, selectWrapper, selectBlock, actionBlock;
        var id = Utils.elementId("timepicker");
        picker = $5("<div>").addClass("wheel-picker time-picker " + element2[0].className).addClass(o2.clsPicker);
        if (!picker.attr("id")) {
          picker.attr("id", id);
        }
        picker.insertBefore(element2);
        element2.attr("readonly", true).appendTo(picker);
        if (o2.label) {
          var label = $5("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(picker);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        timeWrapper = $5("<div>").addClass("time-wrapper").appendTo(picker);
        if (o2.hours === true) {
          hours = $5("<div>").attr("data-title", strings["label_hours"]).addClass("hours").addClass(o2.clsPart).addClass(o2.clsHours).appendTo(timeWrapper);
        }
        if (o2.minutes === true) {
          minutes = $5("<div>").attr("data-title", strings["label_minutes"]).addClass("minutes").addClass(o2.clsPart).addClass(o2.clsMinutes).appendTo(timeWrapper);
        }
        if (o2.seconds === true) {
          seconds = $5("<div>").attr("data-title", strings["label_seconds"]).addClass("seconds").addClass(o2.clsPart).addClass(o2.clsSeconds).appendTo(timeWrapper);
        }
        selectWrapper = $5("<div>").addClass("select-wrapper").appendTo(picker);
        selectBlock = $5("<div>").addClass("select-block").appendTo(selectWrapper);
        if (o2.hours === true) {
          hours = $5("<ul>").addClass("sel-hours").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
          for (i3 = 0; i3 < 24; i3 = i3 + o2.hoursStep) {
            $5("<li>").addClass("js-hours-" + i3).html(Str.lpad(i3, "0", 2)).data("value", i3).appendTo(hours);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
        }
        if (o2.minutes === true) {
          minutes = $5("<ul>").addClass("sel-minutes").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
          for (i3 = 0; i3 < 60; i3 = i3 + o2.minutesStep) {
            $5("<li>").addClass("js-minutes-" + i3).html(Str.lpad(i3, "0", 2)).data("value", i3).appendTo(minutes);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
        }
        if (o2.seconds === true) {
          seconds = $5("<ul>").addClass("sel-seconds").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
          for (i3 = 0; i3 < 60; i3 = i3 + o2.secondsStep) {
            $5("<li>").addClass("js-seconds-" + i3).html(Str.lpad(i3, "0", 2)).data("value", i3).appendTo(seconds);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $5("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
        }
        selectBlock.height((o2.distance * 2 + 1) * 40);
        actionBlock = $5("<div>").addClass("action-block").appendTo(selectWrapper);
        $5("<button>").attr("type", "button").addClass("button action-now").addClass(o2.clsButton).addClass(o2.clsTodayButton).html(`<span class="caption">${this.strings.label_now}</span>`).appendTo(actionBlock);
        $5("<button>").attr("type", "button").addClass("button action-ok").addClass(o2.clsButton).addClass(o2.clsOkButton).html(`<span class="icon">${o2.okButtonIcon}</span>`).appendTo(actionBlock);
        $5("<button>").attr("type", "button").addClass("button action-cancel").addClass(o2.clsButton).addClass(o2.clsCancelButton).html(`<span class="icon">${o2.cancelButtonIcon}</span>`).appendTo(actionBlock);
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          for (i3 = 0; i3 < element2[0].style.length; i3++) {
            picker.css(element2[0].style[i3], element2.css(element2[0].style[i3]));
          }
        }
        if (o2.showLabels === true) {
          picker.addClass("show-labels");
        }
        if (element2.prop("disabled")) {
          picker.addClass("disabled");
        }
        this.picker = picker;
      },
      _createEvents: function() {
        var that = this, o2 = this.options;
        var picker = this.picker;
        picker.on("touchstart", ".select-block ul", function(e2) {
          if (e2.changedTouches) {
            return;
          }
          var target = this;
          var pageY = Utils.pageXY(e2).y;
          $5(document).on(
            "touchmove",
            function(e3) {
              target.scrollTop -= o2.scrollSpeed * (pageY > Utils.pageXY(e3).y ? -1 : 1);
              pageY = Utils.pageXY(e3).y;
            },
            { ns: that.id }
          );
          $5(document).on(
            "touchend",
            function() {
              $5(document).off(Metro2.events.move, { ns: that.id });
              $5(document).off(Metro2.events.stop, { ns: that.id });
            },
            { ns: that.id }
          );
        });
        picker.on(Metro2.events.click, function(e2) {
          if (that.isOpen === false) that.open();
          e2.stopPropagation();
        });
        picker.on(Metro2.events.click, ".action-ok", function(e2) {
          var h3, m4, s3;
          var sh = picker.find(".sel-hours li.active"), sm = picker.find(".sel-minutes li.active"), ss = picker.find(".sel-seconds li.active");
          h3 = sh.length === 0 ? 0 : sh.data("value");
          m4 = sm.length === 0 ? 0 : sm.data("value");
          s3 = ss.length === 0 ? 0 : ss.data("value");
          that.value = [h3, m4, s3];
          that._normalizeValue();
          that._set();
          that.close();
          e2.stopPropagation();
        });
        picker.on(Metro2.events.click, ".action-cancel", function(e2) {
          that.close();
          e2.stopPropagation();
        });
        var scrollLatency = 150;
        $5.each(["hours", "minutes", "seconds"], function() {
          var part = this, list = picker.find(".sel-" + part);
          const scrollFn = Hooks.useDebounce(function(e2) {
            var target, targetElement, scrollTop;
            that.listTimer[part] = null;
            target = Math.round(Math.ceil(list.scrollTop()) / 40);
            if (part === "hours" && o2.hoursStep) {
              target *= parseInt(o2.hoursStep);
            }
            if (part === "minutes" && o2.minutesStep) {
              target *= parseInt(o2.minutesStep);
            }
            if (part === "seconds" && o2.secondsStep) {
              target *= parseInt(o2.secondsStep);
            }
            targetElement = list.find(".js-" + part + "-" + target);
            scrollTop = targetElement.position().top - o2.distance * 40;
            list.find(".active").removeClass("active");
            list[0].scrollTop = scrollTop;
            targetElement.addClass("active");
            Utils.exec(o2.onScroll, [targetElement, list, picker], list[0]);
          }, scrollLatency);
          list.on("scroll", scrollFn);
        });
        picker.on(Metro2.events.click, "ul li", function(e2) {
          const target = $5(this);
          const list = target.closest("ul");
          const scrollTop = target.position().top - o2.distance * 40;
          list.find(".active").removeClass("active");
          $5.animate({
            el: list[0],
            draw: {
              scrollTop
            },
            dur: 300
          });
          list[0].scrollTop = scrollTop;
          target.addClass("active");
          Utils.exec(o2.onScroll, [target, list, picker], list[0]);
        });
        picker.on(Metro2.events.click, ".action-now", function(e2) {
          const now = datetime();
          const hour = now.hour();
          const minute = now.minute();
          const second = now.second();
          picker.find(`.sel-hours li.js-hours-${hour}`).click();
          picker.find(`.sel-minutes li.js-minutes-${minute}`).click();
          picker.find(`.sel-seconds li.js-seconds-${second}`).click();
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _set: function() {
        var element2 = this.element, o2 = this.options;
        var picker = this.picker;
        var h3 = "00", m4 = "00", s3 = "00";
        if (o2.hours === true) {
          h3 = parseInt(this.value[0]);
          picker.find(".hours").html(Str.lpad(h3, "0", 2));
        }
        if (o2.minutes === true) {
          m4 = parseInt(this.value[1]);
          picker.find(".minutes").html(Str.lpad(m4, "0", 2));
        }
        if (o2.seconds === true) {
          s3 = parseInt(this.value[2]);
          picker.find(".seconds").html(Str.lpad(s3, "0", 2));
        }
        element2.val([h3, m4, s3].join(":")).trigger("change");
        this._fireEvent("set", {
          val: this.value,
          elementVal: element2.val()
        });
      },
      open: function() {
        var o2 = this.options;
        var picker = this.picker;
        var h3, m4, s3;
        var h_list, m_list, s_list;
        var items = picker.find("li");
        var select_wrapper = picker.find(".select-wrapper");
        var h_item, m_item, s_item;
        $5.each($5(".time-picker"), function() {
          $5(this).find("input").each(function() {
            Metro2.getPlugin(this, "timepicker").close();
          });
        });
        select_wrapper.show(0);
        items.removeClass("active");
        if (o2.openMode === "auto") {
          if (!Metro2.utils.inViewport(select_wrapper[0])) {
            select_wrapper.parent().addClass("drop-up-select");
          }
          if (!Metro2.utils.inViewport(select_wrapper[0])) {
            select_wrapper.parent().removeClass("drop-up-select");
            select_wrapper.parent().addClass("drop-as-dialog");
          }
        } else {
          if (o2.openMode === "dialog") {
            select_wrapper.parent().addClass("drop-as-dialog");
          } else if (o2.openMode === "up") {
            select_wrapper.parent().addClass("drop-up-select");
          }
        }
        var animateList = function(list, item) {
          list.scrollTop(0).animate({
            draw: {
              scrollTop: item.position().top - o2.distance * 40 + list.scrollTop()
            },
            dur: 100
          });
        };
        if (o2.hours === true) {
          h3 = parseInt(this.value[0]);
          h_list = picker.find(".sel-hours");
          h_item = h_list.find("li.js-hours-" + h3).addClass("active");
          animateList(h_list, h_item);
        }
        if (o2.minutes === true) {
          m4 = parseInt(this.value[1]);
          m_list = picker.find(".sel-minutes");
          m_item = m_list.find("li.js-minutes-" + m4).addClass("active");
          animateList(m_list, m_item);
        }
        if (o2.seconds === true) {
          s3 = parseInt(this.value[2]);
          s_list = picker.find(".sel-seconds");
          s_item = s_list.find("li.js-seconds-" + s3).addClass("active");
          animateList(s_list, s_item);
        }
        this.isOpen = true;
        this._fireEvent("open", {
          val: this.value
        });
      },
      close: function() {
        var picker = this.picker, o2 = this.options;
        picker.find(".select-wrapper").hide(0);
        if (o2.openMode === "auto") {
          picker.find(".select-wrapper").parent().removeClass("drop-up-select drop-as-dialog");
        }
        this.isOpen = false;
        this._fireEvent("close", {
          val: this.value
        });
      },
      _convert: function(t) {
        var result;
        if (Array.isArray(t)) {
          result = t;
        } else if (typeof t.getMonth === "function") {
          result = [t.getHours(), t.getMinutes(), t.getSeconds()];
        } else if (Utils.isObject(t)) {
          result = [t.h, t.m, t.s];
        } else {
          result = t.toArray(":");
        }
        return result;
      },
      val: function(t) {
        if (t === void 0) {
          return this.element.val();
        }
        this.value = this._convert(t);
        this._normalizeValue();
        this._set();
      },
      time: function(t) {
        if (t === void 0) {
          return {
            h: this.value[0],
            m: this.value[1],
            s: this.value[2]
          };
        }
        this.value = this._convert(t);
        this._normalizeValue();
        this._set();
      },
      date: function(t) {
        if (t === void 0 || typeof t.getMonth !== "function") {
          return datetime().hour(this.value[0]).minute(this.value[1]).second(this.value[2]).ms(0).val();
        }
        this.value = this._convert(t);
        this._normalizeValue();
        this._set();
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attr, newValue) {
        switch (attr) {
          case "data-value":
            this.val(newValue);
            break;
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element;
        var picker = this.picker;
        $5.each(["hours", "minutes", "seconds"], function() {
          picker.find(".sel-" + this).off("scroll");
        });
        picker.off(Metro2.events.start, ".select-block ul");
        picker.off(Metro2.events.click);
        picker.off(Metro2.events.click, ".action-ok");
        picker.off(Metro2.events.click, ".action-cancel");
        return element2;
      }
    });
    $5(document).on(Metro2.events.click, function() {
      $5.each($5(".time-picker"), function() {
        $5(this).find("input").each(function() {
          Metro2.getPlugin(this, "timepicker").close();
        });
      });
    });
  })(Metro, Dom);

  // source/components/toast/toast.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var ToastDefaultConfig = {
      callback: Metro2.noop,
      timeout: METRO_TIMEOUT,
      distance: 20,
      position: "bottom",
      // top, bottom, center
      clsToast: ""
    };
    Metro2.toastSetup = function(options) {
      ToastDefaultConfig = $5.extend({}, ToastDefaultConfig, options);
    };
    if (typeof globalThis["metroToastSetup"] !== "undefined") {
      Metro2.toastSetup(globalThis["metroToastSetup"]);
    }
    var Toast = {
      create: function(message, options) {
        var o2, toast, width;
        var args = Array.from(arguments);
        var timeout, callback, cls;
        if (!$5.isPlainObject(options)) {
          options = args[4];
          callback = args[1];
          timeout = args[2];
          cls = args[3];
        }
        o2 = $5.extend({}, ToastDefaultConfig, options);
        toast = $5("<div>").addClass("toast").html(message).appendTo($5("body"));
        width = toast.outerWidth();
        timeout = timeout || o2.timeout;
        callback = callback || o2.callback;
        cls = cls || o2.cls;
        if (o2.position === "top") {
          toast.addClass("show-top").css({
            top: o2.distance
          });
        } else if (o2.position === "center") {
          toast.addClass("show-center");
        } else {
          toast.css({
            bottom: o2.distance
          });
        }
        toast.css({
          "left": "50%",
          "margin-left": -(width / 2)
        }).addClass(o2.clsToast).addClass(cls).fadeIn(METRO_ANIMATION_DURATION, function() {
          setTimeout(function() {
            Toast.remove(toast, callback);
          }, timeout);
        });
      },
      remove: function(toast, cb) {
        if (!toast.length) return;
        toast.fadeOut(METRO_ANIMATION_DURATION, function() {
          toast.remove();
          Utils.exec(cb, null, toast[0]);
        });
      }
    };
    Metro2["toast"] = Toast;
    Metro2["createToast"] = Toast.create;
  })(Metro, Dom);

  // source/components/tokenizer/tokenizer.js
  (function(Metro2, $5) {
    "use strict";
    var TokenizerDefaultConfig = {
      textToTokenize: "",
      spaceSymbol: "",
      spaceClass: "space",
      tokenClass: "",
      splitter: "",
      tokenElement: "span",
      useTokenSymbol: true,
      useTokenIndex: true,
      clsTokenizer: "",
      clsToken: "",
      clsTokenOdd: "",
      clsTokenEven: "",
      onTokenCreate: Metro2.noop,
      onTokenize: Metro2.noop,
      onTokenizerCreate: Metro2.noop
    };
    Metro2.tokenizerSetup = function(options) {
      TokenizerDefaultConfig = $5.extend({}, TokenizerDefaultConfig, options);
    };
    if (typeof globalThis["metroTokenizerSetup"] !== "undefined") {
      Metro2.tokenizerSetup(globalThis["metroTokenizerSetup"]);
    }
    Metro2.Component("tokenizer", {
      init: function(options, elem) {
        this._super(elem, options, TokenizerDefaultConfig, {
          // define instance vars here
          originalText: ""
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        this.originalText = o2.textToTokenize ? o2.textToTokenize.trim() : element2.text().trim().replace(/[\r\n\t]/gi, "").replace(/\s\s+/g, " ");
        this._createStructure();
        this._fireEvent("tokenizer-create");
      },
      _tokenize: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var index = 0, append, prepend;
        element2.clear().attr("aria-label", this.originalText);
        $5.each(this.originalText.split(o2.splitter), function(i3) {
          var symbol = this;
          var isSpace = symbol === " ";
          var token;
          token = $5("<" + o2.tokenElement + ">").html(isSpace ? o2.spaceSymbol : symbol).attr("aria-hidden", true).addClass(isSpace ? o2.spaceClass : "").addClass(isSpace && o2.useTokenSymbol ? "" : "ts-" + symbol.replace(" ", "_")).addClass(isSpace && o2.useTokenIndex ? "" : "ti-" + (i3 + 1)).addClass(o2.tokenClass ? o2.tokenClass : "").addClass(!isSpace ? o2.clsToken : "");
          if (!isSpace) {
            index++;
            token.addClass(index % 2 === 0 ? "te-even" : "te-odd");
            token.addClass(index % 2 === 0 ? o2.clsTokenEven : o2.clsTokenOdd);
          }
          if (o2.prepend) {
            prepend = $5.isSelector(o2.prepend) ? $5(o2.prepend) : $5("<span>").html(o2.prepend);
            token.prepend(prepend);
          }
          if (o2.append) {
            append = $5.isSelector(o2.append) ? $5(o2.append) : $5("<span>").html(o2.append);
            token.append(append);
          }
          element2.append(token);
          that._fireEvent("token-create", {
            token: token[0]
          });
        });
        that._fireEvent("tokenize", {
          tokens: element2.children().items(),
          originalText: this.originalText
        });
      },
      _createStructure: function() {
        var element2 = this.element, o2 = this.options;
        element2.addClass(o2.clsTokenizer);
        this._tokenize();
      },
      tokenize: function(v4) {
        this.originalText = v4;
        this._tokenize();
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/treeview/treeview.js
  (function(Metro2, $5) {
    "use strict";
    let TreeViewDefaultConfig = {
      treeviewDeferred: 0,
      showChildCount: false,
      duration: 100,
      hideActionsOnLeave: true,
      recheckTimeout: 100,
      leaves: [],
      onNodeClick: Metro2.noop,
      onNodeDblClick: Metro2.noop,
      onNodeDelete: Metro2.noop,
      onNodeInsert: Metro2.noop,
      onNodeClean: Metro2.noop,
      onCheckClick: Metro2.noop,
      onRadioClick: Metro2.noop,
      onExpandNode: Metro2.noop,
      onCollapseNode: Metro2.noop,
      onTreeViewCreate: Metro2.noop
    };
    Metro2.treeViewSetup = function(options) {
      TreeViewDefaultConfig = $5.extend({}, TreeViewDefaultConfig, options);
    };
    if (typeof globalThis["metroTreeViewSetup"] !== "undefined") {
      Metro2.treeViewSetup(globalThis["metroTreeViewSetup"]);
    }
    Metro2.Component("tree-view", {
      init: function(options, elem) {
        this._super(elem, options, TreeViewDefaultConfig);
        return this;
      },
      _create: function() {
        const that = this, element2 = this.element;
        this._createTree();
        this._createEvents();
        $5.each(element2.find("input"), function() {
          if (!$5(this).is(":checked")) return;
          that._recheck(this);
        });
        this._fireEvent("tree-view-create", {
          element: element2
        });
      },
      _createIcon: function(data) {
        let icon, src;
        src = Metro2.utils.isTag(data) ? $5(data) : $5("<img src='' alt=''>").attr("src", data);
        icon = $5("<span>").addClass("icon");
        icon.html(src.outerHTML());
        return icon;
      },
      _createCaption: function(data, style) {
        const caption = $5("<span>").addClass("caption").html(data);
        if (style) {
          if (Metro2.utils.isObject(style)) {
            caption.css(style);
          } else if (typeof style === "string") {
            caption[0].style.cssText = style;
          }
        }
        return caption;
      },
      _createToggle: function() {
        return $5("<span>").addClass("node-toggle");
      },
      /*
      * data = {
      *   link: string,
      *   href: string,
      *   caption: string,
      *   icon: string,
      *   html: string,
      *   attributes: {},
      *   style: {} || string,
      *   badge: string,
      *   badges: [],
      *   secondary: string,
      *   actions: [],
      *   type: "" || "node",
      * }
      * */
      _createNode: function(data, target) {
        const o2 = this.options;
        const nodeContainer = target ? target : $5("<li>");
        const node = $5("<a>");
        nodeContainer.prepend(node);
        if (data.link || data.href) {
          node.attr("href", data.link || data.href);
        }
        if (data.caption) {
          node.prepend(this._createCaption(data.caption, data.style));
        }
        if (data.icon) {
          node.prepend(this._createIcon(data.icon));
        }
        if (data.html) {
          node.append(data.html);
        }
        if (data.attributes && $5.type(data.attributes) === "object") {
          for (let key in data.attributes) {
            node.attr(key, data.attributes[key]);
          }
        }
        if (data.style) {
          if (typeof data.style === "string") {
            node[0].style.cssText = data.style;
          } else if ($5.type(data.style) === "object") {
            node.css(data.style);
          }
        }
        if (data.badge) {
          const [badge, className] = data.badge.split(":");
          node.append(
            $5("<span>").addClass("badge").addClass(className).html(badge)
          );
        }
        if (data.badges) {
          $5.each(typeof data.badges === "string" ? data.badges.toArray(",") : Array.isArray(data.badges) ? data.badges : [], function(_4, item) {
            const [badge, className] = item.split(":");
            node.append(
              $5("<span>").addClass("badge").addClass(className).html(badge)
            );
          });
        }
        if (data.secondary) {
          const [badge, className] = data.secondary.split(":");
          node.append(
            $5("<span>").addClass("secondary-text").addClass(className).html(badge)
          );
        }
        if (data.actions) {
          const actionsHolder = $5("<div class='dropdown-button'>").addClass("actions-holder");
          const actionsListTrigger = $5("<span class='actions-list-trigger'>").text("\u22EE").appendTo(actionsHolder);
          const actionsList = $5("<ul data-role='dropmenu' class='d-menu actions-list'>").appendTo(actionsHolder);
          nodeContainer.append(actionsHolder);
          for (let a3 of data.actions) {
            if (a3.type && a3.type === "divider") {
              $5("<li>").addClass("divider").appendTo(actionsList);
            } else {
              const icon = a3.icon ? $5(a3.icon).addClass("icon").outerHTML() : "";
              const caption = `<span class="caption">${a3.caption}</span>`;
              const li = $5(`<li><a href="#">${icon} ${caption}</a></li>`).appendTo(actionsList);
              if (a3.cls) {
                li.addClass(a3.cls);
              }
              li.find("a").on("click", function() {
                Metro2.utils.exec(a3.onclick, [li[0]], this);
              });
            }
          }
          actionsList.on(Metro2.events.leave, (e2) => {
            if (o2.hideActionsOnLeave) Metro2.getPlugin(actionsList, "dropmenu").close();
          });
        }
        if (data.current) {
          nodeContainer.addClass("current");
        }
        if (data.type === "node") {
          nodeContainer.addClass("tree-node");
          nodeContainer.append($5("<span>").addClass("node-toggle"));
          nodeContainer.append($5("<ul>"));
        }
        if (nodeContainer.children("ul").length) {
          nodeContainer.addClass("tree-node");
          nodeContainer.append($5("<span>").addClass("node-toggle"));
          if (Metro2.utils.bool(data.collapsed) !== true) {
            nodeContainer.addClass("expanded");
          } else {
            nodeContainer.children("ul").hide();
          }
        }
        return nodeContainer;
      },
      _createCheckNode: function(data, target) {
        const node = target ? target : $5("<li>");
        node.append(`
                <input data-role="${data.type}" type="${data.type ?? "checkbox"}" name="${data.name}" value="${data.value ?? ""}" ${data.checked ? "checked" : ""} data-append="${data.caption}"/>
            `);
        if (data.icon) {
          node.find("label").prepend(this._createIcon(data.icon));
        }
        if (data.attributes && $5.type(data.attributes) === "object") {
          for (let key in data.attributes) {
            node.attr(key, data.attributes[key]);
          }
        }
        if (data.secondary) {
          const [badge, className] = data.secondary.split(":");
          node.find("label").append(
            $5("<span>").addClass("secondary-text").addClass(className).html(badge)
          );
        }
        return node;
      },
      _createInputNode: function(data, target) {
        const node = target ? target : $5("<li>");
        node.append(`
                <input data-role="${data.type}" type="${data.type ?? "text"}" name="${data.name}" value="${data.value ?? ""}" data-prepend="${data.caption ?? ""}" placeholder="${data.placeholder ?? ""}"/>
            `);
        if (data.secondary) {
          const [badge, className] = data.secondary.split(":");
          node.find("label").append(
            $5("<span>").addClass("secondary-text").addClass(className).html(badge)
          );
        }
        return node;
      },
      _createTree: function() {
        const element2 = this.element, o2 = this.options;
        const nodes = element2.find("li[data-caption]");
        element2.addClass("treeview");
        $5.each(nodes, (i3, _el) => {
          const el = $5(_el);
          if (el.data("type") === "checkbox" || el.data("type") === "radio") {
            this._createCheckNode({
              caption: el.data("caption"),
              icon: el.data("icon"),
              type: el.data("type"),
              name: el.data("name"),
              attributes: el.data("attributes"),
              value: el.data("value"),
              checked: el.data("checked") === "true",
              secondary: el.data("secondary")
            }, el);
          } else if (el.data("type") === "input") {
            this._createInputNode({
              caption: el.data("caption"),
              type: el.data("type"),
              name: el.data("name"),
              attributes: el.data("attributes"),
              value: el.data("value"),
              secondary: el.data("secondary"),
              placeholder: el.data("placeholder")
            }, el);
          } else {
            this._createNode({
              caption: el.data("caption"),
              icon: el.data("icon"),
              html: el.data("html"),
              attributes: el.data("attributes"),
              badge: el.data("badge"),
              badges: el.data("badges"),
              actions: el.data("actions"),
              type: el.data("type"),
              collapsed: el.data("collapsed"),
              link: el.data("link"),
              href: el.data("href"),
              secondary: el.data("secondary"),
              style: el.data("style")
            }, el);
          }
        });
        if (o2.leaves) {
          const leaves = Metro2.utils.isObject(o2.leaves);
          if (leaves) {
            this.fillTree(leaves);
          }
        }
        this._recheckTree();
      },
      _createEvents: function() {
        const that = this, element2 = this.element;
        element2.on(Metro2.events.click, ".node-toggle", function(e2) {
          const toggle = $5(this);
          const node = toggle.parent();
          that.toggleNode(node);
          e2.preventDefault();
        });
        element2.on(Metro2.events.click, "a", function(e2) {
          const node = $5(this).parent();
          that.current(node);
          that._fireEvent("node-click", {
            node: node[0]
          });
          e2.preventDefault();
        });
        element2.on(Metro2.events.dblclick, "a", function(e2) {
          const node = $5(this).closest("li");
          const toggle = node.children(".node-toggle");
          const subtree = node.children("ul");
          if (toggle.length > 0 || subtree.length > 0) {
            that.toggleNode(node);
          }
          that._fireEvent("node-dbl-click", {
            node: node[0]
          });
          e2.preventDefault();
        });
        element2.on(Metro2.events.click, "input[type=radio]", function() {
          const check = $5(this);
          const checked = check.is(":checked");
          const node = check.closest("li");
          that.current(node);
          that._fireEvent("radio-click", {
            checked,
            check: check[0],
            node: node[0]
          });
        });
        element2.on(Metro2.events.click, "input[type=checkbox]", function() {
          const check = $5(this);
          const checked = check.is(":checked");
          const node = check.closest("li");
          that._recheck(check);
          that._fireEvent("check-click", {
            checked,
            check: check[0],
            node: node[0]
          });
        });
      },
      _recheck: function(check) {
        let node;
        check = $5(check);
        const checked = check.is(":checked");
        node = check.closest("li");
        this.current(node);
        const checks = check.closest("li").find("ul input[type=checkbox]");
        checks.attr("data-indeterminate", false);
        checks.prop("indeterminate", false);
        checks.prop("checked", checked);
        checks.trigger("change");
        this._recheckTree();
      },
      _recheckTree: function(timeout) {
        setTimeout(() => {
          const element2 = this.element;
          const all_checks = element2.find("input[type=checkbox]").reverse();
          $5.each(all_checks.reverse(), function() {
            const ch = $5(this);
            const children = ch.closest("li").children("ul").find("input[type=checkbox]").length;
            const children_checked = ch.closest("li").children("ul").find("input[type=checkbox]").filter(function(el) {
              return el.checked;
            }).length;
            if (children > 0 && children_checked === 0) {
              ch.attr("data-indeterminate", false);
              ch.prop("indeterminate", false);
              ch.prop("checked", false);
              ch.trigger("change");
            }
            if (children_checked === 0) {
              ch.attr("data-indeterminate", false);
              ch.prop("indeterminate", false);
            } else {
              if (children_checked > 0 && children > children_checked) {
                ch.attr("data-indeterminate", true);
                ch.prop("indeterminate", true);
              } else if (children === children_checked) {
                ch.attr("data-indeterminate", false);
                ch.prop("indeterminate", false);
                ch.prop("checked", true);
                ch.trigger("change");
              }
            }
          });
        }, timeout ?? this.options.recheckTimeout);
      },
      current: function(node) {
        const element2 = this.element;
        if (!node) {
          return element2.find(".current");
        }
        element2.find(".current").removeClass("current");
        node.addClass("current");
      },
      toggleNode: function(n2) {
        const node = $5(n2);
        const o2 = this.options;
        let func;
        const toBeExpanded = !node.data("collapsed");
        node.toggleClass("expanded");
        node.data("collapsed", toBeExpanded);
        func = toBeExpanded === true ? "slideUp" : "slideDown";
        if (!toBeExpanded) {
          this._fireEvent("expand-node", {
            node: node[0]
          });
        } else {
          this._fireEvent("collapse-node", {
            node: node[0]
          });
        }
        node.children("ul")[func](o2.duration);
      },
      addTo: function(node, data) {
        const element2 = this.element;
        let target;
        let new_node;
        let toggle;
        if (!node) {
          target = element2;
        } else {
          node = $5(node);
          target = node.children("ul");
          if (target.length === 0) {
            target = $5("<ul>").appendTo(node);
            toggle = this._createToggle();
            toggle.appendTo(node);
            node.addClass("expanded");
          }
          node?.addClass("tree-node");
        }
        if (data.type === "checkbox" || data.type === "radio") {
          new_node = this._createCheckNode(data);
        } else if (data.type === "input") {
          new_node = this._createInputNode(data);
        } else {
          new_node = this._createNode(data);
        }
        new_node.appendTo(target);
        this._fireEvent("node-insert", {
          node: new_node[0],
          parent: node ? node[0] : null
        });
        this._recheckTree();
        return new_node;
      },
      insertBefore: function(node, data) {
        const new_node = this._createNode(data);
        if (Metro2.utils.isNull(node)) {
          return this.addTo(node, data);
        }
        node = $5(node);
        new_node.insertBefore(node);
        this._fireEvent("node-insert", {
          node: new_node[0],
          parent: node ? node[0] : null
        });
        return new_node;
      },
      insertAfter: function(node, data) {
        const new_node = this._createNode(data);
        if (Metro2.utils.isNull(node)) {
          return this.addTo(node, data);
        }
        node = $5(node);
        new_node.insertAfter(node);
        this._fireEvent("node-insert", {
          node: new_node[0],
          parent: node[0]
        });
        return new_node;
      },
      del: function(node) {
        const element2 = this.element;
        node = $5(node);
        const parent_list = node.closest("ul");
        const parent_node = parent_list.closest("li");
        this._fireEvent("node-delete", {
          node: node[0]
        });
        node.remove();
        if (parent_list.children().length === 0 && !parent_list.is(element2)) {
          parent_list.remove();
          parent_node.removeClass("expanded");
          parent_node.children(".node-toggle").remove();
        }
        this._recheckTree();
      },
      clean: function(node) {
        node = $5(node);
        node.children("ul").remove();
        node.removeClass("expanded");
        node.children(".node-toggle").remove();
        this._fireEvent("node-clean", {
          node: node[0]
        });
      },
      collapseNode(node) {
        const o2 = this.options;
        node = $5(node);
        node.removeClass("expanded");
        node.data("collapsed", true);
        node.children("ul")["slideUp"](o2.duration);
        this._fireEvent("collapse-node", {
          node: node[0]
        });
      },
      expandNode(node) {
        const o2 = this.options;
        node = $5(node);
        if (!node.hasClass("tree-node")) {
          return;
        }
        node.addClass("expanded");
        node.data("collapsed", false);
        node.children("ul")["slideDown"](o2.duration);
        this._fireEvent("expand-node", {
          node: node[0]
        });
      },
      collapseAll() {
        const element2 = this.element, o2 = this.options;
        element2.find(".expanded").each((_4, el) => {
          const node = $5(el);
          let func;
          const toBeExpanded = !node.data("collapsed");
          node.toggleClass("expanded");
          node.data("collapsed", toBeExpanded);
          func = toBeExpanded === true ? "slideUp" : "slideDown";
          if (!toBeExpanded) {
            this._fireEvent("expand-node", {
              node: node[0]
            });
          } else {
            this._fireEvent("collapse-node", {
              node: node[0]
            });
          }
          node.children("ul")[func](o2.duration);
        });
        this._fireEvent("collapse-all");
      },
      expandAll() {
        const element2 = this.element, o2 = this.options;
        element2.find(".tree-node:not(.expanded)").each((_4, el) => {
          const node = $5(el);
          let func;
          const toBeExpanded = !node.data("collapsed");
          node.toggleClass("expanded");
          node.data("collapsed", toBeExpanded);
          func = toBeExpanded === true ? "slideUp" : "slideDown";
          if (!toBeExpanded) {
            this._fireEvent("expand-node", {
              node: node[0]
            });
          } else {
            this._fireEvent("collapse-node", {
              node: node[0]
            });
          }
          node.children("ul")[func](o2.duration);
        });
        this._fireEvent("expand-all");
      },
      fillTree: function(leaves, node) {
        for (const leaf of leaves) {
          const new_node = this.addTo(node, {
            ...leaf,
            type: leaf.items ? "node" : "item"
          });
          if (leaf.items) {
            this.fillTree(leaf.items, new_node);
          }
        }
      },
      changeAttribute: function(attr, value) {
        if (attr === "data-recheck-timeout") {
          this.options.recheckTimeout = value ?? 100;
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".node-toggle");
        element2.off(Metro2.events.click, "li > .caption");
        element2.off(Metro2.events.dblclick, "li > .caption");
        element2.off(Metro2.events.click, "input[type=radio]");
        element2.off(Metro2.events.click, "input[type=checkbox]");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/validator/validator.js
  (function(Metro2, $5) {
    "use strict";
    var ValidatorFuncs = {
      required: function(val) {
        return G.safeParse(G.required(), val).ok;
      },
      length: function(val, len) {
        return G.safeParse(G.length(+len), val).ok;
      },
      minlength: function(val, len) {
        return G.safeParse(G.minLength(+len), val).ok;
      },
      maxlength: function(val, len) {
        return G.safeParse(G.maxLength(+len), val).ok;
      },
      min: function(val, min_value) {
        return G.safeParse(G.minValue(+min_value), +val).ok;
      },
      max: function(val, max_value) {
        return G.safeParse(G.maxValue(+max_value), +val).ok;
      },
      email: function(val) {
        return G.safeParse(G.email(), val).ok;
      },
      domain: function(val) {
        return G.safeParse(G.domain(), val).ok;
      },
      url: function(val) {
        return G.safeParse(G.url(), val).ok;
      },
      date: function(val, format, locale) {
        try {
          if (!format) {
            datetime(val);
          } else {
            Datetime.from(val, format, locale);
          }
          return true;
        } catch (e2) {
          return false;
        }
      },
      number: function(val) {
        return G.safeParse(G.number(), +val).ok;
      },
      integer: function(val) {
        return G.safeParse(G.integer(), +val).ok;
      },
      safeInteger: function(val) {
        return G.safeParse(G.safeInteger(), +val).ok;
      },
      float: function(val) {
        return G.safeParse(G.float(), +val).ok;
      },
      digits: function(val) {
        return G.safeParse(G.digits(), val).ok;
      },
      hexcolor: function(val) {
        return G.safeParse(G.hexColor(), val).ok;
      },
      color: function(val) {
        if (!Metro2.utils.isValue(val)) return false;
        return Farbe.Palette.color(val, Farbe.StandardColors) || Farbe.Routines.isColor(val);
      },
      pattern: function(val, pat) {
        return G.safeParse(G.pattern(pat), val).ok;
      },
      compare: function(val, val2) {
        return val == val2;
      },
      not: function(val, not_this) {
        return val != not_this;
      },
      notequals: function(val, val2) {
        return val !== val2;
      },
      equals: function(val, val2) {
        return val === val2;
      },
      custom: function(val, func) {
        if (Metro2.utils.isFunc(func) === false) {
          return false;
        }
        return Metro2.utils.exec(func, [val]);
      },
      is_control: function(el) {
        return el.attr("data-role");
      },
      reset_state: function(el) {
        var input = $5(el);
        var is_control = ValidatorFuncs.is_control(input);
        if (is_control) {
          input.parent().removeClass("invalid valid");
        } else {
          input.removeClass("invalid valid");
        }
      },
      set_valid_state: function(el) {
        var input = $5(el);
        var is_control = ValidatorFuncs.is_control(input);
        if (is_control) {
          input.parent().addClass("valid");
        } else {
          input.addClass("valid");
        }
      },
      set_invalid_state: function(el) {
        var input = $5(el);
        var is_control = ValidatorFuncs.is_control(input);
        if (is_control) {
          input.parent().addClass("invalid");
        } else {
          input.addClass("invalid");
        }
      },
      reset: function(form) {
        var that = this;
        $5.each($5(form).find("[data-validate]"), function() {
          that.reset_state(this);
        });
        return this;
      },
      validate: function(el, result, cb_ok, cb_error, required_mode) {
        var this_result = true;
        var input = $5(el);
        var funcs = input.data("validate") !== void 0 ? String(input.data("validate")).split(" ").map(function(s3) {
          return s3.trim();
        }) : [];
        var errors = [];
        var hasForm = input.closest("form").length > 0;
        var attr_name, radio_checked;
        if (funcs.length === 0) {
          return true;
        }
        this.reset_state(input);
        if (input.attr("type") && input.attr("type").toLowerCase() === "checkbox") {
          if (funcs.indexOf("required") === -1) {
            this_result = true;
          } else {
            this_result = input.is(":checked");
          }
          if (this_result === false) {
            errors.push("required");
          }
          if (result !== void 0) {
            result.val += this_result ? 0 : 1;
          }
        } else if (input.attr("type") && input.attr("type").toLowerCase() === "radio") {
          attr_name = input.attr("name");
          if (typeof attr_name === void 0) {
            this_result = true;
          } else {
            radio_checked = $5("input[name=" + attr_name.replace("[", "\\[").replace("]", "\\]") + "]:checked");
            this_result = radio_checked.length > 0;
          }
          if (result !== void 0) {
            result.val += this_result ? 0 : 1;
          }
        } else {
          $5.each(funcs, function() {
            if (this_result === false) return;
            var rule = this.split("=");
            var f5, a3, b4;
            f5 = rule[0];
            rule.shift();
            a3 = rule.join("=");
            if (["compare", "not", "equals", "notequals"].indexOf(f5) > -1) {
              a3 = hasForm ? input[0].form.elements[a3].value : $5("[name=" + a3 + "]").val();
            }
            if (f5 === "date") {
              a3 = input.attr("data-value-format");
              b4 = input.attr("data-value-locale");
            }
            if (Metro2.utils.isFunc(ValidatorFuncs[f5]) === false) {
              this_result = true;
            } else {
              if (required_mode === true || f5 === "required") {
                this_result = ValidatorFuncs[f5](input.val(), a3, b4);
              } else {
                if (input.val().trim() !== "") {
                  this_result = ValidatorFuncs[f5](input.val(), a3, b4);
                } else {
                  this_result = true;
                }
              }
            }
            if (this_result === false) {
              errors.push(f5);
            }
            if (result !== void 0) {
              result.val += this_result ? 0 : 1;
            }
          });
        }
        if (this_result === false) {
          this.set_invalid_state(input);
          if (result !== void 0) {
            result.log.push({
              input: input[0],
              name: input.attr("name"),
              value: input.val(),
              funcs,
              errors
            });
          }
          if (cb_error !== void 0) Metro2.utils.exec(cb_error, [input, input.val()], input[0]);
        } else {
          this.set_valid_state(input);
          if (cb_ok !== void 0) Metro2.utils.exec(cb_ok, [input, input.val()], input[0]);
        }
        return this_result;
      }
    };
    Metro2["validator"] = ValidatorFuncs;
    var ValidatorDefaultConfig = {
      validatorDeferred: 0,
      submitTimeout: 200,
      interactiveCheck: false,
      clearInvalid: 0,
      requiredMode: true,
      useRequiredClass: true,
      onBeforeSubmit: Metro2.noop_true,
      onSubmit: Metro2.noop,
      onError: Metro2.noop,
      onValidate: Metro2.noop,
      onErrorForm: Metro2.noop,
      onValidateForm: Metro2.noop,
      onValidatorCreate: Metro2.noop
    };
    Metro2.validatorSetup = function(options) {
      ValidatorDefaultConfig = $5.extend({}, ValidatorDefaultConfig, options);
    };
    if (typeof globalThis["metroValidatorSetup"] !== "undefined") {
      Metro2.validatorSetup(globalThis["metroValidatorSetup"]);
    }
    Metro2.Component("validator", {
      init: function(options, elem) {
        this._super(elem, options, ValidatorDefaultConfig, {
          _onsubmit: null,
          _onreset: null,
          result: []
        });
        return this;
      },
      _create: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var inputs = element2.find("[data-validate]");
        element2.attr("novalidate", "novalidate");
        $5.each(inputs, function() {
          var input = $5(this);
          var funcs = input.data("validate");
          var required2 = funcs.indexOf("required") > -1;
          if (required2 && o2.useRequiredClass === true) {
            if (ValidatorFuncs.is_control(input)) {
              input.parent().addClass("required");
            } else {
              input.addClass("required");
            }
          }
          if (o2.interactiveCheck === true) {
            input.on(Metro2.events.inputchange, function() {
              ValidatorFuncs.validate(this, void 0, void 0, void 0, o2.requiredMode);
            });
          }
        });
        this._onsubmit = null;
        this._onreset = null;
        if (element2[0].onsubmit !== null) {
          this._onsubmit = element2[0].onsubmit;
          element2[0].onsubmit = null;
        }
        if (element2[0].onreset !== null) {
          this._onreset = element2[0].onreset;
          element2[0].onreset = null;
        }
        element2[0].onsubmit = function() {
          return that._submit();
        };
        element2[0].onreset = function() {
          return that._reset();
        };
        this._fireEvent("validator-create", {
          element: element2
        });
      },
      _reset: function() {
        ValidatorFuncs.reset(this.element);
        if (this._onreset !== null) Metro2.utils.exec(this._onreset, null, this.element[0]);
      },
      _submit: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var form = this.elem;
        var inputs = element2.find("[data-validate]");
        var submit = element2.find("input[type=submit], button[type=submit]");
        var result = {
          val: 0,
          log: []
        };
        var formData = $5.serializeToArray(element2);
        if (submit.length > 0) {
          submit.attr("disabled", "disabled").addClass("disabled");
        }
        $5.each(inputs, function() {
          ValidatorFuncs.validate(this, result, o2.onValidate, o2.onError, o2.requiredMode);
        });
        submit.removeAttr("disabled").removeClass("disabled");
        result.val += Metro2.utils.exec(o2.onBeforeSubmit, [formData], this.elem) === false ? 1 : 0;
        if (result.val === 0) {
          this._fireEvent("validate-form", {
            data: formData
          });
          setTimeout(function() {
            Metro2.utils.exec(o2.onSubmit, [formData], form);
            element2.fire("formsubmit", {
              data: formData
            });
            if (that._onsubmit !== null) Metro2.utils.exec(that._onsubmit, null, form);
          }, o2.submitTimeout);
        } else {
          this._fireEvent("error-form", {
            log: result.log,
            data: formData
          });
          if (o2.clearInvalid > 0) {
            setTimeout(function() {
              $5.each(inputs, function() {
                var inp = $5(this);
                if (ValidatorFuncs.is_control(inp)) {
                  inp.parent().removeClass("invalid");
                } else {
                  inp.removeClass("invalid");
                }
              });
            }, o2.clearInvalid);
          }
        }
        return result.val === 0;
      },
      changeAttribute: function() {
      }
    });
  })(Metro, Dom);

  // source/components/vegas/vegas.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var VegasDefaultConfig = {
      duration: 4e3,
      animationDuration: null,
      transitionDuration: null,
      transition: "fade",
      animation: null,
      slides: [],
      shuffle: false,
      align: "center",
      valign: "center",
      loop: true,
      autoplay: true,
      mute: true,
      cover: true,
      preload: true,
      timer: true,
      overlay: 2,
      color: null,
      volume: 1,
      onPlay: Metro2.noop,
      onPause: Metro2.noop,
      onEnd: Metro2.noop,
      onWalk: Metro2.noop,
      onNext: Metro2.noop,
      onPrev: Metro2.noop,
      onJump: Metro2.noop,
      onVegasCreate: Metro2.noop
    };
    Metro2.vegasSetup = function(options) {
      VegasDefaultConfig = $5.extend({}, VegasDefaultConfig, options);
    };
    if (typeof globalThis["metroVegasSetup"] !== "undefined") {
      Metro2.vegasSetup(globalThis["metroVegasSetup"]);
    }
    Metro2.Component("vegas", {
      videoCache: {},
      init: function(options, elem) {
        this.transitions = [
          "fade",
          "fade2",
          "slideLeft",
          "slideLeft2",
          "slideRight",
          "slideRight2",
          "slideUp",
          "slideUp2",
          "slideDown",
          "slideDown2",
          "zoomIn",
          "zoomIn2",
          "zoomOut",
          "zoomOut2",
          "swirlLeft",
          "swirlLeft2",
          "swirlRight",
          "swirlRight2"
        ];
        this.animations = [
          "kenburns",
          "kenburnsUp",
          "kenburnsDown",
          "kenburnsRight",
          "kenburnsLeft",
          "kenburnsUpLeft",
          "kenburnsUpRight",
          "kenburnsDownLeft",
          "kenburnsDownRight"
        ];
        this.support = {
          objectFit: "objectFit" in document.body.style,
          video: !/(Android|webOS|Phone|iPad|iPod|BlackBerry|Windows Phone)/i.test(navigator.userAgent)
        };
        this._super(elem, options, VegasDefaultConfig, {
          slide: 0,
          slides: null,
          total: 0,
          noshow: false,
          paused: false,
          ended: false,
          timer: null,
          overlay: null,
          first: true,
          timeout: false
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        this.slides = Utils.isObject(o2.slides) || [];
        this.total = this.slides.length;
        this.noshow = this.total < 2;
        this.paused = !o2.autoplay || this.noshow;
        if (o2.shuffle) {
          this.slides.shuffle();
        }
        if (o2.preload) {
          this._preload();
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("vegas-create", {
          element: element2
        });
      },
      _createStructure: function() {
        var that = this, element2 = this.element, o2 = this.options;
        var isBody = element2[0].tagName === "BODY";
        var wrapper;
        if (!isBody) {
          element2.css("height", element2.css("height"));
          wrapper = $5('<div class="vegas-wrapper">').css("overflow", element2.css("overflow")).css("padding", element2.css("padding"));
          if (!element2.css("padding")) {
            wrapper.css("padding-top", element2.css("padding-top")).css("padding-bottom", element2.css("padding-bottom")).css("padding-left", element2.css("padding-left")).css("padding-right", element2.css("padding-right"));
          }
          element2.children().appendTo(wrapper);
          element2.clear();
        }
        element2.addClass("vegas-container");
        if (!isBody) {
          element2.append(wrapper);
        }
        if (o2.timer) {
          this.timer = $5('<div class="vegas-timer"><div class="vegas-timer-progress">');
          element2.append(this.timer);
        }
        if (o2.overlay) {
          this.overlay = $5('<div class="vegas-overlay">').addClass("overlay" + (typeof o2.overlay === "boolean" || isNaN(o2.overlay) ? 2 : +o2.overlay));
          element2.append(this.overlay);
        }
        setTimeout(function() {
          Utils.exec(o2.onPlay, null, element2[0]);
          that._goto(that.slide);
        }, 1);
      },
      _createEvents: function() {
      },
      _preload: function() {
        var img, i3;
        for (i3 = 0; i3 < this.slides.length; i3++) {
          var obj = this.slides[i3];
          if (obj.src) {
            img = new Image();
            img.src = this.slides[i3].src;
          }
          if (obj.video) {
            if (obj.video instanceof Array) {
              this._video(obj.video);
            } else {
              this._video(obj.video.src);
            }
          }
        }
      },
      _slideShow: function() {
        var that = this, o2 = this.options;
        if (this.total > 1 && !this.ended && !this.paused && !this.noshow) {
          this.timeout = setTimeout(function() {
            that.next();
          }, o2.duration);
        }
      },
      _timer: function(state2) {
        var that = this, o2 = this.options;
        clearTimeout(this.timeout);
        if (!this.timer) {
          return;
        }
        this.timer.removeClass("vegas-timer-running").find("div").css("transition-duration", "0ms");
        if (this.ended || this.paused || this.noshow) {
          return;
        }
        if (state2) {
          setTimeout(function() {
            that.timer.addClass("vegas-timer-running").find("div").css("transition-duration", +o2.duration - 100 + "ms");
          }, 100);
        }
      },
      _fadeSoundIn: function(video, duration) {
        var o2 = this.options;
        $5.animate({
          el: video,
          draw: {
            volume: +o2.volume
          },
          dur: duration
        });
      },
      _fadeSoundOut: function(video, duration) {
        $5.animate({
          el: video,
          draw: {
            volume: 0
          },
          dur: duration
        });
      },
      _video: function(sources) {
        var video, source;
        var cacheKey = sources.toString();
        if (this.videoCache[cacheKey]) {
          return this.videoCache[cacheKey];
        }
        if (!Array.isArray(sources)) {
          sources = [sources];
        }
        video = document.createElement("video");
        video.preload = true;
        sources.forEach(function(src) {
          source = document.createElement("source");
          source.src = src;
          video.appendChild(source);
        });
        this.videoCache[cacheKey] = video;
        return video;
      },
      _goto: function(n2) {
        var that = this, element2 = this.element, o2 = this.options;
        if (typeof this.slides[n2] === "undefined") {
          n2 = 0;
        }
        this.slide = n2;
        var $slide, $inner, video, img, $video;
        var slides = element2.children(".vegas-slide");
        var obj = this.slides[n2];
        var cover = o2.cover;
        var transition, animation;
        var transitionDuration, animationDuration;
        if (this.first) {
          this.first = false;
        }
        if (cover !== "repeat") {
          if (cover === true) {
            cover = "cover";
          } else if (cover === false) {
            cover = "contain";
          }
        }
        if (o2.transition === "random") {
          transition = $5.random(this.transitions);
        } else {
          transition = o2.transition ? o2.transition : this.transitions[0];
        }
        if (o2.animation === "random") {
          animation = $5.random(this.animations);
        } else {
          animation = o2.animation ? o2.animation : this.animations[0];
        }
        if (!o2.transitionDuration) {
          transitionDuration = +o2.duration;
        } else if (o2.transitionDuration === "auto" || +o2.transitionDuration > +o2.duration) {
          transitionDuration = +o2.duration;
        } else {
          transitionDuration = +o2.transitionDuration;
        }
        if (!o2.animationDuration) {
          animationDuration = +o2.duration;
        } else if (o2.animationDuration === "auto" || +o2.animationDuration > +o2.duration) {
          animationDuration = +o2.duration;
        } else {
          animationDuration = +o2.animationDuration;
        }
        $slide = $5("<div>").addClass("vegas-slide").addClass("vegas-transition-" + transition);
        if (this.support.video && obj.video) {
          video = obj.video instanceof Array ? this._video(obj.video) : this._video(obj.video.src);
          video.loop = obj.video.loop ? obj.video.loop : o2.loop;
          video.muted = obj.video.mute ? obj.video.mute : o2.mute;
          if (!video.muted) {
            this._fadeSoundIn(video, transitionDuration);
          } else {
            video.pause();
          }
          $video = $5(video).addClass("vegas-video").css("background-color", o2.color || "#000000");
          if (this.support.objectFit) {
            $video.css("object-position", o2.align + " " + o2.valign).css("object-fit", cover).css("width", "100%").css("height", "100%");
          } else if (cover === "contain") {
            $video.css("width", "100%").css("height", "100%");
          }
          $slide.append($video);
        } else {
          img = new Image();
          $inner = $5("<div>").addClass("vegas-slide-inner").css({
            backgroundImage: 'url("' + obj.src + '")',
            backgroundColor: o2.color || "#000000",
            backgroundPosition: o2.align + " " + o2.valign
          });
          if (cover === "repeat") {
            $inner.css("background-repeat", "repeat");
          } else {
            $inner.css("background-size", cover);
          }
          if (animation) {
            $inner.addClass("vegas-animation-" + animation).css("animation-duration", animationDuration + "ms");
          }
          $slide.append($inner);
        }
        if (slides.length) {
          slides.eq(slides.length - 1).after($slide);
        } else {
          element2.prepend($slide);
        }
        slides.css("transition", "all 0ms").each(
          function() {
            this.className = "vegas-slide";
            if (this.tagName === "VIDEO") {
              this.className += " vegas-video";
            }
            if (transition) {
              this.className += " vegas-transition-" + transition;
              this.className += " vegas-transition-" + transition + "-in";
            }
          }
        );
        this._timer(false);
        function go2() {
          that._timer(true);
          setTimeout(function() {
            slides.css("transition", "all " + transitionDuration + "ms").addClass("vegas-transition-" + transition + "-out");
            slides.each(function() {
              var video2 = slides.find("video").get(0);
              if (video2) {
                video2.volume = 1;
                that._fadeSoundOut(video2, transitionDuration);
              }
            });
            $slide.css("transition", "all " + transitionDuration + "ms").addClass("vegas-transition-" + transition + "-in");
            for (var i3 = 0; i3 < slides.length - 1; i3++) {
              slides.eq(i3).remove();
            }
            that._fireEvent("walk", {
              slide: that.current(true)
            });
            that._slideShow();
          }, 100);
        }
        if (video) {
          if (video.readyState === 4) {
            video.currentTime = 0;
          }
          video.play();
          go2();
        } else {
          img.src = obj.src;
          if (img.complete) {
            go2();
          } else {
            img.onload = go2;
          }
        }
      },
      _end: function() {
        this.ended = this.options.autoplay;
        this._timer(false);
        this._fireEvent("end", {
          slide: this.current(true)
        });
      },
      play: function() {
        if (!this.paused) {
          return;
        }
        this._fireEvent("play", {
          slide: this.current(true)
        });
        this.paused = false;
        this.next();
      },
      pause: function() {
        this._timer(false);
        this.paused = true;
        this._fireEvent("pause", {
          slide: this.current(true)
        });
      },
      toggle: function() {
        this.paused ? this.play() : this.pause();
      },
      playing: function() {
        return !this.paused && !this.noshow;
      },
      current: function(advanced) {
        if (advanced) {
          return {
            slide: this.slide,
            data: this.slides[this.slide]
          };
        }
        return this.slide;
      },
      jump: function(n2) {
        if (n2 <= 0 || n2 > this.slides.length || n2 === this.slide + 1) {
          return this;
        }
        this.slide = n2 - 1;
        this._fireEvent("jump", {
          slide: this.current(true)
        });
        this._goto(this.slide);
      },
      next: function() {
        var o2 = this.options;
        this.slide++;
        if (this.slide >= this.slides.length) {
          if (!o2.loop) {
            return this._end();
          }
          this.slide = 0;
        }
        this._fireEvent("next", {
          slide: this.current(true)
        });
        this._goto(this.slide);
      },
      prev: function() {
        var o2 = this.options;
        this.slide--;
        if (this.slide < 0) {
          if (!o2.loop) {
            this.slide++;
            return this._end();
          }
          this.slide = this.slides.length - 1;
        }
        this._fireEvent("prev", {
          slide: this.current(true)
        });
        this._goto(this.slide);
      },
      changeAttribute: function(attr) {
        var element2 = this.element, o2 = this.options;
        var propName = Str.camelCase(attr.replace("data-", ""));
        if (propName === "slides") {
          o2.slides = element2.attr("data-slides");
          this.slides = Utils.isObject(o2.slides) || [];
          this.total = this.slides.length;
          this.noshow = this.total < 2;
          this.paused = !this.options.autoplay || this.noshow;
        } else {
          if (typeof VegasDefaultConfig[propName] !== "undefined")
            o2[propName] = JSON.parse(element2.attr(attr));
        }
      },
      destroy: function() {
        var element2 = this.element, o2 = this.options;
        clearTimeout(this.timeout);
        element2.removeClass("vegas-container");
        element2.find("> .vegas-slide").remove();
        element2.find("> .vegas-wrapper").children().appendTo(element2);
        element2.find("> .vegas-wrapper").remove();
        if (o2.timer) {
          this.timer.remove();
        }
        if (o2.overlay) {
          this.overlay.remove();
        }
        return element2[0];
      }
    });
  })(Metro, Dom);

  // source/components/video-player/video-player.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var VideoPlayerDefaultConfig = {
      videoDeferred: 0,
      src: null,
      poster: "",
      logo: "",
      logoHeight: 32,
      logoWidth: "auto",
      logoTarget: "",
      volume: 0.5,
      loop: false,
      autoplay: false,
      fullScreenMode: Metro2.fullScreenMode.DESKTOP,
      aspectRatio: Metro2.aspectRatio.HD,
      controlsHide: 3e3,
      showLoop: true,
      showPlay: true,
      showStop: true,
      showMute: true,
      showFull: true,
      showStream: true,
      showVolume: true,
      showInfo: true,
      loopIcon: "\u{1F501}",
      stopIcon: "\u23F9",
      playIcon: "\u25B6",
      pauseIcon: "\u23F8",
      muteIcon: "\u{1F507}",
      volumeLowIcon: "\u{1F508}",
      volumeMediumIcon: "\u{1F509}",
      volumeHighIcon: "\u{1F50A}",
      screenMoreIcon: "\u2B1C",
      screenLessIcon: "\u2B1A",
      onPlay: Metro2.noop,
      onPause: Metro2.noop,
      onStop: Metro2.noop,
      onEnd: Metro2.noop,
      onMetadata: Metro2.noop,
      onTime: Metro2.noop,
      onVideoPlayerCreate: Metro2.noop
    };
    Metro2.videoPlayerSetup = function(options) {
      VideoPlayerDefaultConfig = $5.extend({}, VideoPlayerDefaultConfig, options);
    };
    if (typeof globalThis["metroVideoPlayerSetup"] !== "undefined") {
      Metro2.videoPlayerSetup(globalThis["metroVideoPlayerSetup"]);
    }
    Metro2.Component("video-player", {
      init: function(options, elem) {
        this._super(elem, options, VideoPlayerDefaultConfig, {
          fullscreen: false,
          preloader: null,
          player: null,
          video: elem,
          stream: null,
          volume: null,
          volumeBackup: 0,
          muted: false,
          fullScreenInterval: false,
          isPlaying: false,
          id: Utils.elementId("video-player")
        });
        return this;
      },
      _create: function() {
        var element2 = this.element, o2 = this.options;
        if (Metro2.fullScreenEnabled === false) {
          o2.fullScreenMode = Metro2.fullScreenMode.WINDOW;
        }
        this._createPlayer();
        this._createControls();
        this._createEvents();
        this._setAspectRatio();
        if (o2.autoplay === true) {
          this.play();
        }
        this._fireEvent("video-player-create", {
          element: element2,
          player: this.player
        });
      },
      _createPlayer: function() {
        var element2 = this.element, o2 = this.options, video = this.video;
        var player = $5("<div>").addClass("media-player video-player " + element2[0].className);
        var preloader = $5("<div>").addClass("preloader").appendTo(player);
        var logo = $5("<a>").attr("href", o2.logoTarget).addClass("logo").appendTo(player);
        player.insertBefore(element2);
        element2.appendTo(player);
        $5.each(["muted", "autoplay", "controls", "height", "width", "loop", "poster", "preload"], function() {
          element2.removeAttr(this);
        });
        element2.attr("preload", "auto");
        if (o2.poster !== "") {
          element2.attr("poster", o2.poster);
        }
        video.volume = o2.volume;
        preloader.activity({
          type: "cycle",
          style: "color"
        });
        preloader.hide();
        this.preloader = preloader;
        if (o2.logo !== "") {
          $5("<img>").css({
            height: o2.logoHeight,
            width: o2.logoWidth
          }).attr("src", o2.logo).appendTo(logo);
        }
        if (o2.src !== null) {
          this._setSource(o2.src);
        }
        element2[0].className = "";
        this.player = player;
      },
      _setSource: function(src) {
        var element2 = this.element;
        element2.find("source").remove();
        element2.removeAttr("src");
        if (Array.isArray(src)) {
          $5.each(src, function() {
            var item = this;
            if (item.src === void 0) return;
            $5("<source>").attr("src", item.src).attr("type", item.type !== void 0 ? item.type : "").appendTo(element2);
          });
        } else {
          element2.attr("src", src);
        }
      },
      _createControls: function() {
        var that = this, element2 = this.element, o2 = this.options, video = this.elem;
        var controls = $5("<div>").addClass("controls").addClass(o2.clsControls).insertAfter(element2);
        var stream = $5("<div>").addClass("stream").appendTo(controls);
        var streamSlider = $5("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);
        var volume = $5("<div>").addClass("volume").appendTo(controls);
        var volumeSlider = $5("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);
        var infoBox = $5("<div>").addClass("info-box").appendTo(controls);
        if (o2.showInfo !== true) {
          infoBox.hide();
        }
        Metro2.makePlugin(streamSlider, "slider", {
          clsMarker: "bg-red",
          clsHint: "bg-cyan fg-white",
          clsComplete: "bg-cyan",
          hint: true,
          onStart: function() {
            if (!video.paused) video.pause();
          },
          onStop: function(val) {
            if (video.seekable.length > 0) {
              video.currentTime = (that.duration * val / 100).toFixed(0);
            }
            if (video.paused && video.currentTime > 0) {
              video.play();
            }
          }
        });
        this.stream = streamSlider;
        if (o2.showStream !== true) {
          stream.hide();
        }
        Metro2.makePlugin(volumeSlider, "slider", {
          clsMarker: "bg-red",
          clsHint: "bg-cyan fg-white",
          hint: true,
          value: o2.volume * 100,
          onChangeValue: function(val) {
            video.volume = val / 100;
          }
        });
        this.volume = volumeSlider;
        if (o2.showVolume !== true) {
          volume.hide();
        }
        var loop;
        if (o2.showLoop === true) loop = $5("<button>").attr("type", "button").addClass("button square loop").html(o2.loopIcon).appendTo(controls);
        if (o2.showPlay === true) $5("<button>").attr("type", "button").addClass("button square play").html(o2.playIcon).appendTo(controls);
        if (o2.showStop === true) $5("<button>").attr("type", "button").addClass("button square stop").html(o2.stopIcon).appendTo(controls);
        if (o2.showMute === true) $5("<button>").attr("type", "button").addClass("button square mute").html(o2.muteIcon).appendTo(controls);
        if (o2.showFull === true) $5("<button>").attr("type", "button").addClass("button square full").html(o2.screenMoreIcon).appendTo(controls);
        if (o2.loop === true) {
          loop.addClass("active");
          element2.attr("loop", "loop");
        }
        this._setVolume();
        if (o2.muted) {
          that.volumeBackup = video.volume;
          Metro2.getPlugin(that.volume, "slider").val(0);
          video.volume = 0;
        }
        infoBox.html("00:00 / 00:00");
      },
      _createEvents: function() {
        var that = this, element2 = this.element, o2 = this.options, video = this.elem, player = this.player;
        element2.on("loadstart", function() {
          that.preloader.show();
        });
        element2.on("loadedmetadata", function() {
          that.duration = video.duration.toFixed(0);
          that._setInfo(0, that.duration);
          Utils.exec(o2.onMetadata, [video, player], element2[0]);
        });
        element2.on("canplay", function() {
          that._setBuffer();
          that.preloader.hide();
        });
        element2.on("progress", function() {
          that._setBuffer();
        });
        element2.on("timeupdate", function() {
          var position = Math.round(video.currentTime * 100 / that.duration);
          that._setInfo(video.currentTime, that.duration);
          Metro2.getPlugin(that.stream, "slider").val(position);
          Utils.exec(o2.onTime, [video.currentTime, that.duration, video, player], element2[0]);
        });
        element2.on("waiting", function() {
          that.preloader.show();
        });
        element2.on("loadeddata", function() {
        });
        element2.on("play", function() {
          player.find(".play").html(o2.pauseIcon);
          Utils.exec(o2.onPlay, [video, player], element2[0]);
          that._onMouse();
        });
        element2.on("pause", function() {
          player.find(".play").html(o2.playIcon);
          Utils.exec(o2.onPause, [video, player], element2[0]);
          that._offMouse();
        });
        element2.on("stop", function() {
          Metro2.getPlugin(that.stream, "slider").val(0);
          Utils.exec(o2.onStop, [video, player], element2[0]);
          that._offMouse();
        });
        element2.on("ended", function() {
          Metro2.getPlugin(that.stream, "slider").val(0);
          Utils.exec(o2.onEnd, [video, player], element2[0]);
          that._offMouse();
        });
        element2.on("volumechange", function() {
          that._setVolume();
        });
        player.on(Metro2.events.click, ".play", function() {
          if (video.paused) {
            that.play();
          } else {
            that.pause();
          }
        });
        player.on(Metro2.events.click, ".stop", function() {
          that.stop();
        });
        player.on(Metro2.events.click, ".mute", function() {
          that._toggleMute();
        });
        player.on(Metro2.events.click, ".loop", function() {
          that._toggleLoop();
        });
        player.on(Metro2.events.click, ".full", function() {
          that.fullscreen = !that.fullscreen;
          player.find(".full").html(that.fullscreen === true ? o2.screenLessIcon : o2.screenMoreIcon);
          if (o2.fullScreenMode === Metro2.fullScreenMode.WINDOW) {
            if (that.fullscreen === true) {
              player.addClass("full-screen");
            } else {
              player.removeClass("full-screen");
            }
          } else {
            if (that.fullscreen === true) {
              Metro2.requestFullScreen(video);
              if (that.fullScreenInterval === false) that.fullScreenInterval = setInterval(function() {
                if (Metro2.inFullScreen() === false) {
                  that.fullscreen = false;
                  clearInterval(that.fullScreenInterval);
                  that.fullScreenInterval = false;
                  player.find(".full").html(o2.screenMoreIcon);
                }
              }, 1e3);
            } else {
              Metro2.exitFullScreen();
            }
          }
        });
        $5(globalThis).on(Metro2.events.keyup, function(e2) {
          if (that.fullscreen && e2.keyCode === 27) {
            player.find(".full").click();
          }
        }, { ns: this.id });
        $5(globalThis).on(Metro2.events.resize, function() {
          that._setAspectRatio();
        }, { ns: this.id });
      },
      _onMouse: function() {
        var o2 = this.options, player = this.player;
        player.on(Metro2.events.enter, function() {
          var controls = player.find(".controls");
          if (o2.controlsHide > 0 && controls.style("display") === "none") {
            controls.stop(true).fadeIn(500, function() {
              controls.css("display", "flex");
            });
          }
        });
        player.on(Metro2.events.leave, function() {
          var controls = player.find(".controls");
          if (o2.controlsHide > 0 && parseInt(controls.style("opacity")) === 1) {
            setTimeout(function() {
              controls.stop(true).fadeOut(500);
            }, o2.controlsHide);
          }
        });
      },
      _offMouse: function() {
        var player = this.player, o2 = this.options;
        var controls = player.find(".controls");
        player.off(Metro2.events.enter);
        player.off(Metro2.events.leave);
        if (o2.controlsHide > 0 && controls.style("display") === "none") {
          controls.stop(true).fadeIn(500, function() {
            controls.css("display", "flex");
          });
        }
      },
      _toggleLoop: function() {
        var loop = this.player.find(".loop");
        if (loop.length === 0) return;
        loop.toggleClass("active");
        if (loop.hasClass("active")) {
          this.element.attr("loop", "loop");
        } else {
          this.element.removeAttr("loop");
        }
      },
      _toggleMute: function() {
        this.muted = !this.muted;
        if (this.muted === false) {
          this.video.volume = this.volumeBackup;
        } else {
          this.volumeBackup = this.video.volume;
          this.video.volume = 0;
        }
        Metro2.getPlugin(this.volume, "slider").val(this.muted === false ? this.volumeBackup * 100 : 0);
      },
      _setInfo: function(a3, b4) {
        this.player.find(".info-box").html(Utils.secondsToFormattedString(Math.round(a3)) + " / " + Utils.secondsToFormattedString(Math.round(b4)));
      },
      _setBuffer: function() {
        var buffer = this.video.buffered.length ? Math.round(Math.floor(this.video.buffered.end(0)) / Math.floor(this.video.duration) * 100) : 0;
        Metro2.getPlugin(this.stream, "slider").buff(buffer);
      },
      _setVolume: function() {
        var video = this.video, player = this.player, o2 = this.options;
        var volumeButton = player.find(".mute");
        var volume = video.volume * 100;
        if (volume > 1 && volume < 30) {
          volumeButton.html(o2.volumeLowIcon);
        } else if (volume >= 30 && volume < 60) {
          volumeButton.html(o2.volumeMediumIcon);
        } else if (volume >= 60 && volume <= 100) {
          volumeButton.html(o2.volumeHighIcon);
        } else {
          volumeButton.html(o2.muteIcon);
        }
      },
      _setAspectRatio: function() {
        var player = this.player, o2 = this.options;
        var width = player.outerWidth();
        var height;
        switch (o2.aspectRatio) {
          case Metro2.aspectRatio.SD:
            height = Utils.aspectRatioH(width, "4/3");
            break;
          case Metro2.aspectRatio.CINEMA:
            height = Utils.aspectRatioH(width, "21/9");
            break;
          default:
            height = Utils.aspectRatioH(width, "16/9");
        }
        player.outerHeight(height);
      },
      aspectRatio: function(ratio) {
        this.options.aspectRatio = ratio;
        this._setAspectRatio();
      },
      play: function(src) {
        if (src) {
          this._setSource(src);
        }
        if (this.element.attr("src") === void 0 && this.element.find("source").length === 0) {
          return;
        }
        this.isPlaying = true;
        this.video.play();
      },
      pause: function() {
        this.isPlaying = false;
        this.video.pause();
      },
      resume: function() {
        if (this.video.paused) {
          this.play();
        }
      },
      stop: function() {
        this.isPlaying = false;
        this.video.pause();
        this.video.currentTime = 0;
        Metro2.getPlugin(this.stream, "slider").val(0);
        this._offMouse();
      },
      setVolume: function(v4) {
        if (v4 === void 0) {
          return this.video.volume;
        }
        if (v4 > 1) {
          v4 /= 100;
        }
        this.video.volume = v4;
        Metro2.getPlugin(this.volume[0], "slider").val(v4 * 100);
      },
      loop: function() {
        this._toggleLoop();
      },
      mute: function() {
        this._toggleMute();
      },
      changeAspectRatio: function() {
        this.options.aspectRatio = this.element.attr("data-aspect-ratio");
        this._setAspectRatio();
      },
      changeSource: function() {
        var src = JSON.parse(this.element.attr("data-src"));
        this.play(src);
      },
      changeVolume: function() {
        var volume = this.element.attr("data-volume");
        this.setVolume(volume);
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-aspect-ratio":
            this.changeAspectRatio();
            break;
          case "data-src":
            this.changeSource();
            break;
          case "data-volume":
            this.changeVolume();
            break;
        }
      },
      destroy: function() {
        var element2 = this.element, player = this.player;
        Metro2.getPlugin(this.stream, "slider").destroy();
        Metro2.getPlugin(this.volume, "slider").destroy();
        element2.off("loadstart");
        element2.off("loadedmetadata");
        element2.off("canplay");
        element2.off("progress");
        element2.off("timeupdate");
        element2.off("waiting");
        element2.off("loadeddata");
        element2.off("play");
        element2.off("pause");
        element2.off("stop");
        element2.off("ended");
        element2.off("volumechange");
        player.off(Metro2.events.click, ".play");
        player.off(Metro2.events.click, ".stop");
        player.off(Metro2.events.click, ".mute");
        player.off(Metro2.events.click, ".loop");
        player.off(Metro2.events.click, ".full");
        $5(globalThis).off(Metro2.events.keyup, { ns: this.id });
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // source/components/viewport-check/viewport-check.js
  (function(Metro2, $5) {
    "use strict";
    var Utils = Metro2.utils;
    var ViewportCheckDefaultConfig = {
      onViewport: Metro2.noop,
      onViewportEnter: Metro2.noop,
      onViewportLeave: Metro2.noop,
      onViewportCheckCreate: Metro2.noop
    };
    Metro2.viewportCheckSetup = function(options) {
      ViewportCheckDefaultConfig = $5.extend({}, ViewportCheckDefaultConfig, options);
    };
    if (typeof globalThis["metroViewportCheckSetup"] !== "undefined") {
      Metro2.viewportCheckSetup(globalThis["metroViewportCheckSetup"]);
    }
    Metro2.Component("viewport-check", {
      init: function(options, elem) {
        this._super(elem, options, ViewportCheckDefaultConfig, {
          // define instance vars here
          inViewport: false,
          id: Utils.elementId("viewport-check")
        });
        return this;
      },
      _create: function() {
        this.inViewport = Utils.inViewport(this.elem);
        this._createEvents();
        this._fireEvent("viewport-check-create");
      },
      _createEvents: function() {
        var that = this, elem = this.elem;
        $5(globalThis).on(Metro2.events.scroll, function() {
          var oldState = that.inViewport;
          that.inViewport = Utils.inViewport(elem);
          if (oldState !== that.inViewport) {
            if (that.inViewport) {
              that._fireEvent("viewport-enter");
            } else {
              that._fireEvent("viewport-leave");
            }
          }
          that._fireEvent("viewport", {
            state: that.inViewport
          });
        }, { ns: that.id });
      },
      state: function() {
        return this.inViewport;
      },
      destroy: function() {
        $5(globalThis).off(Metro2.events.scroll, { ns: this.id });
        return this.element;
      }
    });
  })(Metro, Dom);

  // source/components/window/window.js
  (function(Metro2, $5) {
    "use strict";
    let WindowDefaultConfig = {
      _runtime: false,
      windowDeferred: 0,
      hidden: false,
      width: "auto",
      height: "auto",
      btnClose: true,
      btnMin: true,
      btnMax: true,
      draggable: true,
      dragElement: ".window-caption .title",
      dragArea: "parent",
      shadow: false,
      icon: "",
      title: "Window",
      content: null,
      resizable: true,
      overlay: false,
      overlayColor: "transparent",
      overlayAlpha: 0.5,
      modal: false,
      position: "absolute",
      checkEmbed: true,
      top: "auto",
      left: "auto",
      place: "auto",
      closeAction: Metro2.actions.HIDE,
      customButtons: null,
      status: "",
      canClose: true,
      canMaximize: true,
      canMinimize: true,
      clsCustomButton: "",
      clsCaption: "",
      clsContent: "",
      clsWindow: "",
      minWidth: 0,
      minHeight: 0,
      maxWidth: 0,
      maxHeight: 0,
      onDragStart: Metro2.noop,
      onDragStop: Metro2.noop,
      onDragMove: Metro2.noop,
      onWindowClick: Metro2.noop,
      onCaptionClick: Metro2.noop,
      onCaptionDblClick: Metro2.noop,
      onCloseClick: Metro2.noop,
      onMaxClick: Metro2.noop,
      onMinClick: Metro2.noop,
      onResizeStart: Metro2.noop,
      onResizeStop: Metro2.noop,
      onResize: Metro2.noop,
      onWindowCreate: Metro2.noop,
      onShow: Metro2.noop,
      onWindowDestroy: Metro2.noop,
      onCanClose: Metro2.noop_true,
      onMinimize: Metro2.noop,
      onMaximize: Metro2.noop,
      onClose: Metro2.noop
    };
    Metro2.windowSetup = function(options) {
      WindowDefaultConfig = $5.extend({}, WindowDefaultConfig, options);
    };
    if (typeof globalThis["metroWindowSetup"] !== "undefined") {
      Metro2.windowSetup(globalThis["metroWindowSetup"]);
    }
    Metro2.Component("window", {
      init: function(options, elem) {
        this._super(elem, options, WindowDefaultConfig, {
          win: null,
          overlay: null,
          position: {
            top: 0,
            left: 0
          },
          hidden: false,
          content: null
        });
        return this;
      },
      _create: function() {
        const that = this, element2 = this.element, o2 = this.options;
        let win, overlay;
        const parent2 = o2.dragArea === "parent" ? element2.parent() : $5(o2.dragArea);
        let _content;
        if (o2.modal === true) {
          o2.btnMax = false;
          o2.btnMin = false;
          o2.resizable = false;
        }
        if (Metro2.utils.isNull(o2.content)) {
          o2.content = element2;
        } else {
          if (Metro2.utils.isUrl(o2.content) && Metro2.utils.isVideoUrl(o2.content)) {
            o2.content = Metro2.utils.embedUrl(o2.content);
            element2.css({
              height: "100%"
            });
          } else if (!Metro2.utils.isQ(o2.content) && Metro2.utils.isFunc(o2.content)) {
            o2.content = Metro2.utils.exec(o2.content);
          }
          _content = $5(o2.content);
          if (_content.length === 0) {
            element2.appendText(o2.content);
          } else {
            element2.append(_content);
          }
          o2.content = element2;
        }
        if (o2._runtime === true) {
          this._runtime(element2, "window");
        }
        win = this._window(o2);
        win.addClass("no-visible");
        parent2.append(win);
        if (o2.overlay === true) {
          overlay = this._overlay();
          overlay.appendTo(win.parent());
          this.overlay = overlay;
        }
        this.win = win;
        this._fireEvent("window-create", {
          win: this.win[0],
          element: element2
        });
        setTimeout(function() {
          that._setPosition();
          if (o2.hidden !== true) {
            that.win.removeClass("no-visible");
          }
          that._fireEvent("show", {
            win: that.win[0],
            element: element2
          });
        }, 100);
      },
      _setPosition: function() {
        const o2 = this.options;
        const win = this.win;
        const parent2 = o2.dragArea === "parent" ? win.parent() : $5(o2.dragArea);
        const top_center = parent2.height() / 2 - win[0].offsetHeight / 2;
        const left_center = parent2.width() / 2 - win[0].offsetWidth / 2;
        let top, left, right, bottom;
        if (o2.place !== "auto") {
          switch (o2.place.toLowerCase()) {
            case "top-left":
              top = 0;
              left = 0;
              right = "auto";
              bottom = "auto";
              break;
            case "top-center":
              top = 0;
              left = left_center;
              right = "auto";
              bottom = "auto";
              break;
            case "top-right":
              top = 0;
              right = 0;
              left = "auto";
              bottom = "auto";
              break;
            case "right-center":
              top = top_center;
              right = 0;
              left = "auto";
              bottom = "auto";
              break;
            case "bottom-right":
              bottom = 0;
              right = 0;
              left = "auto";
              top = "auto";
              break;
            case "bottom-center":
              bottom = 0;
              left = left_center;
              right = "auto";
              top = "auto";
              break;
            case "bottom-left":
              bottom = 0;
              left = 0;
              right = "auto";
              top = "auto";
              break;
            case "left-center":
              top = top_center;
              left = 0;
              right = "auto";
              bottom = "auto";
              break;
            default:
              top = top_center;
              left = left_center;
              bottom = "auto";
              right = "auto";
          }
          win.css({
            top,
            left,
            bottom,
            right
          });
        }
      },
      _window: function(o2) {
        const that = this;
        let win, caption, content, icon, title, buttons, btnClose, btnMin, btnMax, resizer, status;
        let width = o2.width, height = o2.height;
        win = $5("<div>").addClass("window");
        if (o2.modal === true) {
          win.addClass("modal");
        }
        caption = $5("<div>").addClass("window-caption");
        content = $5("<div>").addClass("window-content");
        win.append(caption);
        win.append(content);
        if (o2.status || o2.resizable) {
          status = $5("<div>").addClass("window-status").html(o2.status);
          win.append(status);
        }
        if (o2.shadow === true) {
          win.addClass("shadowed");
        }
        if (Metro2.utils.isValue(o2.icon)) {
          icon = $5("<span>").addClass("icon").html(o2.icon);
          icon.appendTo(caption);
        }
        title = $5("<span>").addClass("title").html(Metro2.utils.isValue(o2.title) ? o2.title : "&nbsp;");
        title.appendTo(caption);
        if (!Metro2.utils.isNull(o2.content)) {
          if (Metro2.utils.isQ(o2.content)) {
            o2.content.appendTo(content);
          } else {
            content.html(o2.content);
          }
        }
        buttons = $5("<div>").addClass("buttons");
        buttons.appendTo(caption);
        if (o2.btnMax === true) {
          btnMax = $5("<span>").addClass("button small square btn-max sys-button");
          btnMax.appendTo(buttons);
        }
        if (o2.btnMin === true) {
          btnMin = $5("<span>").addClass("button small square btn-min sys-button");
          btnMin.appendTo(buttons);
        }
        if (o2.btnClose === true) {
          btnClose = $5("<span>").addClass("button small square btn-close sys-button");
          btnClose.appendTo(buttons);
        }
        if (o2.customButtons) {
          let customButtons = Metro2.utils.isObject(o2.customButtons);
          if (customButtons) {
            $5.each(customButtons, function() {
              const item = this;
              const customButton = $5("<span>");
              customButton.addClass("button btn-custom").addClass(o2.clsCustomButton).addClass(item.cls).attr("tabindex", -1).html(item.html);
              if (item.attr && typeof item.attr === "object") {
                $5.each(item.attr, function(k4, v4) {
                  customButton.attr(Str.dashedName(k4), v4);
                });
              }
              customButton.data("action", item.onclick);
              buttons.prepend(customButton);
            });
          }
        }
        caption.on(Metro2.events.click, ".btn-custom", function(e2) {
          if (Metro2.utils.isRightMouse(e2)) return;
          const button = $5(this);
          const action = button.data("action");
          Metro2.utils.exec(action, [button], this);
        });
        win.attr("id", o2.id === void 0 ? Metro2.utils.elementId("window") : o2.id);
        win.on(Metro2.events.startAll, ".window-caption", function(e2) {
          that._fireEvent("caption-click", {
            win: win[0],
            e: e2
          });
        });
        win.on(Metro2.events.dblclick, ".window-caption", function(e2) {
          that.maximize(e2);
        });
        caption.on(Metro2.events.click, ".btn-max, .btn-min, .btn-close", function(e2) {
          if (Metro2.utils.isRightMouse(e2)) return;
          const target = $5(e2.target);
          if (target.hasClass("btn-max") && o2.canMaximize) that.maximize(e2);
          if (target.hasClass("btn-min") && o2.canMinimize) that.minimize(e2);
          if (target.hasClass("btn-close") && o2.canClose) that.close(e2);
        });
        win.on(Metro2.events.click, function(e2) {
          that._fireEvent("window-click", {
            win: win[0],
            e: e2
          });
        });
        if (o2.draggable === true) {
          Metro2.makePlugin(win, "draggable", {
            dragContext: win[0],
            dragElement: caption,
            dragArea: o2.dragArea,
            onDragStart: o2.onDragStart,
            onDragStop: o2.onDragStop,
            onDragMove: o2.onDragMove
          });
        }
        win.addClass(o2.clsWindow);
        caption.addClass(o2.clsCaption);
        content.addClass(o2.clsContent);
        if (o2.minWidth === 0) {
          o2.minWidth = 34;
          $5.each(buttons.children(".btn-custom"), function() {
            o2.minWidth += Metro2.utils.hiddenElementSize(this).width;
          });
          if (o2.btnMax) o2.minWidth += 34;
          if (o2.btnMin) o2.minWidth += 34;
          if (o2.btnClose) o2.minWidth += 34;
        }
        if (o2.minWidth > 0 && !isNaN(o2.width) && o2.width < o2.minWidth) {
          width = o2.minWidth;
        }
        if (o2.minHeight > 0 && !isNaN(o2.height) && o2.height > o2.minHeight) {
          height = o2.minHeight;
        }
        if (o2.resizable) {
          resizer = $5("<span>").addClass("resize-element");
          resizer.appendTo(win);
          win.addClass("resizable");
          Metro2.makePlugin(win, "resizable", {
            minWidth: o2.minWidth,
            minHeight: o2.minHeight,
            maxWidth: o2.maxWidth,
            maxHeight: o2.maxHeight,
            resizeElement: ".resize-element",
            onResizeStart: o2.onResizeStart,
            onResizeStop: o2.onResizeStop,
            onResize: o2.onResize
          });
        }
        win.css({
          width,
          height,
          position: o2.position,
          top: o2.top,
          left: o2.left
        });
        return win;
      },
      _overlay: function() {
        const o2 = this.options;
        const overlay = $5("<div>");
        overlay.addClass("overlay");
        if (o2.overlayColor === "transparent") {
          overlay.addClass("transparent");
        } else {
          overlay.css({
            background: Farbe.Routines.toRGBA(Farbe.Routines.parse(o2.overlayColor), o2.overlayAlpha)
          });
        }
        return overlay;
      },
      width: function(v4) {
        const win = this.win;
        if (!Metro2.utils.isValue(v4)) {
          return win.width();
        }
        win.css("width", parseInt(v4));
        return this;
      },
      height: function(v4) {
        const win = this.win;
        if (!Metro2.utils.isValue(v4)) {
          return win.height();
        }
        win.css("height", parseInt(v4));
        return this;
      },
      maximize: function(e2) {
        const win = this.win, o2 = this.options;
        const target = $5(e2.target);
        if (o2.btnMax) {
          win.removeClass("minimized");
          win.toggleClass("maximized");
        }
        if (target.hasClass && target.hasClass("title")) {
          this._fireEvent("caption-dbl-click", {
            win: win[0]
          });
        } else {
          this._fireEvent("max-click", {
            win: win[0]
          });
        }
        this._fireEvent("maximize", {
          win: win[0]
        });
      },
      minimize: function() {
        const win = this.win, o2 = this.options;
        if (o2.btnMin) {
          win.removeClass("maximized");
          win.toggleClass("minimized");
        }
        this._fireEvent("min-click", {
          win: win[0]
        });
        this._fireEvent("minimize", {
          win: win[0]
        });
      },
      close: function() {
        const that = this, win = this.win, o2 = this.options;
        if (Metro2.utils.exec(o2.onCanClose, [win]) === false) {
          return false;
        }
        let timeout = 0;
        if (o2.onClose !== Metro2.noop) {
          timeout = 500;
        }
        this._fireEvent("close", {
          win: win[0]
        });
        setTimeout(function() {
          if (o2.modal === true) {
            win.siblings(".overlay").remove();
          }
          that._fireEvent("close-click", {
            win: win[0]
          });
          if (o2.closeAction === Metro2.actions.REMOVE) {
            that._fireEvent("window-destroy", {
              win: win[0]
            });
            win.remove();
          } else {
            that.hide();
          }
        }, timeout);
      },
      hide: function() {
        const win = this.win;
        win.css({
          display: "none"
        });
        this._fireEvent("hide", {
          win: win[0]
        });
      },
      show: function() {
        const win = this.win;
        win.removeClass("no-visible").css({
          display: "flex"
        });
        this._fireEvent("show", {
          win: win[0]
        });
      },
      toggle: function() {
        if (this.win.css("display") === "none" || this.win.hasClass("no-visible")) {
          this.show();
        } else {
          this.hide();
        }
      },
      isOpen: function() {
        return this.win.hasClass("no-visible");
      },
      min: function(a3) {
        a3 ? this.win.addClass("minimized") : this.win.removeClass("minimized");
      },
      max: function(a3) {
        a3 ? this.win.addClass("maximized") : this.win.removeClass("maximized");
      },
      changeClass: function(a3) {
        const element2 = this.element, win = this.win, o2 = this.options;
        if (a3 === "data-cls-window") {
          win[0].className = "window " + (o2.resizable ? " resizable " : " ") + element2.attr("data-cls-window");
        }
        if (a3 === "data-cls-caption") {
          win.find(".window-caption")[0].className = "window-caption " + element2.attr("data-cls-caption");
        }
        if (a3 === "data-cls-content") {
          win.find(".window-content")[0].className = "window-content " + element2.attr("data-cls-content");
        }
      },
      toggleShadow: function() {
        const element2 = this.element, win = this.win;
        const flag = JSON.parse(element2.attr("data-shadow"));
        if (flag === true) {
          win.addClass("win-shadow");
        } else {
          win.removeClass("win-shadow");
        }
      },
      setContent: function(c3) {
        const element2 = this.element, win = this.win;
        const content = Metro2.utils.isValue(c3) ? c3 : element2.attr("data-content");
        let result;
        if (!Metro2.utils.isQ(content) && Metro2.utils.isFunc(content)) {
          result = Metro2.utils.exec(content);
        } else if (Metro2.utils.isQ(content)) {
          result = content.html();
        } else {
          result = content;
        }
        win.find(".window-content").html(result);
      },
      setTitle: function(t) {
        const element2 = this.element, win = this.win;
        const title = Metro2.utils.isValue(t) ? t : element2.attr("data-title");
        win.find(".window-caption .title").html(title);
      },
      setIcon: function(i3) {
        const element2 = this.element, win = this.win;
        const icon = Metro2.utils.isValue(i3) ? i3 : element2.attr("data-icon");
        win.find(".window-caption .icon").html(icon);
      },
      getIcon: function() {
        return this.win.find(".window-caption .icon").html();
      },
      getTitle: function() {
        return this.win.find(".window-caption .title").html();
      },
      toggleDraggable: function(f5) {
        const win = this.win;
        const flag = Metro2.utils.bool(f5);
        const drag = Metro2.getPlugin(win, "draggable");
        if (flag === true) {
          drag.on();
        } else {
          drag.off();
        }
      },
      toggleResizable: function(f5) {
        const win = this.win;
        const flag = Metro2.utils.bool(f5);
        const resize = Metro2.getPlugin(win, "resizable");
        if (flag === true) {
          resize.on();
          win.find(".resize-element").removeClass("resize-element-disabled");
        } else {
          resize.off();
          win.find(".resize-element").addClass("resize-element-disabled");
        }
      },
      changePlace: function(p3) {
        const element2 = this.element, win = this.win;
        const place = Metro2.utils.isValue(p3) ? p3 : element2.attr("data-place");
        win.addClass(place);
      },
      pos: function(top, left) {
        const win = this.win;
        win.css({
          top,
          left
        });
        return this;
      },
      top: function(v4) {
        this.win.css({
          top: v4
        });
        return this;
      },
      left: function(v4) {
        this.win.css({
          left: v4
        });
        return this;
      },
      changeAttribute: function(attr, value) {
        const changePos = function(a3, v4) {
          const win = this.win;
          let pos;
          if (a3 === "data-top") {
            pos = parseInt(v4);
            if (!isNaN(pos)) {
              return;
            }
            win.css("top", pos);
          }
          if (a3 === "data-left") {
            pos = parseInt(v4);
            if (!isNaN(pos)) {
              return;
            }
            win.css("left", pos);
          }
        };
        const toggleButtons = function(a3, v4) {
          const win = this.win;
          const btnClose = win.find(".btn-close");
          const btnMin = win.find(".btn-min");
          const btnMax = win.find(".btn-max");
          const _v = Metro2.utils.bool(v4);
          const func = _v ? "show" : "hide";
          switch (a3) {
            case "data-btn-close":
              btnClose[func]();
              break;
            case "data-btn-min":
              btnMin[func]();
              break;
            case "data-btn-max":
              btnMax[func]();
              break;
          }
        };
        const changeSize = function(a3, v4) {
          const win = this.win;
          if (a3 === "data-width") {
            win.css("width", +v4);
          }
          if (a3 === "data-height") {
            win.css("height", +v4);
          }
        };
        switch (attr) {
          case "data-btn-close":
          case "data-btn-min":
          case "data-btn-max":
            toggleButtons(attr, value);
            break;
          case "data-width":
          case "data-height":
            changeSize(attr, value);
            break;
          case "data-cls-window":
          case "data-cls-caption":
          case "data-cls-content":
            this.changeClass(attr);
            break;
          case "data-shadow":
            this.toggleShadow();
            break;
          case "data-icon":
            this.setIcon();
            break;
          case "data-title":
            this.setTitle();
            break;
          case "data-content":
            this.setContent();
            break;
          case "data-draggable":
            this.toggleDraggable(value);
            break;
          case "data-resizable":
            this.toggleResizable(value);
            break;
          case "data-top":
          case "data-left":
            changePos(attr, value);
            break;
          case "data-place":
            this.changePlace();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2["window"] = {
      isWindow: function(el) {
        return Metro2.utils.isMetroObject(el, "window");
      },
      min: function(el, a3) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").min(a3);
      },
      max: function(el, a3) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").max(a3);
      },
      show: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").show();
      },
      hide: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").hide();
      },
      toggle: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").toggle();
      },
      isOpen: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        const win = Metro2.getPlugin(el, "window");
        return win.isOpen();
      },
      close: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").close();
      },
      pos: function(el, top, left) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").pos(top, left);
      },
      top: function(el, top) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").top(top);
      },
      left: function(el, left) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").left(left);
      },
      width: function(el, width) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").width(width);
      },
      height: function(el, height) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").height(height);
      },
      create: function(options, parent2) {
        let w5;
        w5 = $5("<div>").appendTo(parent2 ? $5(parent2) : $5("body"));
        const w_options = $5.extend({
          _runtime: true
        }, options ? options : {});
        Metro2.makePlugin(w5, "window", w_options);
        return Metro2.getPlugin(w5, "window").win;
      }
    };
  })(Metro, Dom);

  // source/components/wizard/wizard.js
  (function(Metro2, $5) {
    "use strict";
    let WizardDefaultConfig = {
      wizardDeferred: 0,
      start: 1,
      finish: 0,
      iconHelp: "\u{1F4A1}",
      iconPrev: "\u{1F850}",
      iconNext: "\u{1F852}",
      iconFinish: "\u2714",
      buttonMode: "cycle",
      // default, cycle, square
      buttonOutline: true,
      duration: 300,
      clsWizard: "",
      clsActions: "",
      clsHelp: "",
      clsPrev: "",
      clsNext: "",
      clsFinish: "",
      onPage: Metro2.noop,
      onNextPage: Metro2.noop,
      onPrevPage: Metro2.noop,
      onFirstPage: Metro2.noop,
      onLastPage: Metro2.noop,
      onFinishPage: Metro2.noop,
      onHelpClick: Metro2.noop,
      onPrevClick: Metro2.noop,
      onNextClick: Metro2.noop,
      onFinishClick: Metro2.noop,
      onBeforePrev: Metro2.noop_true,
      onBeforeNext: Metro2.noop_true,
      onWizardCreate: Metro2.noop
    };
    Metro2.wizardSetup = function(options) {
      WizardDefaultConfig = $5.extend({}, WizardDefaultConfig, options);
    };
    if (typeof globalThis["metroWizardSetup"] !== "undefined") {
      Metro2.wizardSetup(globalThis["metroWizardSetup"]);
    }
    Metro2.Component("wizard", {
      init: function(options, elem) {
        this._super(elem, options, WizardDefaultConfig, {
          id: Metro2.utils.elementId("wizard")
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createWizard();
        this._createEvents();
        this._fireEvent("wizard-create", {
          element: element2
        });
      },
      _createWizard: function() {
        const element2 = this.element, o2 = this.options;
        let bar;
        element2.addClass("wizard").addClass(o2.view).addClass(o2.clsWizard);
        bar = $5("<div>").addClass("action-bar").addClass(o2.clsActions).appendTo(element2);
        let buttonMode = o2.buttonMode === "button" ? "" : o2.buttonMode;
        if (o2.buttonOutline === true) {
          buttonMode += " outline";
        }
        if (o2.iconHelp !== false) $5("<button>").attr("type", "button").addClass("button wizard-btn-help").addClass(buttonMode).addClass(o2.clsHelp).html(o2.iconHelp).appendTo(bar);
        if (o2.iconPrev !== false) $5("<button>").attr("type", "button").addClass("button wizard-btn-prev").addClass(buttonMode).addClass(o2.clsPrev).html(o2.iconPrev).appendTo(bar);
        if (o2.iconNext !== false) $5("<button>").attr("type", "button").addClass("button wizard-btn-next").addClass(buttonMode).addClass(o2.clsNext).html(o2.iconNext).appendTo(bar);
        if (o2.iconFinish !== false) $5("<button>").attr("type", "button").addClass("button wizard-btn-finish").addClass(buttonMode).addClass(o2.clsFinish).html(o2.iconFinish).appendTo(bar);
        this.toPage(o2.start);
        this._setHeight();
      },
      _setHeight: function() {
        const element2 = this.element;
        const pages = element2.children("section");
        let max_height = 0;
        pages.children(".page-content").css("max-height", "none");
        $5.each(pages, function() {
          const h3 = $5(this).height();
          if (max_height < parseInt(h3)) {
            max_height = h3;
          }
        });
        element2.height(max_height);
      },
      _createEvents: function() {
        const that = this, element2 = this.element;
        element2.on(Metro2.events.click, ".wizard-btn-help", function() {
          const pages = element2.children("section");
          const page = pages.get(that.current - 1);
          that._fireEvent("help-click", {
            index: that.current,
            page
          });
        });
        element2.on(Metro2.events.click, ".wizard-btn-prev", function() {
          that.prev();
          const pages = element2.children("section");
          const page = pages.get(that.current - 1);
          that._fireEvent("prev-click", {
            index: that.current,
            page
          });
        });
        element2.on(Metro2.events.click, ".wizard-btn-next", function() {
          that.next();
          const pages = element2.children("section");
          const page = pages.get(that.current - 1);
          that._fireEvent("next-click", {
            index: that.current,
            page
          });
        });
        element2.on(Metro2.events.click, ".wizard-btn-finish", function() {
          const pages = element2.children("section");
          const page = pages.get(that.current - 1);
          that._fireEvent("finish-click", {
            index: that.current,
            page
          });
        });
        element2.on(Metro2.events.click, ".complete", function() {
          const index = $5(this).index() + 1;
          that.toPage(index);
        });
        $5(globalThis).on(Metro2.events.resize, function() {
          that._setHeight();
        }, { ns: this.id });
      },
      next: function() {
        const that = this, element2 = this.element, o2 = this.options;
        const pages = element2.children("section");
        let page = $5(element2.children("section").get(this.current - 1));
        if (this.current + 1 > pages.length || Metro2.utils.exec(o2.onBeforeNext, [this.current, page, element2]) === false) {
          return;
        }
        this.current++;
        this.toPage(this.current);
        page = $5(element2.children("section").get(this.current - 1));
        this._fireEvent("next-page", {
          index: that.current,
          page: page[0]
        });
      },
      prev: function() {
        const that = this, element2 = this.element, o2 = this.options;
        let page = $5(element2.children("section").get(this.current - 1));
        if (this.current - 1 === 0 || Metro2.utils.exec(o2.onBeforePrev, [this.current, page, element2]) === false) {
          return;
        }
        this.current--;
        this.toPage(this.current);
        page = $5(element2.children("section").get(this.current - 1));
        this._fireEvent("prev-page", {
          index: that.current,
          page: page[0]
        });
      },
      last: function() {
        const that = this, element2 = this.element;
        let page;
        this.toPage(element2.children("section").length);
        page = $5(element2.children("section").get(this.current - 1));
        this._fireEvent("last-page", {
          index: that.current,
          page: page[0]
        });
      },
      first: function() {
        const that = this, element2 = this.element;
        let page;
        this.toPage(1);
        page = $5(element2.children("section").get(0));
        this._fireEvent("first-page", {
          index: that.current,
          page: page[0]
        });
      },
      toPage: function(page) {
        const element2 = this.element, o2 = this.options;
        const target = $5(element2.children("section").get(page - 1));
        const sections = element2.children("section");
        const actions = element2.find(".action-bar");
        if (target.length === 0) {
          return;
        }
        const finish = element2.find(".wizard-btn-finish").addClass("disabled");
        const next = element2.find(".wizard-btn-next").addClass("disabled");
        const prev = element2.find(".wizard-btn-prev").addClass("disabled");
        this.current = page;
        element2.children("section").removeClass("complete current").removeClass(o2.clsCurrent).removeClass(o2.clsComplete);
        target.addClass("current").addClass(o2.clsCurrent);
        target.prevAll().addClass("complete").addClass(o2.clsComplete);
        const border_size = element2.children("section.complete").length === 0 ? 0 : parseInt(Metro2.utils.getStyleOne(element2.children("section.complete")[0], "border-left-width"));
        actions.animate({
          draw: {
            left: element2.children("section.complete").length * border_size + 41
          },
          dur: o2.duration
        });
        if (this.current === sections.length || o2.finish > 0 && this.current >= o2.finish) {
          finish.removeClass("disabled");
        }
        if (parseInt(o2.finish) > 0 && this.current === parseInt(o2.finish)) {
          this._fireEvent("finish-page", {
            index: this.current,
            page: target[0]
          });
        }
        if (this.current < sections.length) {
          next.removeClass("disabled");
        }
        if (this.current > 1) {
          prev.removeClass("disabled");
        }
        this._fireEvent("page", {
          index: this.current,
          page: target[0]
        });
      },
      changeAttribute: function() {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".wizard-btn-help");
        element2.off(Metro2.events.click, ".wizard-btn-prev");
        element2.off(Metro2.events.click, ".wizard-btn-next");
        element2.off(Metro2.events.click, ".wizard-btn-finish");
        element2.off(Metro2.events.click, ".complete");
        $5(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // source/components/working-tree/working-tree.js
  (function(Metro2, $5) {
    "use strict";
    let WorkingTreeDefaultConfig = {
      onStateChange: Metro2.noop,
      onWorkingTreeCreate: Metro2.noop
    };
    Metro2.workingTreeSetup = function(options) {
      WorkingTreeDefaultConfig = $5.extend({}, WorkingTreeDefaultConfig, options);
    };
    if (typeof globalThis["metroWorkingTreeSetup"] !== "undefined") {
      Metro2.workingTreeSetup(globalThis["metroWorkingTreeSetup"]);
    }
    Metro2.Component("working-tree", {
      init(options, elem) {
        this._super(elem, options, WorkingTreeDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("tree-create");
      },
      addNode({ id, title = "", value = "", items = [] } = {}) {
        const element2 = this.element;
        const nodeId = (id || Hooks.useId(`working-tree-node-${element2.children().length}`)).replace(/:/gi, "");
        const node = `
                <li id="${nodeId}">
                    <div class="bull"></div>
                    <div class="node">
                        <div class="title">${title}</div>
                        <div class="value">${value}</div>
                    </div>
                    <ul class="leaves">
                        ${items.map((i3) => `<li><div class="title">${i3.title}</div><div class="value">${i3.value}</div> </li>`).join("\n")}                    
                    </ul>
                </li>
            `;
        this.element.append(node);
        return nodeId;
      },
      setState(id, state2 = "pending") {
        const element2 = this.element;
        const node = element2.find(`#${id}`).clearClasses().addClass(`work-${state2}`);
        node.find(".bull").html(`<span data-role="bull" data-type="${state2}"></span>`);
        this._fireEvent("state-change", { id, state: state2, node });
        return this;
      },
      _createStructure() {
        const that = this, element2 = this.element, o2 = this.options;
        element2.addClass("working-tree");
      },
      _createEvents() {
        const that = this, element2 = this.element, o2 = this.options;
      },
      changeAttribute(attr, newValue) {
      },
      destroy() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // source/components/drop-menu/drop-menu.js
  (function(Metro2, $5) {
    "use strict";
    const participants = `[data-role-dropmenu], [data-role-dropdown]`;
    const toggleImage = `<svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path></svg>`;
    let DropMenuDefaultConfig = {
      height: "auto",
      align: "left",
      // left, right
      onMenuCreate: Metro2.noop
    };
    Metro2.dropMenuSetup = function(options) {
      DropMenuDefaultConfig = $5.extend({}, DropMenuDefaultConfig, options);
    };
    if (typeof globalThis["metroDropMenuSetup"] !== "undefined") {
      Metro2.dropMenuSetup(globalThis["metroDropMenuSetup"]);
    }
    Metro2.Component("dropmenu", {
      init: function(options, elem) {
        this._super(elem, options, DropMenuDefaultConfig, {
          toggle: null,
          displayOrigin: null,
          isOpen: false,
          level: 0
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("menu-create");
      },
      _toggle: function() {
        const element2 = this.element;
        let toggle = element2.siblings(".menu-toggle, .dropdown-toggle, a");
        if (toggle.length === 0) {
          toggle = element2.prev();
          if (toggle.length === 0) {
            throw new Error("Menu toggle not found");
          }
        }
        return toggle[0];
      },
      _createStructure: function() {
        const element2 = this.element, o2 = this.options;
        this.level = element2.parents("[data-role-dropmenu]").length;
        this.toggle = $5(this._toggle()).append(toggleImage);
        this.displayOrigin = element2.css("display");
        this.element.addClass("drop-menu").css("z-index", `calc(var(--z-index-fixed) + ${this.level})!important`).hide();
        if (o2.height !== "auto") {
          element2.css("max-height", o2.height);
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        this.toggle.on("click", (e2) => {
          $5(participants).each((i3, el) => {
            const $el = $5(el);
            const isSubMenu = element2.parents("[data-role-dropmenu]").is(el);
            if (el === element2[0] || isSubMenu || $el.hasClass("keep-open") || $el.hasClass("stay-open") || $el.hasClass("ignore-document-click")) return;
            const dd = Metro2.getPlugin(el, "dropdown");
            const dm = Metro2.getPlugin(el, "dropmenu");
            if (dd) {
              dd.close();
            }
            if (dm) {
              dm.close();
            }
          });
          if (this.isOpen === false) {
            this.open();
          } else {
            this.close();
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      close: function() {
        if (this.isOpen === false) {
          return;
        }
        this.toggle.removeClass("active-toggle");
        this.element.hide();
        this.isOpen = false;
      },
      open: function() {
        const element2 = this.element, o2 = this.options;
        const toggleRect = Metro2.utils.rect(this.toggle[0]);
        const level = element2.parents("[data-role-dropmenu]").length;
        element2.show().visible(false);
        if (level === 0) {
          element2.css({
            top: toggleRect.bottom,
            left: toggleRect.left
          });
          let wOut = Metro2.utils.viewportOutByWidth(element2[0]);
          let hOut = Metro2.utils.viewportOutByHeight(element2[0]);
          if (o2.align === "right" || wOut) {
            element2.css({
              left: toggleRect.right - element2.width()
            });
            if (o2.align !== "right" && Metro2.utils.viewportOutByWidth(element2[0])) {
              element2.css({
                left: toggleRect.left
              });
            }
          }
          if (hOut) {
            element2.css({
              top: toggleRect.top - element2.height()
            });
            if (Metro2.utils.viewportOutByHeight(element2[0])) {
              element2.css({
                top: toggleRect.bottom
              });
            }
          }
        } else {
          element2.css({
            top: toggleRect.top,
            left: toggleRect.right
          });
          let wOut = Metro2.utils.viewportOutByWidth(element2[0]);
          if (o2.align === "right" || wOut) {
            element2.css({
              left: toggleRect.left - element2.width()
            });
            if (o2.align !== "right" && Metro2.utils.viewportOutByWidth(element2[0])) {
              element2.css({
                left: toggleRect.right
              });
            }
          }
        }
        this.toggle.addClass("active-toggle");
        this.isOpen = true;
        element2.visible(true);
      },
      changeAttribute: function(attr, newValue) {
      },
      destroy: function() {
        this.element.remove();
      }
    });
    $5(document).on("click", function(e2) {
      $5(participants).each((i3, el) => {
        const $el = $5(el);
        if ($el.hasClass("keep-open") || $el.hasClass("stay-open") || $el.hasClass("ignore-document-click")) return;
        const dd = Metro2.getPlugin(el, "dropdown");
        const dm = Metro2.getPlugin(el, "dropmenu");
        if (dd) {
          dd.close();
        }
        if (dm) {
          dm.close();
        }
      });
    });
  })(Metro, Dom);
})();
//!node.hasClass("expanded");
/*! Bundled license information:

@olton/datetime/dist/datetime.js:
  (*!
   * Datetime v3.2.2.
   * Build time: 09.03.2025, 06:30:54
   * Copyright 2025 by Serhii Pimenov
   * Licensed under MIT
   *
   * Build time: 09.03.2025 06:30:54
   *)

@olton/string/dist/string.js:
  (*!
   * String v0.10.0 (@olton/string)
   * Copyright 2025 by Serhii Pimenov
   * Built: 16.03.2025, 19:17:56
   * Licensed under MIT
   *)

@olton/dom/dist/dom.js:
  (*!
   * DOM - Work with HTML elements (@olton/dom, https://metroui.org.ua)
   * Version: 1.4.0
   * Build date: 08.03.2025, 03:24:58
   * Copyright 2012-2025 by Serhii Pimenov
   * Licensed under MIT
   *)

@olton/hooks/dist/hooks.js:
  (*!
   * Hooks v0.13.0 (@olton/hooks)
   * Copyright 2025 by Serhii Pimenov <serhii@pimenov.com.ua>
   * Built: 07.03.2025, 15:05:04
   * Licensed under MIT
   *)

@olton/farbe/dist/farbe.es.js:
  (*!
   * Farbe  v1.0.4 - Color manipulation library
   * Copyright 2024 by Serhii Pimenov
   * Licensed under MIT
   !*)

@olton/html/dist/html.js:
  (*!
   * Html.js v0.14.0
   * Description: Creating HTML Elements with JavaScript
   * Build: 18.03.2025, 23:11:45
   * Copyright 2025 by Serhii Pimenov
   * Licensed under MIT
   *)

@olton/guardian/dist/guardian.js:
  (*!
   * Guardian v0.7.1
   * Data guard and validation library
   * Copyright 2025 Serhii Pimenov
   * Licensed under MIT
   *
   * Build time: 07.02.2025 03:04:31
   *)

@olton/router/dist/router.js:
  (*!
   * Router v0.4.0 (Router ror SPA)
   * Build: 08.03.2025, 01:01:34
   * Copyright 2025 by Serhii Pimenov
   * Licensed under MIT
   *)

@olton/model/dist/model.js:
  (*!
   * Model v0.17.0
   * Build: 06.03.2025, 13:09:45
   * Copyright 2012-2025 by Serhii Pimenov
   * Licensed under MIT
   *)
*/
//# sourceMappingURL=metro.js.map
